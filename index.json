[{"categories":["Misc","CTF"],"contents":"In this post I will solve the challenge called Serializado, created for the Ekoparty 2020 - Mobile Hacking Space CTF. In this challenge we have the following file.\nserializable.ab\nThe serializable.ab seems to be a back-up created through an Android OS. In order to get the content of the file we can execute the following command:\ndd if=serializable.ab bs=1 skip=24 | python -c \u0026#34;import zlib,sys;sys.stdout.write(zlib.decompress(sys.stdin.read()))\u0026#34; | tar -xvf - This will generate the following result:\n apps/com.mhs.serializado/manifest apps/com.mhs.serializado/a/base.apk apps/com.mhs.serializado/r/key.ser apps/com.mhs.serializado/r/content.txt  In order to check what is each file, we have to open the base.apk file, which is the application backed-up in this file:\njadx-gui apps/com.mhs.serializado/a/base.apk In this application we have two activitied, SplashActivity.java (which is a splash screen page with no logic), and MainActivity.java which has two buttons btnStore and btnLoad.\nWe check what the btnStore does by going through the decompiled source code:\n get bytes from txtSecretPassword value:  String content = MainActivity.this.txtSecretPassword.getText().toString(); ... byte[] key = content.getBytes(StandardCharsets.UTF_8); Generate a CipherManagement class:  CipherManagement cipherManagement = new CipherManagement(); int i = 0; cipherManagement.x1 = key[0]; cipherManagement.x2 = key[1]; cipherManagement.x3 = key[2]; cipherManagement.x4 = key[3]; cipherManagement.x5 = key[4]; cipherManagement.x6 = key[5]; cipherManagement.x7 = key[6]; cipherManagement.x8 = key[7]; cipherManagement.x9 = key[8]; cipherManagement.x10 = key[9]; cipherManagement.x11 = key[10]; cipherManagement.x12 = key[11]; cipherManagement.x13 = key[12]; cipherManagement.x14 = key[13]; cipherManagement.x15 = key[14]; cipherManagement.x16 = key[15]; cipherManagement.generateSecret(); Call serializeObject from class Serializer. This class does, but here we can see that there is a key.ser String, which is the name of a file in the backup found.  Serializer.serializeObject(cipherManagement, \u0026#34;key.ser\u0026#34;); Generates a file called ontent.txt with the value taken from txtContent, encrypted through the CipherManagement class, and then encoded in Base64. That is the second file we have in the backup.  String multiLines = MainActivity.this.txtContent.getText().toString(); try { FileOutputStream fOut = new FileOutputStream(new File(\u0026#34;/data/data/com.mhs.serializado/content.txt\u0026#34;)); OutputStreamWriter myOutWriter = new OutputStreamWriter(fOut); String[] lines = multiLines.split(\u0026#34;\\n\u0026#34;); try { int length = lines.length; int i2 = 0; while (i2 \u0026lt; length) { myOutWriter.append(Base64.encodeToString(cipherManagement.encrypt(lines[i2]), i)); i2++; i = 0; } } catch (Exception e) { e.printStackTrace(); } myOutWriter.close(); fOut.flush(); fOut.close(); } catch (IOException e2) { Log.e(\u0026#34;Exception\u0026#34;, \u0026#34;File write failed: \u0026#34; + e2.toString()); } In the case of the btnLoad, the application does the following:\n Recover the key from the key.ser file:  CipherManagement cipherManagement = (CipherManagement) Serializer.deserializeObject(\u0026#34;key.ser\u0026#34;); if (cipherManagement == null) { Toast.makeText(MainActivity.this.getApplicationContext(), \u0026#34;Nothing encrypted yet\u0026#34;, 1).show(); return; } Sets the keyin the txtSecretPassword field:  byte[] key = {cipherManagement.x1, cipherManagement.x2, cipherManagement.x3, cipherManagement.x4, cipherManagement.x5, cipherManagement.x6, cipherManagement.x7, cipherManagement.x8, cipherManagement.x9, cipherManagement.x10, cipherManagement.x11, cipherManagement.x12, cipherManagement.x13, cipherManagement.x14, cipherManagement.x15, cipherManagement.x16}; cipherManagement.generateSecret(); MainActivity.this.txtSecretPassword.setText(new String(key, StandardCharsets.UTF_8)); Gets the content of the content.txt file, and tries to decode it. First it decodes the content of the fi√±e with a Base64 decoder, then the application tries to decrypt the decoded text with the CipherManagement class, and the result is being set in the txtContext field.  new InputStreamReader(new FileInputStream(new File(\u0026#34;/data/data/com.mhs.serializado/content.txt\u0026#34;))); StringBuilder resultingContent = new StringBuilder(); if (Build.VERSION.SDK_INT \u0026gt;= 26) { for (String line : Files.readAllLines(Paths.get(\u0026#34;/data/data/com.mhs.serializado/content.txt\u0026#34;, new String[0]), Charset.defaultCharset())) { String decodedLine = cipherManagement.decrypt(Base64.decode(line, 0)); resultingContent.append(decodedLine + \u0026#34;\\n\u0026#34;); } } MainActivity.this.txtContent.setText(resultingContent.toString()); The Serializer stores and loads a Java serialized object in the root package of the application. In this case the object being stored and loaded is a ChiperManagement instance, which holds the key.\nAfter the analysis of the source code, we need to install the application and upload the backup.\nSo we first try to install the apk:\nadb install apps/com.mhs.serializado/a/base.apk which returns the following output:\nPerforming Streamed Install adb: failed to install apps/com.mhs.serializado/a/base.apk: Failure [INSTALL_FAILED_TEST_ONLY: installPackageLI] this error is due to a flag of test in the manifest. We need to add a -t option in the adb install command to avoid this error:\nadb install -t apps/com.mhs.serializado/a/base.apk Now we need to restore the backup. As this is trivial in this case I will do it manually:\nadb shell rm /data/data/com.mhs.serializado/content.txt adb shell rm /data/data/com.mhs.serializado/key.ser adb push content.txt /data/data/com.mhs.serializado adb push key.ser /data/data/com.mhs.serializado Now we need to change the user rights on the files. So first you need to know the name of the user assigned by Android to the application, which will depend on the cellphone, so execute:\nadb shell ls -al /data/data/com.mhs.serializado where you will get the a content similar to the following one:\ndrwx------ 4 u0_a118 u0_a118 4096 2020-11-28 17:00 . drwxrwx--x 169 system system 12288 2020-11-09 12:08 .. drwxrws--x 2 u0_a118 u0_a118_cache 4096 2020-08-18 03:10 cache drwxrws--x 2 u0_a118 u0_a118_cache 4096 2020-08-18 03:10 code_cache In this case the user is u0_118, so we execute:\nadb shell chown u0_a118:u0_a118 /data/data/com.mhs.serializado/content.txt adb shell chown u0_a118:u0_a118 /data/data/com.mhs.serializado/key.ser When we try to restore the content we get an error in the log:\nSystem.out I IOException is caught We have no information about what is going on, so let\u0026rsquo;s check the content of the key file. As it is a Java-serialized object, we can use a tool called SerializationDumper (add link here).\njava -jar SerializationDumper-v1.13.jar -f key.ser STREAM_MAGIC - 0xac ed STREAM_VERSION - 0x00 05 Contents TC_OBJECT - 0x73 TC_CLASSDESC - 0x72 className Length - 36 - 0x00 24 Value - com.mhs.serializado.CipherManagement - 0x636f6d2e6d68732e73657269616c697a61646f2e4369706865724d616e6167656d656e74 serialVersionUID - 0xb2 8a 53 35 20 34 41 18 newHandle 0x00 7e 00 00 classDescFlags - 0x02 - SC_SERIALIZABLE fieldCount - 16 - 0x00 10 Fields 0: Byte - B - 0x42 fieldName Length - 2 - 0x00 02 Value - x1 - 0x7831 1: Byte - B - 0x42 ... 15: Byte - B - 0x42 fieldName Length - 2 - 0x00 02 Value - x9 - 0x7839 classAnnotations TC_ENDBLOCKDATA - 0x78 superClassDesc TC_NULL - 0x70 newHandle 0x00 7e 00 01 classdata com.mhs.serializado.CipherManagement values x1 (byte)97 (ASCII: a) - 0x61 x10 ... x6 (byte)57 (ASCII: 9) - 0x39 x7 Exception in thread \u0026#34;main\u0026#34; java.util.NoSuchElementException at java.util.LinkedList.removeFirst(LinkedList.java:270) at java.util.LinkedList.pop(LinkedList.java:801) at nb.deser.SerializationDumper.readByteField(SerializationDumper.java:1369) at nb.deser.SerializationDumper.readFieldValue(SerializationDumper.java:953) at nb.deser.SerializationDumper.readClassDataField(SerializationDumper.java:939) at nb.deser.SerializationDumper.readClassData(SerializationDumper.java:886) at nb.deser.SerializationDumper.readNewObject(SerializationDumper.java:467) at nb.deser.SerializationDumper.readContentElement(SerializationDumper.java:359) at nb.deser.SerializationDumper.parseStream(SerializationDumper.java:331) at nb.deser.SerializationDumper.main(SerializationDumper.java:113) Through the error we get that the serialized file seems to be corrupted. There seems to be three values missing. As we can see in the definition of the class:\npublic class CipherManagement implements Serializable { private transient byte[] inferedKey = new byte[16]; public byte x1; public byte x10; public byte x11; public byte x12; public byte x13; public byte x14; public byte x15; public byte x16; public byte x2; public byte x3; public byte x4; public byte x5; public byte x6; public byte x7; public byte x8; public byte x9; Now we can assume the following:\n The known values are ordered. We do not know which values are missing. We\u0026rsquo;ll try to test this with alphanumeric (a-zA-Z0-9) and if that does not work we\u0026rsquo;ll test it with printable characters.  I built the following java application in order to test this, and make the process faster than using Frida:\npublic static void main(String[] args) { // TODO Auto-generated method stub \tString content = \u0026#34;jBUwXJdjVaHvZuYfaw/cew==\u0026#34;; byte array[] = Base64.getDecoder().decode(content); CipherManagement cipher = new CipherManagement(); cipher.generateSecret(); CharsetEncoder encoder = Charset.forName(\u0026#34;US-ASCII\u0026#34;).newEncoder(); //starting time \tprintTime(); // rotating positions \tfor (int pos1 = 0; pos1 \u0026lt; 14; pos1++) { for (int pos2 = pos1 + 1; pos2 \u0026lt; 15; pos2++) { for (int pos3 = pos2 + 1; pos3 \u0026lt; 16; pos3++) { setStaticValues(cipher, pos1, pos2, pos3); //bruteforcing just alphanumeric values to check if it returns results fast. \tfor (byte x = 49; x \u0026lt;= 122; x++) { setValue(cipher, pos1, x); for (byte y = 49; y \u0026lt;= 122; y++) { setValue(cipher, pos2, y); for (byte z = 49; z \u0026lt;= 122; z++) { setValue(cipher, pos3, z); cipher.generateSecret(); String decrypted; try { decrypted = cipher.decrypt(array); //this filters the solutions sent to output, but still there are false positives. \tif (encoder.canEncode(decrypted)) { System.out.println(decrypted); //this loop is just to measure what time it takes to get the key \tif (\u0026#34;banana_loca\u0026#34;.equals(decrypted)) { printTime(); return; } } } catch (Exception e) { // TODO Auto-generated catch block \t} } } } } } } } the full source code is in the following repository: solving-serializado\nWith this algorithm I found the key in 13,5 minutes, and decrypted the content of the text that is \u0026ldquo;banana_loca\u0026rdquo;.\n","permalink":"https://cmrodriguez.me/blog/solving-serialized/","tags":null,"title":"CTF - Solving Serialized"},{"categories":["Frida","Android"],"contents":"In this guide I will show how to write scripts in Frida. The idea is not to show how Frida works or what can be done with it, there are plenty of those kind of blogs around. While using this amazing tool I find sometimes hard to know how to write a script in order to make the application do what I want to, and as the documentation does not go too deep on that, sometimes I find myself going through different examples till I find how to solve something related to the syntaxis of the Java bridge. So I wrote this guide in order to concentrate that knowledge in one place.\nThe content is divided in several pages, in order to make it easily searchable. In the content you\u0026rsquo;ll find how to write Java code in the Frida-bridge syntaxis. So I\u0026rsquo;ll go through different Java language features and how to write it as a script in Frida. In order to do this, I wrote an application that has many classes that uses different components (like Interfaces, arrays or anonymous classes). Each page will have a brief introduction of the Java feature (not a through one, as it is only intended to make the user understand what is being done in the code), explain how to do the same with Frida and then an example of how it was done in the demo application. The source code and the application can be downloaded from the following github page: https://github.com/CesarMRodriguez/frida-scripting-guide/\nIndex  Primitive types Methods Access to content of classes \u0026ldquo;this\u0026rdquo; reference Arrays Enums Inheritance Interfaces Inner classes Exception handling  ","permalink":"https://cmrodriguez.me/blog/frida-scripting-guide/","tags":["Android","Frida","Scripting guide"],"title":"Frida Scripting Guide for Java"},{"categories":["Misc"],"contents":"Hi there! My name is Cesar! It will be next April 3 years, since I am advocated full time to my Security Career. Now I\u0026rsquo;m working as a Security Researcher in Faraday Security Labs. I started my career not knowing what I wanted to do, as my only experience with security was related to development.\nDuring these years I\u0026rsquo;ve been working on different technologies, programming languages, so it was hard for me to find something I particularly liked or wanted to do with my professional career, till I got to do a Mobile application security assessment. It was a mix of Java/Objective-C/Swift (as I am a Java developer this technology is natural for me), hardware, client-side exploitation, native OS library reversing, web application assessment (hybrid libraries) and an endless quantity of frameworks.\nIt was pretty hard for me to start doing mobile assessments, because there are a lot of concepts, restrictions and techniques that are different from the Web security discipline. So in this blog I\u0026rsquo;ll try to help others in the process of getting into the Mobile Security world, and my passion for this environment.\n","permalink":"https://cmrodriguez.me/blog/hello-world/","tags":null,"title":"Hello World!"},{"categories":["Frida","Android"],"contents":"In this post I will explain how to use and instance different data types from Java with Frida. In Java we have the following basic types:\n byte: Byte-length integer short: Short integer int: Integer long: Long integer float: Single-precision floating point double: Double-precision floating point char: A single character boolean: A Boolean value (true or false)  Using integer types The different integer types are casted by frida automatically to the Javascript numeric type, which is capable of holding the the long Java type without loosing information. As an example the following code calls different functions from the BasicTypes class, and they are printed by Frida with no need to cast the types:\nvar BasicTypes = Java.use(\u0026#34;com.blog.testfrida.examples.BasicTypes\u0026#34;); console.log(\u0026#34;addTwoInts: \u0026#34; + BasicTypes.addTwoInts(1,2)); console.log(\u0026#34;addTwoBytes: \u0026#34; + BasicTypes.addTwoBytes(1+1,3)); console.log(\u0026#34;addTwoShorts: \u0026#34; + BasicTypes.addTwoShorts(1-1,4)); console.log(\u0026#34;addTwoLongs: \u0026#34; + BasicTypes.addTwoLongs(1*1,5)); console.log(\u0026#34;addTwoInts: \u0026#34; + BasicTypes.addTwoInts(1/1,2));   console.log** is the function used to print in the frida CLI application output.\n  BasicTypes** is the javascript wrapper for the BasicTypes class, binded by using the **Java.use** function.\n Frida casts automatically values as well in the reimplementation of functions:\nBasicTypes.addTwoBytes.implementation = function (var1,var2) { console.log(\u0026#34;test addTwoBytes\u0026#34;); return 3+4; } BasicTypes.addTwoShorts.implementation = function (var1,var2) { console.log(\u0026#34;test addTwoShorts\u0026#34;); return 3+4; } BasicTypes.addTwoLongs.implementation = function (var1,var2) { console.log(\u0026#34;test addTwoLongs\u0026#34;); return 3+4; } In this case to test the function, it needs to be run from the Java environment, because the changes are not being reflected on the method in the Frida environment, that is why I created in a button in the Main Activity of the application. So in order to trigger the modified behavior you need to click the button in the application.\nUsing boolean types Frida converts automatically from Java boolean type to javascript boolean with no weird behavior. The following example is used to send boolean values from the Frida bridge to Java, and from Java to the script:\nvar testBooleanValues = function () { var BasicTypes = Java.use(\u0026#34;com.blog.testfrida.examples.BasicTypes\u0026#34;); console.log(BasicTypes.negate(false)); console.log(BasicTypes.negate(true)); BasicTypes.negate.implementation = function (var1) { console.log(\u0026#34;test negate\u0026#34;); return false; } } Using floating point types  WARNING In floating points we see some differences. The issue comes from the use of float values\n As an example, when the 23/3 is executed, the Java operation returns 7.666666507720947, because of the limitation on the precision. But javascript by default has an extended precision, so the division returns 7.666666666666667, as the double Java operation does. So be careful when you override a method as there could be issues when some value is sent to a function that works on floats. The following code shows multiple scenarios of float manipulation:\nvar testFloatValues = function () { var BasicTypes = Java.use(\u0026#34;com.blog.testfrida.examples.BasicTypes\u0026#34;); console.log(\u0026#34;native values\u0026#34;); console.log(23.0/3.0); console.log(0.1234567890123/1); console.log(2/5); console.log(\u0026#34;java values\u0026#34;); console.log(BasicTypes.divideFloat(23,3)); console.log(BasicTypes.divideFloat(0.1234567890123,1)); console.log(BasicTypes.divideDouble(2,5)); console.log(BasicTypes.divideDouble(23,3)); console.log(BasicTypes.divideDouble(0.1234567890123,1)); BasicTypes.divideFloat.implementation = function (var1, var2) { console.log(\u0026#34;test divideFloat\u0026#34;); return var1 / var2; } BasicTypes.divideDouble.implementation = function (var1, var2) { console.log(\u0026#34;test divideDouble\u0026#34;); return var1 / var2; } } which returns the following output:\njavascript values\n 23/3: 7.666666666666667 0.1234567890123/1: 0.1234567890123 2/5: 0.4  java values\n 23/3 (float): 7.666666507720947 0.1234567890123/1 (float): 0.12345679104328156 2/5(float): 0.4 23/3 (double): 7.666666666666667 0.1234567890123/1 (double): 0.1234567890123  Using char types Frida converts automatically from Java char type to javascript char with no weird behavior. The following example is used to send char values from the Frida bridge to Java, and from Java to the script:\nvar testCharValues = function () { var BasicTypes = Java.use(\u0026#34;com.blog.testfrida.examples.BasicTypes\u0026#34;); console.log(BasicTypes.getNextChar(\u0026#39;a\u0026#39;)); console.log(BasicTypes.isCChar(\u0026#39;f\u0026#39;)); console.log(BasicTypes.isCChar(\u0026#39;c\u0026#39;)); BasicTypes.getNextChar.implementation = function (char1) { return \u0026#39;F\u0026#39;; } BasicTypes.isCChar.implementation = function (char1) { return char1 == \u0026#39;c\u0026#39;; } } Using String type In this case the String is managed as a classic Java Object with some particularities regarding the javascript string type. Based on the previous logic used to send basic type parameters , we could call a method that receives two Strings in the following way:\nvar testStrings = function () { var BasicTypes = Java.use(\u0026#34;com.blog.testfrida.examples.BasicTypes\u0026#34;); console.log(BasicTypes.concatString(\u0026#34;first\u0026#34;,\u0026#34;second\u0026#34;)); } When we run this, we get the following error:\nTypeError: undefined not callable (property \u0026#39;concatString\u0026#39; of [object Object]) at [anon] (../../../frida-gum/bindings/gumjs/duktape.c:65012) at /examples.js:112 at frida/node_modules/frida-java-bridge/lib/vm.js:11 at E (frida/node_modules/frida-java-bridge/index.js:346) at frida/node_modules/frida-java-bridge/index.js:298 at frida/node_modules/frida-java-bridge/lib/vm.js:11 This is an error because the parameter sent is a native javascript String, but it should be encapsulated in a java.lang.String object. So we need to create an instance of the String:\nvar String = Java.use(\u0026#34;java.lang.String\u0026#34;); var str1 = String.$new(\u0026#34;test \u0026#34;); var str2 = String.$new(\u0026#34;String\u0026#34;); console.log(BasicTypes.concatString(str1,str2)); The second step to test is the override of a method that receives one or more String. We created the following function that overrides the concatString method from the example APK:\nBasicTypes.concatString.implementation = function (str1,str2) { console.log(\u0026#34;First string: \u0026#34; + str1); console.log(\u0026#34;Second string: \u0026#34; + str2); return str1 + str2; } This code works perfectly because Frida wraps the String parameters and then returns a Javascript String to the internal implementation. So the concatenation works as in javascript, and Frida is in charge of converting the result to a java.lang.String object. Also the concatenation works with native attributes as it does in Java. As an example the following command works in java and in Javascript in the same way:\n str1\u0026lt;\u0026quot;test \u0026ldquo;\u0026gt; + int1 \u0026lt;2\u0026gt; + str2 \u0026lt;\u0026quot;strings\u0026quot;\u0026gt; = \u0026ldquo;test 2 strings\u0026rdquo;\n String comparison The difference between a comparison between a native variable and a String is that the former is an object. So the variable that the developer manipulates holds a reference (pointer or memory value) to the real object. This is the reason a comparison == does not work with Strings, as it will naturally compare the references from the two Strings instead of the content. So to compare in Frida you should use the following script:\nvar strHex = String.$new(\u0026#34;hex\u0026#34;); console.log(\u0026#34;--\u0026gt; test\u0026#34;); return strHex.equals(str1); Accesing String attributes If the String is in an attribute of a class, and you want to get access from the Frida script, you need to access it through the attribute \u0026ldquo;value\u0026rdquo;, as in the following example:\nvar ScopedObject = Java.use(\u0026#34;com.blog.testfrida.complexobjects.ScopeObject\u0026#34;); console.log(\u0026#34;Direct access: \u0026#34; + ScopedObject.publicStaticObject.value); Encapsulation of attributes (optional) Initially I thought the access to an attribute will be transparent for the frida cli, so the first time I got to the situation of retrieving it, I tested the following FridaSnippet:\nvar ScopedObject = Java.use(\u0026#34;com.blog.testfrida.complexobjects.ScopeObject\u0026#34;); console.log(\u0026#34;Direct access: \u0026#34; + ScopedObject.publicStaticObject); which printed \u0026ldquo;Direct access: [object Object]\u0026quot;. This is due to the fact that the attributes in a Frida Object holds an encapsulation of a class. So when someone access it directly, it will return this content, and in this case it will cast it to the default Object string. To print the raw content of the variable (to check what it is), we can use the JSON.stringify javascript function:\nvar ScopedObject = Java.use(\u0026#34;com.blog.testfrida.complexobjects.ScopeObject\u0026#34;); console.log(\u0026#34;Direct access: \u0026#34; + JSON.stringify(ScopedObject.publicStaticObject)); which will return:\n {\u0026ldquo;fieldType\u0026rdquo;:1,\u0026ldquo;fieldReturnType\u0026rdquo;:{\u0026ldquo;className\u0026rdquo;:\u0026ldquo;java.lang.String\u0026rdquo;,\u0026ldquo;name\u0026rdquo;:\u0026ldquo;Ljava/lang/String;\u0026quot;,\u0026ldquo;type\u0026rdquo;:\u0026ldquo;pointer\u0026rdquo;,\u0026ldquo;size\u0026rdquo;:1},\u0026ldquo;$holder\u0026rdquo;:{}}\n which shows that the field is of type java.lang.String. In order to return the actual value, we should call the attribute value from the Frida Object.\nNext: Methods\n","permalink":"https://cmrodriguez.me/blog/primitive-types/","tags":["Frida","Android","Scripting guide"],"title":"Frida Scripting Guide (1) - Primitive Types"},{"categories":["Frida","Android"],"contents":"In this post I will explain how to call methods from java through Frida. A method is a function that belongs to a class. In Java all the functions are attached to classes. We have two different kind of methods. The static ones, that can be called from a Class, and the non-static that can only be used from an instance of an object. If you need any more information about this, check the following link: Static and Non Static Methods.\nThe following code snippet shows how to call a static method:\nvar BasicTypes = Java.use(\u0026#34;com.blog.testfrida.examples.BasicTypes\u0026#34;); BasicTypes.divideFloat(23,3); To call a non-static method, we need to get first an object, so we need first to get the class reference in Frida:\nvar Person = Java.use(\u0026#34;com.blog.testfrida.complexobjects.Person\u0026#34;); Then we create an object from that class. This special method is called constructor):\nvar personInstance = Person.$new(); personInstance.setId(1); The following code shows how to send parameters to a method:\nvar String = Java.use(\u0026#34;java.lang.String\u0026#34;); personInstance.setName(String.$new(\u0026#34;Peter Griffin\u0026#34;));  Note that the parameters sent have to be javascript encapsulated objects\n Overridden methods In Java there is a possibility to generate overridden methods. Basically it means that two or more methods have the same name and different parameters (in quantity and type). As an example the following java code snippet is valid:\npublic static int multiply(int val1, int val2) { return val1 * val2; } ‚Äã public static byte multiply(byte val1, byte val2) { return (byte) (val1 * val2); } If you want to use an overridden method, the syntax does not change, as Frida solves the method by the argument types, so in the previous example the snippet code to call the multiply operation would be the following one:\nvar BasicTypes = Java.use(\u0026#34;com.blog.testfrida.examples.BasicTypes\u0026#34;); console.log(BasicTypes.multiply(3,5)); The difference in the syntax comes when you want to modify a method with overridden options. The naive approach would be the following one:\nvar BasicTypes = Java.use(\u0026#34;com.blog.testfrida.examples.BasicTypes\u0026#34;); console.log(BasicTypes.multiply(3,5)); ‚Äã BasicTypes.multiply.implementation = function (val1, val2) { console.log(\u0026#34;it works\u0026#34;); return val1 * val2; } If that code is executed, you\u0026rsquo;ll see in the Frida cli console the following error:\nError: multiply(): has more than one overload, use .overload() to choose from: .overload(\u0026#39;long\u0026#39;, \u0026#39;long\u0026#39;) .overload(\u0026#39;byte\u0026#39;, \u0026#39;byte\u0026#39;) .overload(\u0026#39;short\u0026#39;, \u0026#39;short\u0026#39;) .overload(\u0026#39;int\u0026#39;, \u0026#39;int\u0026#39;) .overload(\u0026#39;float\u0026#39;, \u0026#39;float\u0026#39;) at throwOverloadError (frida/node_modules/frida-java-bridge/lib/class-factory.js:1054) at frida/node_modules/frida-java-bridge/lib/class-factory.js:714 at /examples.js:164 which states that you should define which of the overridden methods you want to modify. As an example we\u0026rsquo;ll modify the multiplication of two ints:\nBasicTypes.multiply.overload(\u0026#39;int\u0026#39;,\u0026#39;int\u0026#39;).implementation = function (val1, val2) { return val1 * val2; } Once you start to write Frida scripts, you will eventually find the need to modify or rewrite an overridden method. Not all the types of attributes are written as clear as the basic types. The following table can help to search for the types:\n   Java Type Frida Type     int int   byte byte   short short   long long   float float   double double   char char   {Object} (eg. String) {package}.{Object} (eg. java.lang.String)   int[] [I   byte[] [B   short[] [S   long[] [J   float[] [F   double[] [D   char[] [C   {Object}[] [L{package}.{Object} (eg. [Ljava.lang.String)     Note that the object array starts with a \u0026ldquo;L\u0026rdquo; char.\n If you wander where those weird data types comes from, they are inherited by the dex specification (Java code is transformed in dex format when the application is compiled). Primitives are represented by a single letter. They are actually stored in the dex file, in string form. They are specified in the Dex format document in the AOSP repository.\nAs an example the following script lists all the overridden methods with their signatures:\nfunction listOverritenMethods(className, func) { var Class = Java.use(className); var overloadedMethods = Class[func].overloads; for (i in overloadedMethods) { if (overloadedMethods[i].hasOwnProperty(\u0026#39;argumentTypes\u0026#39;)) { var parameterString = \u0026#34;(\u0026#34;; for (j in overloadedMethods[i].argumentTypes) { parameterString = parameterString + overloadedMethods[i].argumentTypes[j].className + \u0026#34;,\u0026#34;; } parameterString = parameterString.slice(0,-1) + \u0026#34;)\u0026#34;; console.log(func + parameterString); } } } ‚Äã Java.perform(function () { listOverritenMethods(\u0026#34;com.blog.testfrida.examples.BasicTypes\u0026#34;,\u0026#34;multiply\u0026#34;) }); Next: Access to content of classes\n","permalink":"https://cmrodriguez.me/blog/methods/","tags":["Frida","Android","Scripting guide"],"title":"Frida Scripting Guide (2) - Methods"},{"categories":["Frida","Android"],"contents":"TL;DR In this blogpost I show the results of an analysis done over some frida scripts that allows the bypass of the network security configuration in Android. I show a new way to bypass the configuration. Also I will show the procedure used to test the scripts in multiple scenarios, and an analysis of the reason some scripts do not work in all the test-cases.\nA couple of months ago I was in the middle of an Android application security assessment. One of the first steps while preparing the environment to start the pentest is configuring the application to bypass the network security config (check this link for references regarding network security config: https://developer.android.com/training/articles/security-config). As I am a frida fan, I tend to do everything with it (there are other alternatives to do this: https://www.nccgroup.trust/uk/about-us/newsroom-and-events/blogs/2017/november/bypassing-androids-network-security-configuration/).\nI downloaded two or three scripts at that moment, but when I run it in my Android 7.1.0, none of those worked. That was the reason I started to analyze how the network security config worked, and how to bypass it with frida. The first thing I did was to generate different test cases. I tried to choose the most popular ones:\n OKHttp (it is also used in retrofit and volley also) HttpsURLConnection WebView (Chromium in API 25 and 26, and Default WebView in API 24).  Then I generated three applications with different network security config:\n An application that used the default NSC configuration (without network-security-config xml file) - called BypassNSC An application with a NSC file that used only system certificates - called BypassNSC2. An application with a NSC file that enforced the certificate pinning - called BypassNSC3.  At the time of evaluating the scripts with my test suite, only one worked in the 100% of the cases. I also developed an alternative that also works in all of the cases.\nThe code that parses and validates the network security config is in the Android SDK, so it might change between versions. I tested the scripts with the versions 24,25 and 26.\nThe following github repository has all the applications I developed and the scripts I used.\nhttps://github.com/CesarMRodriguez/network-security-config-frida\nThe scripts are called:\n network-security-config-bypass-1.js network-security-config-bypass-2.js network-security-config-bypass-3.js network-security-config-bypass-cr.js \u0026lt;\u0026ndash; this is the one I created  The following is a screenshot of the table I created with the results of the analysis:\nI analysed all the scripts I downloaded to know why it didn\u0026rsquo;t work in some of the scenarios.\nnetwork-security-config-bypass-1.js Original reference: Link\nIn this case the script basically modifies the getEffectiveCertificatesEntryRefs method from the NetworkSecurityConfig.Builder class. This method returns the list of valid certificates. In a standard Android configuration, the list of certificates it returns is the ones installed in the system. In this script, the certificates installed by the user are also returned. So it is logical that the bypass for the first two applications worked, but I was surprised that the ones with the certificate pinning configuration also worked. The method that validates the pinning is the following one:\nandroid.security.net.config.NetworkSecurityTrustManager.checkPins The following stacktrace shows the path executed till it gets to the checkPins function:\nat android.security.net.config.NetworkSecurityTrustManager.checkPins(Native Method) at android.security.net.config.NetworkSecurityTrustManager.checkServerTrusted(NetworkSecurityTrustManager.java:95) at android.security.net.config.RootTrustManager.checkServerTrusted(RootTrustManager.java:88) at com.android.org.conscrypt.Platform.checkServerTrusted(Platform.java:178) at com.android.org.conscrypt.OpenSSLSocketImpl.verifyCertificateChain(OpenSSLSocketImpl.java:596) at com.android.org.conscrypt.NativeCrypto.SSL_do_handshake(Native Method) at com.android.org.conscrypt.OpenSSLSocketImpl.startHandshake(OpenSSLSocketImpl.java:357) ... If the patch is not executed, the following exception is thrown when it gets to that method:\nCaused by: java.security.cert.CertificateException: Pin verification failed at android.security.net.config.NetworkSecurityTrustManager.checkPins(NetworkSecurityTrustManager.java:148) at android.security.net.config.NetworkSecurityTrustManager.checkServerTrusted(NetworkSecurityTrustManager.java:95) at android.security.net.config.RootTrustManager.checkServerTrusted(RootTrustManager.java:88) at com.android.org.conscrypt.Platform.checkServerTrusted(Platform.java:178) at com.android.org.conscrypt.OpenSSLSocketImpl.verifyCertificateChain(OpenSSLSocketImpl.java:596) at com.android.org.conscrypt.NativeCrypto.SSL_do_handshake(Native Method) at com.android.org. Let\u0026rsquo;s check the implementation of this method (API 25):\nprivate void checkPins(List\u0026lt;X509Certificate\u0026gt; chain) throws CertificateException { PinSet pinSet = mNetworkSecurityConfig.getPins(); if (pinSet.pins.isEmpty() || System.currentTimeMillis() \u0026gt; pinSet.expirationTime || !isPinningEnforced(chain)) { return; } Set\u0026lt;String\u0026gt; pinAlgorithms = pinSet.getPinAlgorithms(); Map\u0026lt;String, MessageDigest\u0026gt; digestMap = new ArrayMap\u0026lt;String, MessageDigest\u0026gt;( pinAlgorithms.size()); for (int i = chain.size() - 1; i \u0026gt;= 0 ; i--) { X509Certificate cert = chain.get(i); byte[] encodedSPKI = cert.getPublicKey().getEncoded(); for (String algorithm : pinAlgorithms) { MessageDigest md = digestMap.get(algorithm); if (md == null) { try { md = MessageDigest.getInstance(algorithm); } catch (GeneralSecurityException e) { throw new RuntimeException(e); } digestMap.put(algorithm, md); } if (pinSet.pins.contains(new Pin(algorithm, md.digest(encodedSPKI)))) { return; } } } // TODO: Throw a subclass of CertificateException which indicates a pinning failure.  throw new CertificateException(\u0026#34;Pin verification failed\u0026#34;); } This method receives a list of certificates returned by the site when the communication starts. The first thing it does is checking some conditions:\n the pinset (list of pins loaded during the configuration instantiation) is empty. the pinset has expired at the moment of validation pinning is NOT enforced by configuration  If any of those conditions are true, pinning validation is ignored. In case the validation must be achieved, the application checks if any of the certificates provided by the site matches with one of the pins defined in the network security config file. In that case the validation is successful. If that does not happen, the method throws the exception shown in the previous stacktrace.\nInitially I thought the issue was in the for loop that analyzed each of the certificates, so I added the following log in the frida script:\nvar Pin = Java.use(\u0026#34;android.security.net.config.Pin\u0026#34;); Pin.$init.implementation = function (digestAlg, digest) { var bt = Java.use(\u0026#34;android.util.Log\u0026#34;).getStackTraceString(Java.use(\u0026#34;java.lang.Exception\u0026#34;).$new()); console.log(\u0026#34;\\nBacktrace:\\n\u0026#34; + bt); console.log(digestAlg); return this.$init(digestAlg,digest); } It should print each of the Pins created during the evaluation. When I run the application with the changes I found that the application wasn\u0026rsquo;t getting to that point.\nI thought it could be because of the for loop, so I added a log in the call to pinSet.getPinAlgorithms(), that was executed before the for loop:\nvar PinSet = Java.use(\u0026#34;android.security.net.config.PinSet\u0026#34;); PinSet.getPinAlgorithms.implementation = function () { var bt = Java.use(\u0026#34;android.util.Log\u0026#34;).getStackTraceString(Java.use(\u0026#34;java.lang.Exception\u0026#34;).$new()); console.log(\u0026#34;\\nBacktrace:\\n\u0026#34; + bt); return this.getPinAlgorithms(); } And nothing was printed. My next idea was that the first if was evaluated to true, and that was the reason it didn\u0026rsquo;t get to the rest of the method. To check which conditions were the ones that made the method exit, I added the following lines to the script:\nNetworkSecurityTrustManager.checkPins.implementation = function (pins) { var bt = Java.use(\u0026#34;android.util.Log\u0026#34;).getStackTraceString(Java.use(\u0026#34;java.lang.Exception\u0026#34;).$new()); console.log(\u0026#34;\\nBacktrace:\\n\u0026#34; + bt); pinSet = this.mNetworkSecurityConfig.value.getPins(); console.log(\u0026#34;pinSet.pins.value.isEmpty: \u0026#34; +pinSet.pins.value.isEmpty()); console.log(\u0026#34;isPinningEnforced: \u0026#34; +this.isPinningEnforced(pins)); console.log(\u0026#34;pins.isEmpty: \u0026#34; +pins.isEmpty()); console.log(System.currentTimeMillis()) console.log(pinSet.expirationTime.value); console.log(System.currentTimeMillis() \u0026gt; pinSet.expirationTime.value); this.checkPins(pins); } So after running the application I got the following output:\npinSet.pins.value.isEmpty: false isPinningEnforced: false \u0026lt;-- this condition is the problematic one pins.isEmpty: false 1562031248274 9223372036854775807 false As it can be seen, the isPinningEnforced was evaluated to false and then as it was negated, it transformed all the expression to true.\nThe method has the following implementation:\nprivate boolean isPinningEnforced(List\u0026lt;X509Certificate\u0026gt; chain) throws CertificateException { if (chain.isEmpty()) { return false; } X509Certificate anchorCert = chain.get(chain.size() - 1); TrustAnchor chainAnchor = mNetworkSecurityConfig.findTrustAnchorBySubjectAndPublicKey(anchorCert); if (chainAnchor == null) { throw new CertificateException(\u0026#34;Trusted chain does not end in a TrustAnchor\u0026#34;); } return !chainAnchor.overridesPins; } I knew the chain wasn\u0026rsquo;t empty, as I already executed the evaluation of the List, so the problem should ne in the findTrustAnchorBySubjectAndPublicKey, which returned a chainAnchor with the attribute overridesPins in true.\nThe findTrustAnchorBySubjectAndPublicKey method is implemented in the NetworkSecurityConfig class:\npublic TrustAnchor findTrustAnchorBySubjectAndPublicKey(X509Certificate cert) { for (CertificatesEntryRef ref : mCertificatesEntryRefs) { TrustAnchor anchor = ref.findBySubjectAndPublicKey(cert); if (anchor != null) { return anchor; } } return null; } It iterates over all the CertificatesEntryRef created during the seting up, and returns the first one that matches the SubjectAndPublicKey. In this scenario it will always return the ones from the proxy. After reading the source code I went to the CertificatesEntryRef class to check where the classes were instantiated, and found that the only constructor was the following one:\npublic CertificatesEntryRef(CertificateSource source, boolean overridesPins) { mSource = source; mOverridesPins = overridesPins; } If you read the frida script again, you will see that the CertificatesEntryRef were created in the following way:\nNetworkSecurityConfig_Builder.getEffectiveCertificatesEntryRefs.implementation = function(){ origin = this.getEffectiveCertificatesEntryRefs() source = UserCertificateSource.getInstance() userCert = CertificatesEntryRef.$new(source,true) \u0026lt;-- sets overridesPins in true origin.add(userCert) return origin } And that is the reason why this script works for all the scenarios.\nnetwork-security-config-bypass-2.js Original Reference: Link\nIn this case, the only case that worked was the one where the network security config file was not present. I analyzed why this patch didn\u0026rsquo;t work. The issue is in the XmlConfigSource in the method \u0026ldquo;parseNetworkSecurityConfig\u0026rdquo;:\nXmlUtils.beginDocument(parser, \u0026#34;network-security-config\u0026#34;); int outerDepth = parser.getDepth(); while (XmlUtils.nextElementWithin(parser, outerDepth)) { //here it creates a NetworkSecurityconfig.Builder based on the xml structure.  ... } ... NetworkSecurityConfig.Builder platformDefaultBuilder = NetworkSecurityConfig.getDefaultBuilder(mTargetSdkVersion); \u0026lt;-- this is the method changed with the script addDebugAnchorsIfNeeded(debugConfigBuilder, platformDefaultBuilder); //baseConfigBuilder is null only if the xml network-security-config is not defined in the AndroidManifest.xml  if (baseConfigBuilder != null) { baseConfigBuilder.setParent(platformDefaultBuilder); addDebugAnchorsIfNeeded(debugConfigBuilder, baseConfigBuilder); } else { baseConfigBuilder = platformDefaultBuilder; } ... mDefaultConfig = baseConfigBuilder.build(); mDomainMap = configs; } The build method generates the NetworkSecurityConfig entity:\npublic NetworkSecurityConfig build() { boolean cleartextPermitted = getEffectiveCleartextTrafficPermitted(); boolean hstsEnforced = getEffectiveHstsEnforced(); PinSet pinSet = getEffectivePinSet(); List\u0026lt;CertificatesEntryRef\u0026gt; entryRefs = getEffectiveCertificatesEntryRefs(); return new NetworkSecurityConfig(cleartextPermitted, hstsEnforced, pinSet, entryRefs); } The valid certificate sources are defined in the entryRefs variable, which is constructed as:\nprivate List\u0026lt;CertificatesEntryRef\u0026gt; getEffectiveCertificatesEntryRefs() { if (mCertificatesEntryRefs != null) { return mCertificatesEntryRefs; } if (mParentBuilder != null) { return mParentBuilder.getEffectiveCertificatesEntryRefs(); } return Collections.\u0026lt;CertificatesEntryRef\u0026gt;emptyList(); } In this case mCertificatesEntryRefs is not null, as it returns the standard SystemCertificateSource (looks for all the certs in the system ca folder). So the mParentBuilder (the one modified in the script) is never called.\nLater on, when the server certificate is validated, the application calls the method NetworkSecurityConfig.findTrustAnchorBySubjectAndPublicKey, which filters the valid certificates from the system folder:\npublic TrustAnchor findTrustAnchorBySubjectAndPublicKey(X509Certificate cert) { for (CertificatesEntryRef ref : mCertificatesEntryRefs) { TrustAnchor anchor = ref.findBySubjectAndPublicKey(cert); if (anchor != null) { return anchor; } } return null; } leading to the exception thrown in the stacktrace, because there aren\u0026rsquo;t coincidences as the certificate return by the server is self-signed:\ncom.android.org.conscrypt.TrustManagerImpl.checkTrusted(TrustManagerImpl.java:375) at com.android.org.conscrypt.TrustManagerImpl.getTrustedChainForServer(TrustManagerImpl.java:304) at android.security.net.config.NetworkSecurityTrustManager.checkServerTrusted(NetworkSecurityTrustManager.java:94) at android.security.net.config.RootTrustManager.checkServerTrusted(RootTrustManager.java:88) ... network-security-config-bypass-3.js Original Reference: Link\nThis works in two of the three scenarios, because the patch is executed in the method that validates certificates. But it does not work in the third scenario because the pin validation is executed in other method, as shown in the error stacktrace:\nat android.security.net.config.NetworkSecurityTrustManager.checkPins(NetworkSecurityTrustManager.java:148) at android.security.net.config.NetworkSecurityTrustManager.checkServerTrusted(NetworkSecurityTrustManager.java:95) at android.security.net.config.RootTrustManager.checkServerTrusted(RootTrustManager.java:88) at com.android.org.conscrypt.Platform.checkServerTrusted(Platform.java:203) at com.android.org.conscrypt.OpenSSLSocketImpl.verifyCertificateChain(OpenSSLSocketImpl.java:592) at com.android.org.conscrypt.NativeCrypto.SSL_do_handshake(Native Method) at com.android.org.conscrypt.OpenSSLSocketImpl.startHandshake(OpenSSLSocketImpl.java:351) ... 25 more network-security-config-bypass-cr.js In this case the method patched is getConfigSource, which is called when the network-security-config is parsed. As it can be seen, the reimplementation proposed creates a DefaultConfigSource, setting as a parameter the android version 23. So regardless of the file uploaded in the application, it will always retrieve the configuration of Android 23 (adds user certificates, does not validate certificate pinning, and allows http communication at http level).\nConclusion: I could achieve my goal, that was finding a script to bypass the network security configuration implemented by the Android SDK. Creating a new alternative to the one I found was a bonus track. During the process I learnt many aspects of the SDK, frida and the Android ecosystem. It is not easy to find bypasses. The hardest part during my analysis was the definition and setting up of all the environment to execution different test scenarios. Adding a new script, a new way to execute requests or another SDK would lead to at least 18 new cases. I guess this is the main reason many of the scripts I found worked for some cases (but not for all of them).\n","permalink":"https://cmrodriguez.me/blog/nsc-bypass/","tags":["Frida","Android"],"title":"Analysis of Network Security Configuration bypasses with Frida"},{"categories":["Frida","Android"],"contents":"In this post I will explain how to try exception handling in Java with Frida. While working on Frida scripts it is usually common to get an error that will crash the script or even the application. So to reliably create applications powered by Frida it is advisable to protect the code from unexpected errors by using exceptions, as shown in the following example:\ntry { var instanceInnerClass = InnerClass.$new(); } catch (e) { var instanceOuterClass = OuterClass.$new(); var instanceInnerClass = InnerClass.$new(instanceOuterClass); } finally { //always gets to this part. } So if any error happens when you call the InnerClass.$new(), the script won\u0026rsquo;t crash, and the execution will follow.\nJava exception handling from Frida When an exception is thrown, Frida generates a javascript exception as well The variable thrown is a JSON with a $handle structure, so we have to cast it to an appropriate class. Depending on the situation we might or might not know which exception can be thrown based on the source code. So in order to handle all the possible exceptions thrown by Java, we need to cast it to a \u0026ldquo;java.lang.Throwable\u0026rdquo; class, and then cast it to the specific class (only if you want to do something specific related to the exception class):\nvar testExceptions = function () { var ThrowingExceptionClass = Java.use(\u0026#34;com.blog.testfrida.exceptions.ThrowingExceptionClass\u0026#34;); try { ThrowingExceptionClass.callException(); } catch (ex) { //ex is a handle, you have to cast it.  var Exception = Java.use(\u0026#34;java.lang.Trowable\u0026#34;); var item = Java.cast(ex,Exception); var SpecificException = Java.use(item.$className); item = Java.cast(ex,SpecificException); console.log(item.attribute.value); } } ","permalink":"https://cmrodriguez.me/blog/exception-handling/","tags":["Frida","Android","Scripting guide"],"title":"Frida Scripting Guide (10) - Exception Handling"},{"categories":["Frida","Android"],"contents":"In this blogpost I will explain how to access different methods with different visibilities in a class through Frida. Whenever we work with Java we have four scopes available applicable to a class, method or attribute. The following table shows what each scope means.\n   Class Package Subclass (same pkg) Subclass (diff pkg) World      public + + + + +   protected + + + +    no modifier + + +     private +          : accessible blank : not accessible   As an example a private method can only be invoked by the class or instance that owns the method (if it is not static, just by an instance). The static methods and objects can be used from a Frida script independently of the scope modifier, as shown in the following example:\nvar ScopeObject = Java.use(\u0026#34;com.blog.testfrida.complexobjects.ScopeObject\u0026#34;); console.log(\u0026#34;private static object:\u0026#34; + ScopeObject.privateStaticObject.value); console.log(\u0026#34;protected static object:\u0026#34; + ScopeObject.protectedStaticObject.value); console.log(\u0026#34;public static object:\u0026#34; + ScopeObject.publicStaticObject.value); console.log(\u0026#34;static object:\u0026#34; + ScopeObject.nonModifiedStaticObject.value); console.log(\u0026#34;private static method:\u0026#34; + ScopeObject.privateStaticMethod()); console.log(\u0026#34;protected static method:\u0026#34; + ScopeObject.protectedStaticMethod()); console.log(\u0026#34;public static method:\u0026#34; + ScopeObject.publicStaticMethod()); console.log(\u0026#34;static method:\u0026#34; + ScopeObject.nonModifiedStaticMethod()); In order to use the attributes and methods of an instance, we need to create an instance by calling its constructor. Frida acts like in the case of the static methods and attributes:\nvar ScopeObject = Java.use(\u0026#34;com.blog.testfrida.complexobjects.ScopeObject\u0026#34;); var scopeInstance = ScopeObject.$new(); console.log(\u0026#34;private object:\u0026#34; + scopeInstance.privateObject.value); console.log(\u0026#34;protected object:\u0026#34; + scopeInstance.protectedObject.value); console.log(\u0026#34;public object:\u0026#34; + scopeInstance.publicObject.value); console.log(\u0026#34;object:\u0026#34; + scopeInstance.nonModifiedObject.value); console.log(\u0026#34;private method:\u0026#34; + scopeInstance.privateMethod()); console.log(\u0026#34;protected method:\u0026#34; + scopeInstance.protectedMethod()); console.log(\u0026#34;public method:\u0026#34; + scopeInstance.publicMethod()); console.log(\u0026#34;method:\u0026#34; + scopeInstance.nonModifiedMethod()); Next: \u0026ldquo;this\u0026rdquo; reference\n","permalink":"https://cmrodriguez.me/blog/classes-content/","tags":["Frida","Android","Scripting guide"],"title":"Frida Scripting Guide (3) - Access to content of classes"},{"categories":["Frida","Android"],"contents":"In this post I\u0026rsquo;ll show how to access the this reference. In Java (and a lot of other languages as well) there is always a special variable called this that references the object which is running the method. In Frida, whenever someone is rewriting a method, he has access to the \u0026ldquo;this\u0026rdquo; parameter. Check the following script as an example:\nBasicTypes.addTwoInts.implementation = function (var1,var2) { console.log(\u0026#34;the method is being called\u0026#34;); return this.addTwoInts(var1,var2); } In this case the \u0026ldquo;this\u0026rdquo; references the class BasicTypes. So by calling the \u0026ldquo;this.addTwoInts\u0026rdquo; we are calling the original implementation of the method, instead of reimplementing it. This feature is useful for many use cases as:\n know if a method is being called (as shown in the example above) print the input values to know what is being received by the function. print the stack trace to know where it is being called.  In all these cases the idea is not to change the workflow of the methods, just trace or debug the functionality.\nNext: Arrays\n","permalink":"https://cmrodriguez.me/blog/this-reference/","tags":["Frida","Android","Scripting guide"],"title":"Frida Scripting Guide (4) - 'this' Reference"},{"categories":["Frida","Android"],"contents":"In this post I\u0026rsquo;ll explain how to use arrays from Java in Frida. Arrays are transformed in Frida from Javascript to Java transparently, so there is no special consideration, as shown in the following examples:\nvar intArray = [1, 2, 3]; console.log(ArrayType.sumArray(intArray)); This example shows a transformation from a javascript Array to a Java array.\nArrayType.sumArray.overload(\u0026#34;[I\u0026#34;).implementation = function (arrayList) { var total = 0; for (var i = 0; i \u0026lt; arrayList.length; i++) { total += arrayList[i]; } console.log(\u0026#34;Entra en arrayInt sumArray: \u0026#34; + total); return total; } This method receives an array in Java. When the Frida user writes the reimplementation function, they will receive a Javascript Array.\n Warning The forEach structure (used in Javascript) to iterate on an array does not work.\n Whenever the following code is called:\nvar total = 0.0; arrayList.forEach(function (element) { total += element; }); the frida server generates an error:\nTypeError: undefined not callable (property \u0026#39;forEach\u0026#39; of [object Object]) at [anon] (../../../frida-gum/bindings/gumjs/duktape.c:65012) at /examples.js:278 at input:1 Working with array of Objects is like working with native types, with the exception that a position in the Array can be null, so it must be taken in consideration when the script is being developed, as in the following example:\nvar peopleArray = ArrayType.getAllPeople(); for (var i = 0; i \u0026lt; peopleArray.length; i++) { if (peopleArray[i] == null) { console.log(i + \u0026#34; - null\u0026#34;); } else { console.log(peopleArray[i].getId()+\u0026#34; - \u0026#34;+peopleArray[i].getName() + \u0026#34; - \u0026#34; + peopleArray[i].getAge()); } }  Note A null value in the Java array is translated to a null javascript value automatically by the framework.\n Next: Enums\n","permalink":"https://cmrodriguez.me/blog/arrays/","tags":["Frida","Android","Scripting guide"],"title":"Frida Scripting Guide (5) - Arrays"},{"categories":["Frida","Android"],"contents":"It is a bit complicated to work on Enums. There is a difference between Enums and common classes. The latter has multiple values but no status. So it is usually used to hold finite and semantically strong status, like in the following case months of a year (in Java code):\nenum Month { JAN, FEB, MAR, APR, MAY, JUN, JUL, AUG, SEP, OCT, NOV, DEC } To set a value you have to define the value to set:\nMonth month = Month.APR; In Frida we have the following possibilties:\n Generate a Frida reference to the enum  Month = Java.use(\u0026#34;com.blog.testfrida.complexobjects.DateAbstraction$Month\u0026#34;); Get all the possible values (it returns an array, so it can be iterated as shown in the array part of this guide):  Month.values(); Print the value of a particular state. Note that we need a .value to get to the real value and not the wrapper of the status:  //Month has not redefined the toString so it calls the Object one console.log(Month.APR.value);  The toString method does not work in this case, as it will print the generic \u0026quot;[object Object]\u0026quot; string.\n  Instantiate a Month value based on a String, and send it as a parameter (there are two ways to send it as a parameter to the Java method):\n  console.log(DateAbstraction.getMonthName(Month.valueOf(String.$new(\u0026#34;APR\u0026#34;)))); console.log(DateAbstraction.getMonthName(Month.APR.value)); While writing this guide I had issues finding a way to get the value from a method (when it returns an Enum) and get the value when You want to override a method. The following example does not work as expected. We have the following code in Java:\npublic static Month getMay() { return Month.MAY; } When we get the result from Frida:\nMay = DateAbstraction.getMay(); the object returned seems to be the Month enum itself and not the particular value (so as an example the .value does not work with the May object). I\u0026rsquo;ll post a bug in the Frida repo and will update the result.\nNext: Inheritance\n","permalink":"https://cmrodriguez.me/blog/enums/","tags":["Frida","Android","Scripting guide"],"title":"Frida Scripting Guide (6) - Enums"},{"categories":["Frida","Android"],"contents":"In this post I will show how to use inheritance in Java from Frida. Java as a OOP language has the inheritance feature. When one class inherits from another class in Java, the two classes take on certain roles. The class that extends (inherits from another class) is the subclass and the class that is being extended (the class being inherited from) is the superclass. In other words, the subclass extends the superclass. Or, the subclass inherits from the superclass. The subclass inherits the attributes and methods from their parents, so a subclass behaves like a superclass.\npublic static double getPerimeter(Figure figure) { return figure.perimeter(); } As it can be seen it receives a \u0026ldquo;Figure\u0026rdquo; class type. As the Circle and Square classes are figures (because of inheritance), you can send any instance of these two classes to the getPerimeter method. Let\u0026rsquo;s do this with Frida:\nvar TestInheritance = Java.use(\u0026#34;com.blog.testfrida.inheritance.TestInheritance\u0026#34;); var Square = Java.use(\u0026#34;com.blog.testfrida.inheritance.Square\u0026#34;); var squareInstance = Square.$new(5); console.log(\u0026#34;square perimeter: \u0026#34; + TestInheritance.getPerimeter(squareInstance)); In Frida you can work with inherited classes as you would do directly in Java, as the methods automatically casts the object to the right type.\npublic static double getPerimeter(Figure figure) { return figure.perimeter(); } When we retrieve the value from Frida and check the class:\nvar figureInstance = TestInheritance.getCircle(); console.log(figureInstance.$className); we get that the className is \u0026lsquo;com.blog.testfrida.inheritance.Circle'. But when we try to use a method that is in the Circle only (getCircleName) we get that the method is undefined. This means the object is casted to a Figure:\nvar figureInstance = TestInheritance.getCircle(); if (figureInstance.getCircleName === undefined) { console.log(\u0026#34;Instance is figure, the getCircleName does not exist.\u0026#34;); } else { console.log(figureInstance.getCircleName()); } To access the circle method, we should cast it:\ncircleInstance = Java.cast(figureInstance,Circle); console.log(circleInstance.getCircleName()); Sometimes in Java we want to reuse some code of a parent class, but we want to add some component that exists or makes sense only in the subclass. As an example a constructor that sets all the private attributes to a default value. As an example, in the Android application I created two classes. One is SuperClass, and the other SubClass. In the SuperClass we have the \u0026ldquo;superValue\u0026rdquo;. In the constructor we set its value to 10:\npublic SuperClass() { superValue = 10; } The SubClass has two attributes that are being set in the constructor.\npublic SubClass() { super(); subValue = 10; setValue = 10; } To avoid copy the SuperClass content to the SubClass constructor (in some cases it isn\u0026rsquo;t even possible), Java has a \u0026ldquo;super\u0026rdquo; attribute that points to the SuperClass object. We can use it to call the SuperClass method, so then when we use the SubClass method to get the superValue, we\u0026rsquo;ll see that it was set to 10.\n//In this case I rewrote a new function that has a super implementation SubClass.$init.implementation = function () { var superInheritance = Java.cast(this,SuperClass); superInheritance.$init(); this.subValue.value = 25; } There a couple of things to tell about this example. When you want to change or intercept a constructor, you need to modify the $init function in Frida. To call the super class, you need to cast the \u0026ldquo;this\u0026rdquo; variable (reference to itself).\nNext: Interfaces\n","permalink":"https://cmrodriguez.me/blog/inheritance/","tags":["Frida","Android","Scripting guide"],"title":"Frida Scripting Guide (8) - Inheritance"},{"categories":["Frida","Android"],"contents":"An interface is a reference type in Java. It is similar to class. It is a collection of abstract methods. A class implements an interface, thereby inheriting the abstract methods of the interface.\nAlong with abstract methods, an interface may also contain constants, default methods, static methods, and nested types. Method bodies exist only for default methods and static methods.\nAn interface is different from a class in several ways:\n You cannot instantiate an interface. An interface does not contain any constructors. All of the methods in an interface are abstract. An interface cannot contain instance fields. The only fields that can appear in an interface must be declared both static and final. An interface is not extended by a class; it is implemented by a class.  To test this functionality I\u0026rsquo;ve created in the application an interface called MyInterface, and a class that implements the interface called MyInterfaceClass.\nIn order to get the interface representation in Frida we use the same code as we would use for a class:\nMyInterface = Java.use(\u0026#34;com.blog.testfrida.interfaces.MyInterface\u0026#34;); We can\u0026rsquo;t intercept or modify the abstract methods exposed by the interface. As an example I tried to implement the getMessage method from the interface in the following way:\nMyInterface.getMessage.implementation = function () { console.log(\u0026#34;it gets into the getMessage\u0026#34;); return String.$new(\u0026#34;it works\u0026#34;); } When we call the getMessage from the implementation of the getMessage method in the MyInterfaceClass, the console.log is not triggered. If we want to change the implementation, we have to do it in each class the abstract method is implemented. In this case we did it on the only class implementing MyInterface:\nvar MyInterfaceClass = Java.use(\u0026#34;com.blog.testfrida.interfaces.MyInterfaceClass\u0026#34;); MyInterfaceClass.getMessage.implementation = function () { console.log(\u0026#34;it gets into the getMessage\u0026#34;); return String.$new(\u0026#34;it works\u0026#34;); } Note that we can\u0026rsquo;t instantiate an interface, it will throw the following error:\nError: no supported overloads at makeConstructor (frida/node_modules/frida-java-bridge/lib/class-factory.js:478) ... at /examples.js:434 When we get an instance of a class that implements an interface, we can call the interfaces\u0026rsquo; methods, but Frida will end up calling the classes implementations as in the following examples:\n//we get an instance of Interface and call the getMessage var interfaceInstance = MyInterfaceClass.getNewInstance(); //internally it calls the getMessage from the MyInterfaceClass console.log(interfaceInstance.getMessage()); //this does not call the default interface, it calls the class one (even when it is //casted as a MyInterface interface) console.log(interfaceInstance.getInt()); Next: Inner classes\n","permalink":"https://cmrodriguez.me/blog/interfaces/","tags":["Frida","Android","Scripting guide"],"title":"Frida Scripting Guide (8) - Interfaces"},{"categories":["Frida","Android"],"contents":"In this blogpost I will show how to consume inner classes in Java from Frida. In Java nested classes are classes that are defined inside another class. The purpose of a nested class is to clearly group the nested class with its surrounding class, signaling that these two classes are to be used together. Or perhaps that the nested class is only to be used from inside its enclosing (owning) class.\nAs an example the following are nested classes:\npublic class OuterClass { ... class InnerClass { public char getInnerChar() { return \u0026#39;i\u0026#39;; } } } In order to get with Frida to the InnerClass we have to use the following code:\nvar InnerClass = Java.use(\u0026#34;com.blog.testfrida.innerclasses.OuterClass$InnerClass\u0026#34;); var OuterClass = Java.use(\u0026#34;com.blog.testfrida.innerclasses.OuterClass\u0026#34;); If the inner class is instantiated as a static public class, it can be used in a code as a common class (besides the OuterClass, that always has access to the InnerClass). But if the class is configured as shown in the example the following code will generate an error:\nvar instanceInnerClass = InnerClass.$new(); It will fail because the InnerClass will have by default a constructor that receives an instance from the OuterClass (as the declaration of the class is not static). So to create an instance we need to execute the following code in Frida:\nvar instanceOuterClass = OuterClass.$new(); var instanceInnerClass = InnerClass.$new(instanceOuterClass); So the reference to the OuterClass is stored in an internal attribute. In order to ge acces to it from a reimplementation of a method we can use the this$0 reference as in the following example:\nInnerClass.getInnerChar.implementation = function () { //reference to outer class, and call a method  console.log(this.this$0.value.getIdOuterClass()); //reference to outer class, and call an attribute  console.log(this.this$0.value.val.value); return \u0026#39;j\u0026#39;; } There is another type of innerclass called Anonymous Inner Class. It is an inner class without a name and for which only a single object is created. An anonymous inner class can be useful when making an instance of an object with certain ‚Äúextras‚Äù such as overloading methods of a class or interface, without having to actually subclass a class. The following is an example of an anonymous inner class:\npublic class AnonymousInnerClass { public String getMessageAnonymous() { InnerInterface inner = new InnerInterface() { @Override public String getMessage() { return \u0026#34;getMessage\u0026#34;; } }; return inner.getMessage(); } } Even when the anonmyous class seems not to have a name, Java internally at compile type generates a common nested class with a numeric name (starting in 1). In order to abstract ourselves from the name Java assigns to the class we can use the following code in Frida:\nJava.enumerateLoadedClasses( { \u0026#34;onMatch\u0026#34;: function(className){ if(className.includes(\u0026#34;com.blog.testfrida.innerclasses.AnonymousInnerClass$\u0026#34;)){ console.log(className); } }, \u0026#34;onComplete\u0026#34;:function(){} } ); This code snippet lists all the classes loaded in the VM by name. As we know that the anonymous class is created as an inner class, we know that the full classpath will be $. So we filter all the classes that starts with that name. As a caveat, the first time I listed all the inner classes from AnonymousInnerClass, I could find none. After some minutes of analyzing the reason I realized that it has not been loaded by a ClassLoader yet, as it was never used in the application. So I forced the VM to load it basically instantiating it:\nvar AnonymousInnerClass = Java.use(\u0026#34;com.blog.testfrida.innerclasses.AnonymousInnerClass\u0026#34;); var instanceAnonymous = AnonymousInnerClass.$new(); And after that I could achieve the dynamic instrumentation of the anonymous inner class:\nJava.enumerateLoadedClasses( { \u0026#34;onMatch\u0026#34;: function(className){ if(className.includes(\u0026#34;com.blog.testfrida.innerclasses.AnonymousInnerClass\u0026#34;)){ if (className.includes(\u0026#34;$\u0026#34;)) { var anonymousClass = Java.use(className); anonymousClass.getMessage.implementation = function () { return \u0026#34;it works well :)\u0026#34;; } } } }, \u0026#34;onComplete\u0026#34;:function(){} } ); Next: Exception handling\n","permalink":"https://cmrodriguez.me/blog/inner-classes/","tags":["Frida","Android","Scripting guide"],"title":"Frida Scripting Guide (9) - Inner Classes"}]