[{"categories":["Frida","Android","CTF","Challenge","HTTPS","TCP","UDP"],"contents":"In this series of posts I\u0026rsquo;ll be solving the hpandro ctf challenges. hpAndro created an Android application with multiple vulnerabilities, following the MSTG.\nThis application has a lot of simple challenges, so it is good for beginners or to test some techniques. I\u0026rsquo;ll try to solve all the challenges using Frida. As a secondary objective I\u0026rsquo;ll try to use scripts that can work in multiple scenarios and not just to get the flag.\nIn this post we continue solving issues of hpAndro with Frida. We have three different challenges to solve:\n Intercept HTTPS traffic. Intercept TCP traffic. Intercept UDP traffic.  Intercept HTTPS traffic Whenever we have an application with https traffic (luckily nowadays most of them have https instead of http), we have to do some extra steps in order to intercept the traffic, as in most scenarios the application won\u0026rsquo;t recognize the Web Proxy root certificate as a trusted one.\n  The first option is installing the certificate in the cellphone as a user certificate. This will work only in an Android OSs with API level 23 or lower. So if the application is compatible with older versions of Android and you have an old cellphone or VM, you could try to test it in that environment.\n  With API 24 and above, Android added the Network Security Configuration feature which lets the developer customize the network security settings of the application in a safe, declarative configuration file without modifying app code. (see https://developer.android.com/training/articles/security-config). By default applications do not trust user certificates. Generally speaking in a release version of an app it is weird to see the user certificates configuration. So there are 3 alternatives.\n  a- Install the web proxy certificate as a system cert. This can only be done for rooted devices as the user needs to have those rights to set the system partition as read/write. I will not cover those steps here, because this is already documented in many places.\nOne of the advantages of this approach is that you do it once, and unless you change the device or the proxy, it will work for all the applications you install on it. Other advantage is that you do not need to change the application.\nb- Modify the application in order to set the network security configuration to accept user certificates. This alternative requires to decompile and recompile the application, so it might be cumbersome in modern application because some tools that unpacks and repacks the applications throw errors in them. I tend to avoid this approach unless it is strictly neccesary.\nc- Using Frida. I\u0026rsquo;ve already covered different strategies and scripts in previous posts: Network security bypass 2 and Network security bypass.\nOne of the first things I do when I start the analysis of an application is checking the AndroidManifest to get an idea of the permissions the application requests, the exposed components and the network security configuration. In this case I\u0026rsquo;ll check just the third as it is needed to solve the challenge:\nAndroidManifest.xml:\n\u0026lt;application android:theme=\u0026#34;@style/AppTheme\u0026#34; android:label=\u0026#34;@string/app_name\u0026#34; android:icon=\u0026#34;@mipmap/ic_launcher\u0026#34; android:name=\u0026#34;com.hpandro.androidsecurity.MainApp\u0026#34; ... *android:networkSecurityConfig=\u0026#34;@xml/network_security_config\u0026#34;* ...\u0026gt; As the application tag has the attribute android:networkSecurityConfig, I need to check the file that is defined as the value of that attribute. In this case it is res/xml/network_security_config.xml:\n\u0026lt;?xml version=\u0026#34;1.0\u0026#34; encoding=\u0026#34;utf-8\u0026#34;?\u0026gt; \u0026lt;network-security-config\u0026gt; \u0026lt;domain-config cleartextTrafficPermitted=\u0026#34;true\u0026#34;\u0026gt; \u0026lt;domain includeSubdomains=\u0026#34;true\u0026#34;\u0026gt;hpandro.raviramesh.info \u0026lt;/domain\u0026gt; \u0026lt;domain includeSubdomains=\u0026#34;true\u0026#34;\u0026gt;raviramesh.info \u0026lt;/domain\u0026gt; \u0026lt;domain includeSubdomains=\u0026#34;true\u0026#34;\u0026gt;hpandro.me \u0026lt;/domain\u0026gt; \u0026lt;trust-anchors\u0026gt; \u0026lt;certificates src=\u0026#34;system\u0026#34;/\u0026gt; \u0026lt;certificates src=\u0026#34;user\u0026#34;/\u0026gt; \u0026lt;/trust-anchors\u0026gt; \u0026lt;/domain-config\u0026gt; \u0026lt;/network-security-config\u0026gt; So in this case for the following domains, the application accepts user certificates:\n hpandro.raviramesh.info raviramesh.info hpandro.me  I still need to check what does the application in the challenge. If the request is to one of the previous domains, the proxy configuration will work without doing anything else.\nThe activity called in the task can be seen in the AndroidManifest.xml as well:\n\u0026lt;activity android:name=\u0026#34;com.hpandro.androidsecurity.ui.activity.task.trafficanalysis.HTTPsTrafficActivity\u0026#34;/\u0026gt; Whenever I navigate to the class defined in the manifest and read the code in the onCreate function I see the following URL:\nif (z) { WebView webView4 = (WebView) y(R.id.webviewTask); g.c(webView4); webView4.loadUrl(\u0026#34;https://hpandro.raviramesh.info/https_task.php\u0026#34;); } So in this case the challenge could be solved easily, but as our objective is to solve the challenge with Frida, we\u0026rsquo;ll have to create an script and retrieve the flag with it.\nBy reading the content of the challenge I realized that the code is exactly the same as in the HTTPTrafficActivity, so the only change needed is to change the URL on the script. The final script is the following one:\nfunction readNewStream(inputStream) { var BufferedReader = Java.use(\u0026#39;java.io.BufferedReader\u0026#39;); var InputStreamReader = Java.use(\u0026#39;java.io.InputStreamReader\u0026#39;); var inputStreamReader = InputStreamReader.$new(inputStream); var r = BufferedReader.$new(inputStreamReader); var StringBuilder = Java.use(\u0026#39;java.lang.StringBuilder\u0026#39;); var total = StringBuilder.$new(); var String = Java.use(\u0026#39;java.lang.String\u0026#39;); while (true) { var line = r.readLine(); if (line == null) { break; } else { total.append(line).append(String.$new(\u0026#39;\\n\u0026#39;)); } } console.log(total.toString()); } Java.perform( function () { var WebViewClient = Java.use(\u0026#39;v0.d.a.c.a.d.h.b\u0026#39;); WebViewClient.shouldInterceptRequest.overload(\u0026#39;android.webkit.WebView\u0026#39;, \u0026#39;android.webkit.WebResourceRequest\u0026#39;).implementation = function (webView, request) { var WebResourceResponse = Java.use(\u0026#39;android.webkit.WebResourceResponse\u0026#39;); var isFavicon = request.getUrl().toString().search(\u0026#34;favicon.ico\u0026#34;) \u0026gt; 0; var URL = Java.use(\u0026#39;java.net.URL\u0026#39;); var url = URL.$new(request.getUrl().toString()); var HttpURLConnection = Java.use(\u0026#39;java.net.HttpURLConnection\u0026#39;); var urlConnection = Java.cast(url.openConnection(),HttpURLConnection); var String = Java.use(\u0026#39;java.lang.String\u0026#39;); urlConnection.setRequestProperty(String.$new(\u0026#34;User-Agent\u0026#34;), String.$new(\u0026#34;hpAndro\u0026#34;)); var BufferedInputStream = Java.use(\u0026#39;java.io.BufferedInputStream\u0026#39;); var inputStr = BufferedInputStream.$new(urlConnection.getInputStream()); var webResourceRes = null; if (!isFavicon) { readNewStream(inputStr); var map = urlConnection.getHeaderFields(); var iter = map.entrySet().iterator(); var Entry = Java.use(\u0026#39;java.util.Map$Entry\u0026#39;); while(iter.hasNext()) { var entry = Java.cast(iter.next(),Entry); console.log(\u0026#34;Key : \u0026#34; + entry.getKey() + \u0026#34; ,Value : \u0026#34; + entry.getValue()); } webResourceRes = WebResourceResponse.$new(\u0026#34;text/html\u0026#34;,\u0026#34;utf-8\u0026#34;, inputStr); } else { webResourceRes = WebResourceResponse.$new(\u0026#34;image/vnd.microsoft.icon\u0026#34;,\u0026#34;gzip\u0026#34;, inputStr); } return webResourceRes; } }); Intercept TCP traffic. As we have non HTTP Traffic, web proxies do not work here. In this case a lower level of sniffer is needed (like wireshark or tcpdump). As the objective is to solve this challenge with Frida, we need to find out how the TCP packets are being sent. We start by searching in the AndroidManifest the activity that generates the communication:\n\u0026lt;activity android:name=\u0026#34;com.hpandro.androidsecurity.ui.activity.task.nonhttptraffic.TCPTrafficActivity\u0026#34;/\u0026gt; We then check the TCPTrafficActivity, and analyze the code of the onCreate method. Note that by using the application we see that the packet seems to be sent whenever the user clicks the button CONNECT:\nSo we want to check what the onClickListener does in that case. We can find it in the following code in the onCreate method:\nonCreate() ((Button) y(R.id.btnConnectTCP)).setOnClickListener(new d(this)); We then check d, a class that implement OnClickListener:\npublic static final class d implements View.OnClickListener { public final /* synthetic */ TCPTrafficActivity e; public d(TCPTrafficActivity tCPTrafficActivity) { this.e = tCPTrafficActivity; } public final void onClick(View view) { ... } } Whenever the user clicks the button, the onClick method from the OnCLickListener is being called, so we have to analyze that method.\npublic final void onClick(View view) { this.e.t = new Thread(new b()); Thread thread = this.e.t; g.c(thread); thread.start(); } which basically instantiates b (an implementation of Runnable) and executes it. We\u0026rsquo;ll do a review of the method run:\npublic void run() { try { ... // socket created with the folling domain and port  // public final String w = \u0026#34;hpandro.raviramesh.info\u0026#34;;  // public final int x = 65000;  tCPTrafficActivity.s = new Socket(tCPTrafficActivity2.w, tCPTrafficActivity2.x); //sets a buffer reader with the InputSttram from a socket in attribute b of the TCPTrafficActivity instance  tCPTrafficActivity4.v = new BufferedReader(new InputStreamReader(socket2.getInputStream())); //run a new thread with a Runnable class (a)  new Thread(new a()).start(); } catch (IOException e2) { try { e2.printStackTrace(); } catch (IOException e3) { e3.printStackTrace(); } } } We check the implementation of the class a that is in the same file as TCPTrafficActivity:\npublic void run() { BufferedReader bufferedReader; while (true) { try { //v is the bufferreader that takes the InputStream from the socket  bufferedReader = TCPTrafficActivity.this.v; g.c(bufferedReader); break; } catch (IOException e2) { e2.printStackTrace(); } } //in this line the bufferReader retrieves the content of the socket, and does nothing with it  if (bufferedReader.readLine() != null) { So in this case in order to solve the issue we could override the method readLine from BufferReader in order to show the content of the flag. The following script was created to solve it:\nJava.perform( function () { var BufferedReader = Java.use(\u0026#34;java.io.BufferedReader\u0026#34;); BufferedReader.readLine.overload().implementation = function () { var line = this.readLine(); console.log(line); return line; } }); Intercept UDP traffic. The process to solve this challenge is like the last one, so I\u0026rsquo;ll focus on the analysis of the source code. The following image is taken from the UDP taks:\nWe check the onCreate method to find the implementation of the OnCLickListener:\n((Button) y(R.id.btnConnectUDP)).setOnClickListener(new a(1, this)); In the \u0026ldquo;a\u0026rdquo; class we have the following code:\npublic final void onClick(View view) { int i = this.e; if (i == 0) { ((UDPTrafficActivity) this.f).finish(); } else if (i == 1) { ... //this is the handler that receives the answer in UDPTrafficActivity  ((UDPTrafficActivity) this.f).s = new b((UDPTrafficActivity) this.f); b bVar = ((UDPTrafficActivity) this.f).s; g.c(bVar); //this class starts the communication and retrieves the messages  //The application is connected to hpandro.raviramesh.info:65001  ((UDPTrafficActivity) this.f).t = new v0.d.a.c.a.d.g.b(\u0026#34;hpandro.raviramesh.info\u0026#34;, 65001, bVar); v0.d.a.c.a.d.g.b bVar2 = ((UDPTrafficActivity) this.f).t; g.c(bVar2); bVar2.start(); } else { throw null; } } We have to navigate to v0.d.a.c.a.d.g.b and see the implementation of the run method:\n... DatagramSocket datagramSocket3 = this.f; g.c(datagramSocket3); datagramSocket3.receive(datagramPacket2); //data retrieved from the socket byte[] data = datagramPacket2.getData(); g.d(data, \u0026#34;packet.data\u0026#34;); //converts byteArray to String String str = new String(data, 0, datagramPacket2.getLength(), a.a); UDPTrafficActivity.b bVar3 = this.e; //bVar3.sendMessage is invoked and the String is sent as parameter bVar3.sendMessage(Message.obtain(bVar3, 1, str));UDPTrafficActivity.b datagramSocket = this.f; if (datagramSocket == null) { return; } The application is using the (Message)[https://developer.android.com/reference/android/os/Message] framework that provides Android to send messages from the previous class to the AndroidActivity. So we have to check the handleMessage, and what it does with the String. The Message has the following content:\n message.what: int that identifies the kind of message sent . In this case it has the valui 1. message.obj: Object with the message. In this case it is the String retrieved from the socket.  The handleMessage handles the message type 1 in the following way:\nUDPTrafficActivity uDPTrafficActivity2 = this.a; Object obj2 = message.obj; if (obj2 != null) { int i3 = UDPTrafficActivity.v; uDPTrafficActivity2.getClass(); System.out.println((Object) (\u0026#34;+++++++++++++++ updateRxMsg:\u0026#34; + ((String) obj2))); uDPTrafficActivity2.runOnUiThread(new v0.d.a.c.a.d.g.a(uDPTrafficActivity2)); return; As it can be seen the application executes a System.out.println with the String received. If we check the logcat logs from the application we will see that the flag is printed there. So there is no need to create a Frida script to solve the challenge. Nevertheless, we\u0026rsquo;ll do it.\nIn this case the easiest thing is to execute a hook on the method getData of DatagramPacket:\nJava.perform( function () { var DatagramPacket = Java.use(\u0026#34;java.net.DatagramPacket\u0026#34;); var String = Java.use(\u0026#34;java.lang.String\u0026#34;); var a = Java.use(\u0026#34;a1.u.a\u0026#34;); DatagramPacket.getData.implementation = function () { var data = this.getData(); console.log(String.$new(data, 0, this.getLength(),a.a.value)); return data; } }); In the following link https://github.com/CesarMRodriguez/lunesdemobile/tree/main/Sesion%202 you can find the following content:\n https_task.js: Scrip used to solve the task of https interception. tcp_traffic.js: Script to solve the TCP interception task. udp_traffic.js: Script to solve the UDP interception task.  ","permalink":"https://cmrodriguez.me/blog/hpandro-2/","tags":["Frida","Android","CTF","Challenge","HTTPS","TCP","UDP"],"title":"Solving CTF with Frida - Part 2"},{"categories":["Frida","Android","CTF","Challenge","HTTP"],"contents":"In this series of posts I\u0026rsquo;ll be solving the hpandro ctf challenges. hpAndro created an Android application with multiple vulnerabilities, following the MSTG.\nThis application has a lot of simple challenges, so it is good for beginners or to test some techniques. I\u0026rsquo;ll try to solve all the challenges using Frida. As a secondary objective I\u0026rsquo;ll try to use scripts that can work in multiple scenarios and not just to get the flag.\nThe first challenge to solve is the Http interception. This challenge can be solved with the following strategies:\n Intercepting the application requests with any web-proxy. Use a lower stack network proxy like wireshark. In this case it is possible because the content is in cleartext. Using static code analysis tools in order to find what the application does, and executing the same request on a browser. Last but not least, using Frida.  As we already explained, we\u0026rsquo;ll be solving the challenge with Frida. So in order to find what to script with Frida, I\u0026rsquo;ll check the decompiled application.\nSo the first thing to find is which component is executing the request that has to be intercepted. This can be done analyzing the Android Manifest, where we can find the following activity:\n\u0026lt;activity android:name=\u0026#34;com.hpandro.androidsecurity.ui.activity.task.trafficanalysis.HTTPTrafficActivity\u0026#34;/\u0026gt; In this case the activity class is descriptive, so we can read that class directly. We can find in the HTTPTrafficActivity class the following code:\nif (z) { WebView webView4 = (WebView) y(R.id.webviewTask); g.c(webView4); webView4.loadUrl(\u0026#34;http://hpandro.raviramesh.info/http_task.php\u0026#34;); } It can be seen that the URL is being loaded in a WebView. As it is a GET request, I executed it in a browser. But the server did not return any content on the response.\nAfter reading a bit more what was being done in the code I found the following method:\na.D(a.J((WebView) y(R.id.webviewTask), \u0026#34;webviewTask!!.settings\u0026#34;, true, true, false, false, true), WebSettings.LayoutAlgorithm.SINGLE_COLUMN, 2, true, \u0026#34;hpAndro\u0026#34;); a.J does not do anything significative for our analysys, but a.D does the following:\npublic static void D(WebSettings webSettings, WebSettings.LayoutAlgorithm layoutAlgorithm, int i, boolean z, String str) { webSettings.setLayoutAlgorithm(layoutAlgorithm); webSettings.setCacheMode(i); webSettings.setDomStorageEnabled(z); webSettings.setUserAgentString(str); } which sets up \u0026ldquo;hpAndro\u0026rdquo; as the User-Agent. I tested the request changing it:\nGET /http_task.php HTTP/1.1 Host: hpandro.raviramesh.info Pragma: no-cache Cache-Control: no-cache Upgrade-Insecure-Requests: 1 User-Agent: hpAndro Accept: text/html,application/xhtml+xml,application/xml;q=0.9,image/webp,image/apng,*/*;q=0.8,application/signed-exchange;v=b3;q=0.9 X-Requested-With: com.hpandro.androidsecurity Accept-Encoding: gzip, deflate Accept-Language: en-US,en;q=0.9 Connection: close which returns the desired flag in a header. So in order to solve this challenge we need to see the way to intercept traffic in a WebView.\nWhenever I have to create a complex script with Frida I follow 3 steps.\n  Code a Java application that does whatever I want the Frida script to. I do this in order to discard the complexity of the targeted application and focus on the problem to solve. In this case it was how to intercept the request and the response from a WebView.\n  Translate the Java code in a Frida script. In this case the translation is in the mock application.\n  Adapt the code to the particular application. As the Frida script from step 2 applies to the mock application, I need to find where to hook the script in the targeted application in order to make it work.\n  Step 1 It is not that easy to intercept requests from a WebView, as it runs in a different process and executes requests in a browser engine. So I had to find a way to change the behavior of the WebView in order to send the traffic through the Java layer. I found that the Android SDK has a way to configure the way the resources are being loaded by the WebViewClient through the function shouldInterceptRequest. This function is used to notify the host application of a resource request and allow the application to return the data. If the return value is null, the WebView will continue to load the resource as usual. Otherwise, the return response and data will be used.\nSo if we implement this function in the Java layer, the application will be able to intercept the requests sent by the WebView.\nNote: This function works fine for GET parameters, with other verbs with body it does not work.\nSo I created an Activity in an application with a WebView, and implemented the shouldInterceptRequest:\na. Configure the WebViewClient for the WebView:\ntestWebView.setWebViewClient(new WebViewClient() { @RequiresApi(api = Build.VERSION_CODES.LOLLIPOP) @Override public WebResourceResponse shouldInterceptRequest (final WebView view, WebResourceRequest request) { ... WebResourceResponse webResourceResponse = FirstFragment.shouldInterceptRequest(view, request); return webResourceResponse; ... b. Implement the function that takes the content of the original request (WebResourceRequest) and executes the request. It is possible, because the WebResourceRequest instance has the URL and headers of the original petition.\n@RequiresApi(api = Build.VERSION_CODES.LOLLIPOP) private static WebResourceResponse shouldInterceptRequest (final WebView view, WebResourceRequest request) { //show method \tSystem.out.println(\u0026#34;Method: \u0026#34; + request.getMethod()); //show URL and queryString \tSystem.out.println(\u0026#34;Uri: \u0026#34; + request.getUrl().toString()); //show all http headers  Map\u0026lt;String, String\u0026gt; headers = request.getRequestHeaders(); for (Map.Entry\u0026lt;String,String\u0026gt; entry : headers.entrySet()) System.out.println(\u0026#34;Header: \u0026#34; + entry.getKey() + \u0026#34;= \u0026#34; + entry.getValue()); // and here, if you want, you can load the page normally  String htmlContent = \u0026#34;\u0026#34;; URL url = null; try { //execute the request  url = new URL(request.getUrl().toString()); HttpURLConnection urlConnection = (HttpURLConnection) url.openConnection(); urlConnection.setRequestProperty(\u0026#34;User-Agent\u0026#34;, \u0026#34;hpAndro\u0026#34;); try { InputStream in = new BufferedInputStream(urlConnection.getInputStream()); //print content of response  readStream(in); Map\u0026lt;String, List\u0026lt;String\u0026gt;\u0026gt; map = urlConnection.getHeaderFields(); for (Map.Entry\u0026lt;String, List\u0026lt;String\u0026gt;\u0026gt; entry : map.entrySet()) { System.out.println(\u0026#34;Key : \u0026#34; + entry.getKey() + \u0026#34; ,Value : \u0026#34; + entry.getValue()); } //return response to the WebView.  WebResourceResponse webResourceRes; webResourceRes = new WebResourceResponse(\u0026#34;text/html\u0026#34;,\u0026#34;utf-8\u0026#34;, in); return webResourceRes; ... As it can be seen in the previous code, we achieve the initial goal of sending the request to the Java layer in order to manipulate it then with Frida.\nStep 2 We need to translate the previous code to a Frida script. Most of the translation is straightforward if you have done some scripts on your own.\nThe most complex part of the translation is that the solution needs us to create a new class that inherits from WebViewClient, and that implements the shouldInterceptRequest.\nThe following Java code creates an anonymous class, that is being used as a parameter in the setWebViewClient:\ntestWebView.setWebViewClient(new WebViewClient() { In Frida we can\u0026rsquo;t create anonymous classes, so we have to use the Java.registerClass API:\nvar WebViewClient = Java.use(\u0026#39;android.webkit.WebViewClient\u0026#39;); var MyWebViewClient = Java.registerClass({ name: \u0026#39;com.example.MyWebViewClient\u0026#39;, superClass: WebViewClient, methods: { $init() { console.log(\u0026#39;Constructor called\u0026#39;); }, shouldInterceptRequest: [{ returnType: \u0026#39;android.webkit.WebResourceResponse\u0026#39;, argumentTypes: [\u0026#39;android.webkit.WebView\u0026#39;, \u0026#39;android.webkit.WebResourceRequest\u0026#39;], implementation(webView, request) { ... return webResourceRes; } }], } }); The other issue I had creating the scripts is that Frida-client breaks whenever a method returns a null value. In this case I wanted to return null in all non HTML requests (like the favico or any javascript/css request), and avoid creating a WebResourceResponse per each potential kind of resource.\nAs I couldn\u0026rsquo;t find a way to make it work I analyzed the resources being requested by the webview and then create different WebResourceResponses based on them. That is the reason you\u0026rsquo;ll find in a script the following if statement:\nif (!isFavicon) { ... webResourceRes = WebResourceResponse.$new(\u0026#34;text/html\u0026#34;,\u0026#34;utf-8\u0026#34;, inputStr); } else { webResourceRes = WebResourceResponse.$new(\u0026#34;image/vnd.microsoft.icon\u0026#34;,\u0026#34;gzip\u0026#34;, inputStr); } In order to create a custom script to intercept all HTTP traffic, you\u0026rsquo;ll need to consider that you\u0026rsquo;ll need to handle the non HTTP traffic as well, because of the return of null error.\nStep 3 I needed to find a place to inject the script in the original application. The requirements of the script I wrote is that I need the reference to the WebView in order to set the WebViewClient. Based on the decompiled code:\nsuper.onCreate(bundle); setContentView(R.layout.activity_httptraffic); ... boolean z = true; this.i.a(this, new v0.d.a.c.a.d.h.j(this, true)); a.D(a.J((WebView) y(R.id.webviewTask), \u0026#34;webviewTask!!.settings\u0026#34;, true, true, false, false, true), WebSettings.LayoutAlgorithm.SINGLE_COLUMN, 2, true, \u0026#34;hpAndro\u0026#34;); int i = Build.VERSION.SDK_INT; WebView webView = (WebView) y(R.id.webviewTask); ... if (systemService != null) { ... if (z) { WebView webView4 = (WebView) y(R.id.webviewTask); g.c(webView4); webView4.loadUrl(\u0026#34;http://hpandro.raviramesh.info/http_task.php\u0026#34;); } else { RelativeLayout relativeLayout = (RelativeLayout) y( ... } ((Button) y(R.id.btnCheck)).setOnClickListener(new i(this)); return; } throw new NullPointerException(\u0026#34;null cannot be cast to non-null type android.net.ConnectivityManager\u0026#34;); the function that receives a WebView as a parameter is a.J. So I created the hook on that function:\nvar WebViewConfigurator = Java.use(\u0026#34;v0.a.a.a.a\u0026#34;); WebViewConfigurator.J.implementation = function (webView, str, z, z2, z3, z4, z5) { webView.setWebViewClient(MyWebViewClient.$new()); return this.J(webView, str, z, z2, z3, z4, z5); } The final script can be seen in the following URL: https://github.com/CesarMRodriguez/lunesdemobile/blob/main/Sesion%201/http_task.js\nSadly after running the script in the application to see if it worked, I found that the custom class was not being called. After reading and checking the script I found that between a.J and webview.loadUrl, the HttpTrafficActivity class was setting a custom webViewClient, overwriting the custom class I wrote.\na.D(a.J((WebView) y(R.id.webviewTask), \u0026#34;webviewTask!!.settings\u0026#34;, true, true, false, false, true), WebSettings.LayoutAlgorithm.SINGLE_COLUMN, 2, true, \u0026#34;hpAndro\u0026#34;); ... webView3.setWebChromeClient(new h()); g.c(this); Object systemService = getSystemService(\u0026#34;connectivity\u0026#34;); if (systemService != null) { ... if (z) { WebView webView4 = (WebView) y(R.id.webviewTask); g.c(webView4); webView4.loadUrl(\u0026#34;http://hpandro.raviramesh.info/http_task.php\u0026#34;); So I had to create a new script. In this case the solution was much more simpler than what I wrote initially, because I only had to overwrite the shouldInterceptRequest from that class:\nJava.perform( function () { var WebViewClient = Java.use(\u0026#39;v0.d.a.c.a.d.h.g\u0026#39;); WebViewClient.shouldInterceptRequest.overload(\u0026#39;android.webkit.WebView\u0026#39;, \u0026#39;android.webkit.WebResourceRequest\u0026#39;).implementation = function (webView, request) { ... if (!isFavicon) { readNewStream(inputStr); ... webResourceRes = WebResourceResponse.$new(\u0026#34;text/html\u0026#34;,\u0026#34;utf-8\u0026#34;, inputStr); } else { webResourceRes = WebResourceResponse.$new(\u0026#34;image/vnd.microsoft.icon\u0026#34;,\u0026#34;gzip\u0026#34;, inputStr); } return webResourceRes; } }); This second script worked as desired, achieving the goal of solving the challenge with Frida.\nIn the following link https://github.com/CesarMRodriguez/lunesdemobile/tree/main/Sesion%201 you can find the following content:\n test: Application written with Android Studio to practice the script from step 2. There you will find two Fragments. The first fragment has the code used in step 1, and the second one has an empty structure in order to generate the script manually. hpandro.apk: Application with challenges http_task.js: First script shown http_task2.js: Second script shown  ","permalink":"https://cmrodriguez.me/blog/hpandro-1/","tags":["Frida","Android","CTF","Challenge","HTTP"],"title":"Solving CTF with Frida - Part 1"},{"categories":["Frida","Android","PixelDungeon","Automation"],"contents":"Hi there! I come this time with a new project, automating the resolution of a game. I\u0026rsquo;ve been thinking about doing it since I found the game in 2019 for one of the presentations I did about Frida. I was hesitant of doing it because it is complex project, there are lots of things to do, a lot of tests on each step, and long hours of coding and thinking. But after around two years of trying to forget about it, the idea keeps getting in my mind over and over again. So I dediced to give it a try, and so the journey begins\u0026hellip;\nThis is the first post of a series focused on the automation of the resolution of a game with Frida. I\u0026rsquo;ll try to create a Frida script that will start a game and will play it till it finishes. Finish does not mean winning it necessarily, but getting to the game over state (trying my best to get a script with good results). I will explain later why it is not possible to achieve a 100% winning rate.\nI chose Pixel Dungeon for many reasons:\n It is an RPG game, which are my favourite type of games. It is open source, so I just have to focus on understanding the code and creating the script rather than reversing the application. It is written fully on Java, so it is a good way to practice Frida\u0026rsquo;s Java API.  Note:This series of posts are not security oriented. I\u0026rsquo;ll explain how I solved each step of the automation algorithm.\nAbout the game Pixel Dungeon is a roguelike(1) RPG game, and the objective of the game is go through all the levels of a dungeon. The player can choose between four character classes (Warrior, Mage, Rogue \u0026amp; Huntress), which have different abilities and stats. The character has different stats, a character level and HP. The player looses when the character\u0026rsquo;s HP gets to 0. In order to level-up the character has to kill monsters that will spawn while the user crawls the dungeon.\nThe dungeon is divided in levels. Each level is divided in different rooms which are connected through corridors, with stairs to go up and down the dungeon. Each level is generated randomly when the user gets into it. The algorithm assures that there is always an accesible stair to go up and down.\nThe developer of the game added a mechanics related to food consumption. The character needs to eat food regularly in order to not get to the starving state, where the player will loose 1 HP after he does a couple of steps. Food is rarely scarce, so the player needs to manage all the resources in order to avoid getting to that state. Because of this, the easiest strategies of farming monsters and getting levels won\u0026rsquo;t work. Also as everything is generated randomnly, the player will not be able to find food to give the character, and they will get to the starving state.\nThat are the reasons the game is hard to play, and it is impossible to get to a 100% win rate.\n(1) From Wikipedia:\n Roguelike is a sub-genre of role-playing video games, characterized by random level generation, tile-based graphics and permanent death.\n Strategy to solve the game I\u0026rsquo;ll use a basic strategy in order to solve this game, which is the one I use in order to play the game as well. It is a greedy strategy:\n get in each level of the dungeon. try to go through all the rooms killing all monsters found during the process and getting all the items. use food whenever the character is getting in the starved state. use health potions whenever the user gets to low levels.  There are multiple upgrades to the strategy, that I will add after I achieve the first iteration of the algorithm.\nPixel Dungeon concepts and internals Character The application has the following classes related to the character:\nFrom this class diagram the most important attributes that will be used in the algorithms are:\n Char.pos: position of the character in the map. Char.HT: temporary hitpoints. When this value gets to 0 the character dies, finishing the game.  The main stats can be found in the Hero class:\n Hero.attackSkill Hero.defenseSkill Hero.STR Hero.exp  In order to make the characted do things, the application calls the Hero.call() method. This method checks the type of the HeroAction stored in the curAction attribute and then it calls the actXxxx(HeroAction) based on it. As an example if in the curAction the application stored a HeroAction.Move object, whenever the Hero.call() is invoked, the Hero will end up calling the actMove() method, sending as a parameter the HeroAction.Move from the curAction attribute.\nAs an example, the following code can be used to move a character from one position to another:\nfunction moveCharacter(endPos) { Java.perform(function () { Java.choose(\u0026#34;com.watabou.pixeldungeon.actors.hero.Hero\u0026#34;, { onMatch: function (hero) { var heroObject = hero; var moveActionClass = Java.use(\u0026#34;com.watabou.pixeldungeon.actors.hero.HeroAction$Move\u0026#34;); var moveAction = moveActionClass.$new(endPos); heroObject.curAction.value = moveAction; heroObject.act();\t}, onComplete: function () { } }); }); } In this case we use the Java.choose API call, because we want the Hero instance created by the application when the game starts.\nLevel \u0026amp; Map The following diagram shows the main classes related to the level and map creation and update:\nThe map is divided in discrete units of space, that we will call \u0026ldquo;pixels\u0026rdquo;. Each pixel has a terrain type (the information about the values are stored in the Terrain class). Each terrain type is associated with an integer value, which can also be seen in the Terrain type. The map is basically a matrix of pixels. In the game this is stored as an array, and whenever the application needs a position, it makes count to convert the array to a matrix. This can be done, because the width of the map is a constant. Each pixel has an id, that is the position of the pixel in the array, which will be used to execute operations and validations during the game lifecycle.\nThe following image shows the values of the positions in a Room:\nThe following script was used to print the positions of the cells:\nfunction printMap(charObj, level) { var pos = charObj.pos.value; var y = Math.floor(pos / 32); var x = pos % 32; var RANGE = 6; var minY = Math.max(y-RANGE,0); var maxY = Math.min(y+RANGE,31); var minX = Math.max(x-RANGE,0); var maxX = Math.min(x+RANGE,31); for (var i = minY; i\u0026lt;= maxY; i++) { var line = \u0026#34;\u0026#34;; for (var j = minX; j \u0026lt; maxX; j++) { var posPrint = i * 32 + j; //values in Terrain.java  if (posPrint == pos) { line += \u0026#34;* \u0026#34;; } else { line += posPrint + \u0026#34; \u0026#34;; } } console.log(line); } } Java.perform(function () { Java.choose(\u0026#34;com.watabou.pixeldungeon.actors.hero.Hero\u0026#34;, { onMatch: function (hero) { var heroObject = hero; //cast a Char  var charClass = Java.use(\u0026#34;com.watabou.pixeldungeon.actors.Char\u0026#34;); var charObj = Java.cast(hero,charClass); var Dungeon = Java.use(\u0026#34;com.watabou.pixeldungeon.Dungeon\u0026#34;); var level = Dungeon.level.value; printMap(charObj, level); }, onComplete: function () { } }); }); The following image shows the values stored in the map attribute for the same Room:\nThe only change from the above script was the printMap function:\nfunction printMap(charObj, level) { var pos = charObj.pos.value; var y = Math.floor(pos / 32); var x = pos % 32; var RANGE = 6; var minY = Math.max(y-RANGE,0); var maxY = Math.min(y+RANGE,31); var minX = Math.max(x-RANGE,0); var maxX = Math.min(x+RANGE,31); for (var i = minY; i\u0026lt;= maxY; i++) { var line = \u0026#34;\u0026#34;; for (var j = minX; j \u0026lt; maxX; j++) { var posPrint = i * 32 + j; //values in Terrain.java  if (posPrint == pos) { line += \u0026#34;* \u0026#34;; } else { line += level.map.value[posPrint] + \u0026#34; \u0026#34;; } } console.log(line); } } Another important attribute from the Level class is visited, which has an Array of booleans. This array has one item per pixel, and it stores if the user visited the pixel or not. Visit a pixel means it gets into the field of view of the character.\nIn this case the visited = true is mapped to 1 and the visited = false is mapped to 0. The only change from the above script was the printMap function:\nfunction printMap(charObj, level) { var pos = charObj.pos.value; var y = Math.floor(pos / 32); var x = pos % 32; var RANGE = 6; var minY = Math.max(y-RANGE,0); var maxY = Math.min(y+RANGE,31); var minX = Math.max(x-RANGE,0); var maxX = Math.min(x+RANGE,31); for (var i = minY; i\u0026lt;= maxY; i++) { var line = \u0026#34;\u0026#34;; for (var j = minX; j \u0026lt; maxX; j++) { var posPrint = i * 32 + j; //values in Terrain.java  if (posPrint == pos) { line += \u0026#34;* \u0026#34;; } else if (level.visited.value[posPrint]) { line += \u0026#34;1 \u0026#34;; } else { line += \u0026#34;0 \u0026#34;; } } console.log(line); } } The attribute fieldOfView attribute holds which pixels can be seen by the character. It depends on the place where the user is, the max range of sight (8 pixels), and if there is any object that blocks the sight (like a wall or a closed door). This attribute is reloaded each time the character moves.\nIn this case the visible pixels are mapped to 1 and the others are mapped to 0. The only change from the above script was the printMap function:\nfunction printMap(charObj, level) { var pos = charObj.pos.value; var y = Math.floor(pos / 32); var x = pos % 32; var RANGE = 6; var minY = Math.max(y-RANGE,0); var maxY = Math.min(y+RANGE,31); var minX = Math.max(x-RANGE,0); var maxX = Math.min(x+RANGE,31); for (var i = minY; i\u0026lt;= maxY; i++) { var line = \u0026#34;\u0026#34;; for (var j = minX; j \u0026lt; maxX; j++) { var posPrint = i * 32 + j; //values in Terrain.java  if (posPrint == pos) { line += \u0026#34;* \u0026#34;; } else if (level.fieldOfView.value[posPrint]) { line += \u0026#34;1 \u0026#34;; } else { line += \u0026#34;0 \u0026#34;; } } console.log(line); } } With all this information, in next Phase, I\u0026rsquo;ll try to generate an algorithm that crawls a level in the dungeon. See you soon!\n","permalink":"https://cmrodriguez.me/blog/auto-pixeldungeon-1/","tags":["Frida","Android","PixelDungeon","Automation"],"title":"Automating Game Resolution - PixelDungeon Edition - Phase 1"},{"categories":["Frida","Android"],"contents":"TL;DR In this blogpost I show the update of the analysis on different scripts that executes the bypass of network security configuration with Frida on devices with API 27 to 29.\nIn the previous post I explain how and why each script works. It is not mandatory to read it before reading this one: https://cmrodriguez.me/blog/nsc-bypass/\nIt has been a while since I did the first analysis of different scripts used to bypass the network security configuration of Android devices. In the moment I did it we did not have in Genymotion (the VM I use for pentesting) devices with Android 27 and above, so I limited the analysis on the devices with API 24 to 26. Now we can create Android emulated devices till API 29, so I thought it was a good moment to do a review on the scripts I had collected for the first post.\nI\u0026rsquo;ll use the same criteria to execute the analysis as I did before. I created three applications with different network security configurations:\n An application that used the default NSC configuration (without network-security-config xml file) - called BypassNSC An application with a NSC file that used only system certificates - called BypassNSC2. An application with a NSC file that enforced the certificate pinning - called BypassNSC3.  Each application has three different ways to execure requests:\n OKHttp (it is also used in retrofit and volley also) HttpsURLConnection WebView (Chromium in API 25 and 26, and Default WebView in API 24).  The scripts I used are the following ones:\n network-security-config-bypass-1.js network-security-config-bypass-2.js network-security-config-bypass-3.js network-security-config-bypass-cr.js \u0026lt;\u0026ndash; this is the one I created  The following github repository has all the applications I developed and the scripts I used.\nhttps://github.com/CesarMRodriguez/network-security-config-frida-2\nThe following is a screenshot of the table I created with the results of the analysis:\nnetwork-security-config-bypass-1.js Original reference: Link\nI had to change the network-security-config-bypass-1.js. It threw some errors that in previous version of frida-cli worked. The errors were related to undefined variables. The change to avoid this error was to add in some variable declarations were the let or var modified.\nnetwork-security-config-bypass-2.js Original Reference: Link\nI had to change the network-security-config-bypass-2.js. It threw the same kind of errors as in the firs script.\nnetwork-security-config-bypass-3.js Original Reference: Link\nIn this case I did not need to change anything from the original script\nnetwork-security-config-bypass-cr.js For API 28 and AÏ 29, the original script does not work. There is a change in the signatures of the methods hooked by the library, which throws the following error:\n[NSC 28::com.example.bypassnsc]-\u0026gt; Error: ManifestConfigSource$DefaultConfigSource(): specified argument types do not match any of: .overload(\u0026#39;boolean\u0026#39;, \u0026#39;android.content.pm.ApplicationInfo\u0026#39;) at ge (frida/node_modules/frida-java-bridge/lib/class-factory.js:584) at frida/node_modules/frida-java-bridge/lib/class-factory.js:923 at /network-security-config-bypass-2.js:16 at frida/node_modules/frida-java-bridge/lib/vm.js:11 at frida/node_modules/frida-java-bridge/index.js:446 at frida/node_modules/frida-java-bridge/index.js:431 at je (frida/node_modules/frida-java-bridge/lib/class-factory.js:633) at frida/node_modules/frida-java-bridge/lib/class-factory.js:616 The fix was the following one:\nif (DefaultConfigSource.$new.argumentTypes[1].className == \u0026#34;android.content.pm.ApplicationInfo\u0026#34;) { var ApplicationInfo = Java.use(\u0026#34;android.content.pm.ApplicationInfo\u0026#34;); var appInstance = ApplicationInfo.$new(); appInstance.targetSdkVersion.value = ANDROID_VERSION_M; appInstance.targetSandboxVersion.value = 1; return DefaultConfigSource.$new(true,appInstance); } The change is neccesary because the constructor of \u0026ldquo;DefaultConfigSource\u0026rdquo; changed to the following one:\nDefaultConfigSource(boolean usesCleartextTraffic, ApplicationInfo info) { mDefaultConfig = NetworkSecurityConfig.getDefaultBuilder(info) .setCleartextTrafficPermitted(usesCleartextTraffic) .build(); } I also had to set some values in the second parameter (object from class ApplicatoinInfo). In order to see what we need to set, we had to check the implementation of the method getDefaultBuilder from the NetworkSecurityConfig class:\npublic static Builder getDefaultBuilder(ApplicationInfo info) { Builder builder = new Builder() .setHstsEnforced(DEFAULT_HSTS_ENFORCED) // System certificate store, does not bypass static pins.  .addCertificatesEntryRef( new CertificatesEntryRef(SystemCertificateSource.getInstance(), false)); final boolean cleartextTrafficPermitted = info.targetSdkVersion \u0026lt; Build.VERSION_CODES.P \u0026amp;\u0026amp; info.targetSandboxVersion \u0026lt; 2; builder.setCleartextTrafficPermitted(cleartextTrafficPermitted); // Applications targeting N and above must opt in into trusting the user added certificate  // store.  if (info.targetSdkVersion \u0026lt;= Build.VERSION_CODES.M \u0026amp;\u0026amp; !info.isPrivilegedApp()) { // User certificate store, does not bypass static pins.  builder.addCertificatesEntryRef( new CertificatesEntryRef(UserCertificateSource.getInstance(), false)); } return builder; } we can see that we have to set the \u0026ldquo;targetSdkVersion\u0026rdquo; to 23 in order to make the application to import UserCertificateSource, and we need to set targetSandboxVersion to 1, so the clearTextTraffic is set to true.\nWith this change, the script worked as intended. I also checked the parameter types to make the script compatible with older versions as well.\nConclusion: The results from the analysis of the scripts used for the network security config bypass show that they are as effective in the newer APIs as they were in the old ones. Two of the scripts works in all scenarios (network-security-config-1.js) and (network-security-config-cr.js).\n","permalink":"https://cmrodriguez.me/blog/nsc-bypass-2/","tags":["Frida","Android"],"title":"Network Security Configuration bypasses with Frida (update API 27-29)"},{"categories":["Misc","CTF"],"contents":"In this post I will solve the challenge called Serializado, created for the Ekoparty 2020 - Mobile Hacking Space CTF. In this challenge we have the following file.\nserializable.ab\nThe serializable.ab seems to be a back-up created through an Android OS. In order to get the content of the file we can execute the following command:\ndd if=serializable.ab bs=1 skip=24 | python -c \u0026#34;import zlib,sys;sys.stdout.write(zlib.decompress(sys.stdin.read()))\u0026#34; | tar -xvf - This will generate the following result:\n apps/com.mhs.serializado/manifest apps/com.mhs.serializado/a/base.apk apps/com.mhs.serializado/r/key.ser apps/com.mhs.serializado/r/content.txt  In order to check what is each file, we have to open the base.apk file, which is the application backed-up in this file:\njadx-gui apps/com.mhs.serializado/a/base.apk In this application we have two activitied, SplashActivity.java (which is a splash screen page with no logic), and MainActivity.java which has two buttons btnStore and btnLoad.\nWe check what the btnStore does by going through the decompiled source code:\n get bytes from txtSecretPassword value:  String content = MainActivity.this.txtSecretPassword.getText().toString(); ... byte[] key = content.getBytes(StandardCharsets.UTF_8); Generate a CipherManagement class:  CipherManagement cipherManagement = new CipherManagement(); int i = 0; cipherManagement.x1 = key[0]; cipherManagement.x2 = key[1]; cipherManagement.x3 = key[2]; cipherManagement.x4 = key[3]; cipherManagement.x5 = key[4]; cipherManagement.x6 = key[5]; cipherManagement.x7 = key[6]; cipherManagement.x8 = key[7]; cipherManagement.x9 = key[8]; cipherManagement.x10 = key[9]; cipherManagement.x11 = key[10]; cipherManagement.x12 = key[11]; cipherManagement.x13 = key[12]; cipherManagement.x14 = key[13]; cipherManagement.x15 = key[14]; cipherManagement.x16 = key[15]; cipherManagement.generateSecret(); Call serializeObject from class Serializer. This class does, but here we can see that there is a key.ser String, which is the name of a file in the backup found.  Serializer.serializeObject(cipherManagement, \u0026#34;key.ser\u0026#34;); Generates a file called ontent.txt with the value taken from txtContent, encrypted through the CipherManagement class, and then encoded in Base64. That is the second file we have in the backup.  String multiLines = MainActivity.this.txtContent.getText().toString(); try { FileOutputStream fOut = new FileOutputStream(new File(\u0026#34;/data/data/com.mhs.serializado/content.txt\u0026#34;)); OutputStreamWriter myOutWriter = new OutputStreamWriter(fOut); String[] lines = multiLines.split(\u0026#34;\\n\u0026#34;); try { int length = lines.length; int i2 = 0; while (i2 \u0026lt; length) { myOutWriter.append(Base64.encodeToString(cipherManagement.encrypt(lines[i2]), i)); i2++; i = 0; } } catch (Exception e) { e.printStackTrace(); } myOutWriter.close(); fOut.flush(); fOut.close(); } catch (IOException e2) { Log.e(\u0026#34;Exception\u0026#34;, \u0026#34;File write failed: \u0026#34; + e2.toString()); } In the case of the btnLoad, the application does the following:\n Recover the key from the key.ser file:  CipherManagement cipherManagement = (CipherManagement) Serializer.deserializeObject(\u0026#34;key.ser\u0026#34;); if (cipherManagement == null) { Toast.makeText(MainActivity.this.getApplicationContext(), \u0026#34;Nothing encrypted yet\u0026#34;, 1).show(); return; } Sets the keyin the txtSecretPassword field:  byte[] key = {cipherManagement.x1, cipherManagement.x2, cipherManagement.x3, cipherManagement.x4, cipherManagement.x5, cipherManagement.x6, cipherManagement.x7, cipherManagement.x8, cipherManagement.x9, cipherManagement.x10, cipherManagement.x11, cipherManagement.x12, cipherManagement.x13, cipherManagement.x14, cipherManagement.x15, cipherManagement.x16}; cipherManagement.generateSecret(); MainActivity.this.txtSecretPassword.setText(new String(key, StandardCharsets.UTF_8)); Gets the content of the content.txt file, and tries to decode it. First it decodes the content of the fiñe with a Base64 decoder, then the application tries to decrypt the decoded text with the CipherManagement class, and the result is being set in the txtContext field.  new InputStreamReader(new FileInputStream(new File(\u0026#34;/data/data/com.mhs.serializado/content.txt\u0026#34;))); StringBuilder resultingContent = new StringBuilder(); if (Build.VERSION.SDK_INT \u0026gt;= 26) { for (String line : Files.readAllLines(Paths.get(\u0026#34;/data/data/com.mhs.serializado/content.txt\u0026#34;, new String[0]), Charset.defaultCharset())) { String decodedLine = cipherManagement.decrypt(Base64.decode(line, 0)); resultingContent.append(decodedLine + \u0026#34;\\n\u0026#34;); } } MainActivity.this.txtContent.setText(resultingContent.toString()); The Serializer stores and loads a Java serialized object in the root package of the application. In this case the object being stored and loaded is a ChiperManagement instance, which holds the key.\nAfter the analysis of the source code, we need to install the application and upload the backup.\nSo we first try to install the apk:\nadb install apps/com.mhs.serializado/a/base.apk which returns the following output:\nPerforming Streamed Install adb: failed to install apps/com.mhs.serializado/a/base.apk: Failure [INSTALL_FAILED_TEST_ONLY: installPackageLI] this error is due to a flag of test in the manifest. We need to add a -t option in the adb install command to avoid this error:\nadb install -t apps/com.mhs.serializado/a/base.apk Now we need to restore the backup. As this is trivial in this case I will do it manually:\nadb shell rm /data/data/com.mhs.serializado/content.txt adb shell rm /data/data/com.mhs.serializado/key.ser adb push content.txt /data/data/com.mhs.serializado adb push key.ser /data/data/com.mhs.serializado Now we need to change the user rights on the files. So first you need to know the name of the user assigned by Android to the application, which will depend on the cellphone, so execute:\nadb shell ls -al /data/data/com.mhs.serializado where you will get the a content similar to the following one:\ndrwx------ 4 u0_a118 u0_a118 4096 2020-11-28 17:00 . drwxrwx--x 169 system system 12288 2020-11-09 12:08 .. drwxrws--x 2 u0_a118 u0_a118_cache 4096 2020-08-18 03:10 cache drwxrws--x 2 u0_a118 u0_a118_cache 4096 2020-08-18 03:10 code_cache In this case the user is u0_118, so we execute:\nadb shell chown u0_a118:u0_a118 /data/data/com.mhs.serializado/content.txt adb shell chown u0_a118:u0_a118 /data/data/com.mhs.serializado/key.ser When we try to restore the content we get an error in the log:\nSystem.out I IOException is caught We have no information about what is going on, so let\u0026rsquo;s check the content of the key file. As it is a Java-serialized object, we can use a tool called SerializationDumper (add link here).\njava -jar SerializationDumper-v1.13.jar -f key.ser STREAM_MAGIC - 0xac ed STREAM_VERSION - 0x00 05 Contents TC_OBJECT - 0x73 TC_CLASSDESC - 0x72 className Length - 36 - 0x00 24 Value - com.mhs.serializado.CipherManagement - 0x636f6d2e6d68732e73657269616c697a61646f2e4369706865724d616e6167656d656e74 serialVersionUID - 0xb2 8a 53 35 20 34 41 18 newHandle 0x00 7e 00 00 classDescFlags - 0x02 - SC_SERIALIZABLE fieldCount - 16 - 0x00 10 Fields 0: Byte - B - 0x42 fieldName Length - 2 - 0x00 02 Value - x1 - 0x7831 1: Byte - B - 0x42 ... 15: Byte - B - 0x42 fieldName Length - 2 - 0x00 02 Value - x9 - 0x7839 classAnnotations TC_ENDBLOCKDATA - 0x78 superClassDesc TC_NULL - 0x70 newHandle 0x00 7e 00 01 classdata com.mhs.serializado.CipherManagement values x1 (byte)97 (ASCII: a) - 0x61 x10 ... x6 (byte)57 (ASCII: 9) - 0x39 x7 Exception in thread \u0026#34;main\u0026#34; java.util.NoSuchElementException at java.util.LinkedList.removeFirst(LinkedList.java:270) at java.util.LinkedList.pop(LinkedList.java:801) at nb.deser.SerializationDumper.readByteField(SerializationDumper.java:1369) at nb.deser.SerializationDumper.readFieldValue(SerializationDumper.java:953) at nb.deser.SerializationDumper.readClassDataField(SerializationDumper.java:939) at nb.deser.SerializationDumper.readClassData(SerializationDumper.java:886) at nb.deser.SerializationDumper.readNewObject(SerializationDumper.java:467) at nb.deser.SerializationDumper.readContentElement(SerializationDumper.java:359) at nb.deser.SerializationDumper.parseStream(SerializationDumper.java:331) at nb.deser.SerializationDumper.main(SerializationDumper.java:113) Through the error we get that the serialized file seems to be corrupted. There seems to be three values missing. As we can see in the definition of the class:\npublic class CipherManagement implements Serializable { private transient byte[] inferedKey = new byte[16]; public byte x1; public byte x10; public byte x11; public byte x12; public byte x13; public byte x14; public byte x15; public byte x16; public byte x2; public byte x3; public byte x4; public byte x5; public byte x6; public byte x7; public byte x8; public byte x9; Now we can assume the following:\n The known values are ordered. We do not know which values are missing. We\u0026rsquo;ll try to test this with alphanumeric (a-zA-Z0-9) and if that does not work we\u0026rsquo;ll test it with printable characters.  I built the following java application in order to test this, and make the process faster than using Frida:\npublic static void main(String[] args) { // TODO Auto-generated method stub \tString content = \u0026#34;jBUwXJdjVaHvZuYfaw/cew==\u0026#34;; byte array[] = Base64.getDecoder().decode(content); CipherManagement cipher = new CipherManagement(); cipher.generateSecret(); CharsetEncoder encoder = Charset.forName(\u0026#34;US-ASCII\u0026#34;).newEncoder(); //starting time \tprintTime(); // rotating positions \tfor (int pos1 = 0; pos1 \u0026lt; 14; pos1++) { for (int pos2 = pos1 + 1; pos2 \u0026lt; 15; pos2++) { for (int pos3 = pos2 + 1; pos3 \u0026lt; 16; pos3++) { setStaticValues(cipher, pos1, pos2, pos3); //bruteforcing just alphanumeric values to check if it returns results fast. \tfor (byte x = 49; x \u0026lt;= 122; x++) { setValue(cipher, pos1, x); for (byte y = 49; y \u0026lt;= 122; y++) { setValue(cipher, pos2, y); for (byte z = 49; z \u0026lt;= 122; z++) { setValue(cipher, pos3, z); cipher.generateSecret(); String decrypted; try { decrypted = cipher.decrypt(array); //this filters the solutions sent to output, but still there are false positives. \tif (encoder.canEncode(decrypted)) { System.out.println(decrypted); //this loop is just to measure what time it takes to get the key \tif (\u0026#34;banana_loca\u0026#34;.equals(decrypted)) { printTime(); return; } } } catch (Exception e) { // TODO Auto-generated catch block \t} } } } } } } } the full source code is in the following repository: solving-serializado\nWith this algorithm I found the key in 13,5 minutes, and decrypted the content of the text that is \u0026ldquo;banana_loca\u0026rdquo;.\n","permalink":"https://cmrodriguez.me/blog/solving-serialized/","tags":null,"title":"CTF - Solving Serialized"},{"categories":["Frida","Android"],"contents":"In this guide I will show how to write scripts in Frida. The idea is not to show how Frida works or what can be done with it, there are plenty of those kind of blogs around. While using this amazing tool I find sometimes hard to know how to write a script in order to make the application do what I want to, and as the documentation does not go too deep on that, sometimes I find myself going through different examples till I find how to solve something related to the syntaxis of the Java bridge. So I wrote this guide in order to concentrate that knowledge in one place.\nThe content is divided in several pages, in order to make it easily searchable. In the content you\u0026rsquo;ll find how to write Java code in the Frida-bridge syntaxis. So I\u0026rsquo;ll go through different Java language features and how to write it as a script in Frida. In order to do this, I wrote an application that has many classes that uses different components (like Interfaces, arrays or anonymous classes). Each page will have a brief introduction of the Java feature (not a through one, as it is only intended to make the user understand what is being done in the code), explain how to do the same with Frida and then an example of how it was done in the demo application. The source code and the application can be downloaded from the following github page: https://github.com/CesarMRodriguez/frida-scripting-guide/\nIndex  Primitive types Methods Access to content of classes \u0026ldquo;this\u0026rdquo; reference Arrays Enums Inheritance Interfaces Inner classes Exception handling  ","permalink":"https://cmrodriguez.me/blog/frida-scripting-guide/","tags":["Android","Frida","Scripting guide"],"title":"Frida Scripting Guide for Java"},{"categories":["Misc"],"contents":"Hi there! My name is Cesar! It will be next April 3 years, since I am advocated full time to my Security Career. Now I\u0026rsquo;m working as a Security Researcher in Faraday Security Labs. I started my career not knowing what I wanted to do, as my only experience with security was related to development.\nDuring these years I\u0026rsquo;ve been working on different technologies, programming languages, so it was hard for me to find something I particularly liked or wanted to do with my professional career, till I got to do a Mobile application security assessment. It was a mix of Java/Objective-C/Swift (as I am a Java developer this technology is natural for me), hardware, client-side exploitation, native OS library reversing, web application assessment (hybrid libraries) and an endless quantity of frameworks.\nIt was pretty hard for me to start doing mobile assessments, because there are a lot of concepts, restrictions and techniques that are different from the Web security discipline. So in this blog I\u0026rsquo;ll try to help others in the process of getting into the Mobile Security world, and my passion for this environment.\n","permalink":"https://cmrodriguez.me/blog/hello-world/","tags":null,"title":"Hello World!"},{"categories":["Frida","Android"],"contents":"In this post I will explain how to use and instance different data types from Java with Frida. In Java we have the following basic types:\n byte: Byte-length integer short: Short integer int: Integer long: Long integer float: Single-precision floating point double: Double-precision floating point char: A single character boolean: A Boolean value (true or false)  Using integer types The different integer types are casted by frida automatically to the Javascript numeric type, which is capable of holding the the long Java type without loosing information. As an example the following code calls different functions from the BasicTypes class, and they are printed by Frida with no need to cast the types:\nvar BasicTypes = Java.use(\u0026#34;com.blog.testfrida.examples.BasicTypes\u0026#34;); console.log(\u0026#34;addTwoInts: \u0026#34; + BasicTypes.addTwoInts(1,2)); console.log(\u0026#34;addTwoBytes: \u0026#34; + BasicTypes.addTwoBytes(1+1,3)); console.log(\u0026#34;addTwoShorts: \u0026#34; + BasicTypes.addTwoShorts(1-1,4)); console.log(\u0026#34;addTwoLongs: \u0026#34; + BasicTypes.addTwoLongs(1*1,5)); console.log(\u0026#34;addTwoInts: \u0026#34; + BasicTypes.addTwoInts(1/1,2));   console.log** is the function used to print in the frida CLI application output.\n  BasicTypes** is the javascript wrapper for the BasicTypes class, binded by using the **Java.use** function.\n Frida casts automatically values as well in the reimplementation of functions:\nBasicTypes.addTwoBytes.implementation = function (var1,var2) { console.log(\u0026#34;test addTwoBytes\u0026#34;); return 3+4; } BasicTypes.addTwoShorts.implementation = function (var1,var2) { console.log(\u0026#34;test addTwoShorts\u0026#34;); return 3+4; } BasicTypes.addTwoLongs.implementation = function (var1,var2) { console.log(\u0026#34;test addTwoLongs\u0026#34;); return 3+4; } In this case to test the function, it needs to be run from the Java environment, because the changes are not being reflected on the method in the Frida environment, that is why I created in a button in the Main Activity of the application. So in order to trigger the modified behavior you need to click the button in the application.\nUsing boolean types Frida converts automatically from Java boolean type to javascript boolean with no weird behavior. The following example is used to send boolean values from the Frida bridge to Java, and from Java to the script:\nvar testBooleanValues = function () { var BasicTypes = Java.use(\u0026#34;com.blog.testfrida.examples.BasicTypes\u0026#34;); console.log(BasicTypes.negate(false)); console.log(BasicTypes.negate(true)); BasicTypes.negate.implementation = function (var1) { console.log(\u0026#34;test negate\u0026#34;); return false; } } Using floating point types  WARNING In floating points we see some differences. The issue comes from the use of float values\n As an example, when the 23/3 is executed, the Java operation returns 7.666666507720947, because of the limitation on the precision. But javascript by default has an extended precision, so the division returns 7.666666666666667, as the double Java operation does. So be careful when you override a method as there could be issues when some value is sent to a function that works on floats. The following code shows multiple scenarios of float manipulation:\nvar testFloatValues = function () { var BasicTypes = Java.use(\u0026#34;com.blog.testfrida.examples.BasicTypes\u0026#34;); console.log(\u0026#34;native values\u0026#34;); console.log(23.0/3.0); console.log(0.1234567890123/1); console.log(2/5); console.log(\u0026#34;java values\u0026#34;); console.log(BasicTypes.divideFloat(23,3)); console.log(BasicTypes.divideFloat(0.1234567890123,1)); console.log(BasicTypes.divideDouble(2,5)); console.log(BasicTypes.divideDouble(23,3)); console.log(BasicTypes.divideDouble(0.1234567890123,1)); BasicTypes.divideFloat.implementation = function (var1, var2) { console.log(\u0026#34;test divideFloat\u0026#34;); return var1 / var2; } BasicTypes.divideDouble.implementation = function (var1, var2) { console.log(\u0026#34;test divideDouble\u0026#34;); return var1 / var2; } } which returns the following output:\njavascript values\n 23/3: 7.666666666666667 0.1234567890123/1: 0.1234567890123 2/5: 0.4  java values\n 23/3 (float): 7.666666507720947 0.1234567890123/1 (float): 0.12345679104328156 2/5(float): 0.4 23/3 (double): 7.666666666666667 0.1234567890123/1 (double): 0.1234567890123  Using char types Frida converts automatically from Java char type to javascript char with no weird behavior. The following example is used to send char values from the Frida bridge to Java, and from Java to the script:\nvar testCharValues = function () { var BasicTypes = Java.use(\u0026#34;com.blog.testfrida.examples.BasicTypes\u0026#34;); console.log(BasicTypes.getNextChar(\u0026#39;a\u0026#39;)); console.log(BasicTypes.isCChar(\u0026#39;f\u0026#39;)); console.log(BasicTypes.isCChar(\u0026#39;c\u0026#39;)); BasicTypes.getNextChar.implementation = function (char1) { return \u0026#39;F\u0026#39;; } BasicTypes.isCChar.implementation = function (char1) { return char1 == \u0026#39;c\u0026#39;; } } Using String type In this case the String is managed as a classic Java Object with some particularities regarding the javascript string type. Based on the previous logic used to send basic type parameters , we could call a method that receives two Strings in the following way:\nvar testStrings = function () { var BasicTypes = Java.use(\u0026#34;com.blog.testfrida.examples.BasicTypes\u0026#34;); console.log(BasicTypes.concatString(\u0026#34;first\u0026#34;,\u0026#34;second\u0026#34;)); } When we run this, we get the following error:\nTypeError: undefined not callable (property \u0026#39;concatString\u0026#39; of [object Object]) at [anon] (../../../frida-gum/bindings/gumjs/duktape.c:65012) at /examples.js:112 at frida/node_modules/frida-java-bridge/lib/vm.js:11 at E (frida/node_modules/frida-java-bridge/index.js:346) at frida/node_modules/frida-java-bridge/index.js:298 at frida/node_modules/frida-java-bridge/lib/vm.js:11 This is an error because the parameter sent is a native javascript String, but it should be encapsulated in a java.lang.String object. So we need to create an instance of the String:\nvar String = Java.use(\u0026#34;java.lang.String\u0026#34;); var str1 = String.$new(\u0026#34;test \u0026#34;); var str2 = String.$new(\u0026#34;String\u0026#34;); console.log(BasicTypes.concatString(str1,str2)); The second step to test is the override of a method that receives one or more String. We created the following function that overrides the concatString method from the example APK:\nBasicTypes.concatString.implementation = function (str1,str2) { console.log(\u0026#34;First string: \u0026#34; + str1); console.log(\u0026#34;Second string: \u0026#34; + str2); return str1 + str2; } This code works perfectly because Frida wraps the String parameters and then returns a Javascript String to the internal implementation. So the concatenation works as in javascript, and Frida is in charge of converting the result to a java.lang.String object. Also the concatenation works with native attributes as it does in Java. As an example the following command works in java and in Javascript in the same way:\n str1\u0026lt;\u0026quot;test \u0026ldquo;\u0026gt; + int1 \u0026lt;2\u0026gt; + str2 \u0026lt;\u0026quot;strings\u0026quot;\u0026gt; = \u0026ldquo;test 2 strings\u0026rdquo;\n String comparison The difference between a comparison between a native variable and a String is that the former is an object. So the variable that the developer manipulates holds a reference (pointer or memory value) to the real object. This is the reason a comparison == does not work with Strings, as it will naturally compare the references from the two Strings instead of the content. So to compare in Frida you should use the following script:\nvar strHex = String.$new(\u0026#34;hex\u0026#34;); console.log(\u0026#34;--\u0026gt; test\u0026#34;); return strHex.equals(str1); Accesing String attributes If the String is in an attribute of a class, and you want to get access from the Frida script, you need to access it through the attribute \u0026ldquo;value\u0026rdquo;, as in the following example:\nvar ScopedObject = Java.use(\u0026#34;com.blog.testfrida.complexobjects.ScopeObject\u0026#34;); console.log(\u0026#34;Direct access: \u0026#34; + ScopedObject.publicStaticObject.value); Encapsulation of attributes (optional) Initially I thought the access to an attribute will be transparent for the frida cli, so the first time I got to the situation of retrieving it, I tested the following FridaSnippet:\nvar ScopedObject = Java.use(\u0026#34;com.blog.testfrida.complexobjects.ScopeObject\u0026#34;); console.log(\u0026#34;Direct access: \u0026#34; + ScopedObject.publicStaticObject); which printed \u0026ldquo;Direct access: [object Object]\u0026quot;. This is due to the fact that the attributes in a Frida Object holds an encapsulation of a class. So when someone access it directly, it will return this content, and in this case it will cast it to the default Object string. To print the raw content of the variable (to check what it is), we can use the JSON.stringify javascript function:\nvar ScopedObject = Java.use(\u0026#34;com.blog.testfrida.complexobjects.ScopeObject\u0026#34;); console.log(\u0026#34;Direct access: \u0026#34; + JSON.stringify(ScopedObject.publicStaticObject)); which will return:\n {\u0026ldquo;fieldType\u0026rdquo;:1,\u0026ldquo;fieldReturnType\u0026rdquo;:{\u0026ldquo;className\u0026rdquo;:\u0026ldquo;java.lang.String\u0026rdquo;,\u0026ldquo;name\u0026rdquo;:\u0026ldquo;Ljava/lang/String;\u0026quot;,\u0026ldquo;type\u0026rdquo;:\u0026ldquo;pointer\u0026rdquo;,\u0026ldquo;size\u0026rdquo;:1},\u0026ldquo;$holder\u0026rdquo;:{}}\n which shows that the field is of type java.lang.String. In order to return the actual value, we should call the attribute value from the Frida Object.\nNext: Methods\n","permalink":"https://cmrodriguez.me/blog/primitive-types/","tags":["Frida","Android","Scripting guide"],"title":"Frida Scripting Guide (1) - Primitive Types"},{"categories":["Frida","Android"],"contents":"In this post I will explain how to call methods from java through Frida. A method is a function that belongs to a class. In Java all the functions are attached to classes. We have two different kind of methods. The static ones, that can be called from a Class, and the non-static that can only be used from an instance of an object. If you need any more information about this, check the following link: Static and Non Static Methods.\nThe following code snippet shows how to call a static method:\nvar BasicTypes = Java.use(\u0026#34;com.blog.testfrida.examples.BasicTypes\u0026#34;); BasicTypes.divideFloat(23,3); To call a non-static method, we need to get first an object, so we need first to get the class reference in Frida:\nvar Person = Java.use(\u0026#34;com.blog.testfrida.complexobjects.Person\u0026#34;); Then we create an object from that class. This special method is called constructor):\nvar personInstance = Person.$new(); personInstance.setId(1); The following code shows how to send parameters to a method:\nvar String = Java.use(\u0026#34;java.lang.String\u0026#34;); personInstance.setName(String.$new(\u0026#34;Peter Griffin\u0026#34;));  Note that the parameters sent have to be javascript encapsulated objects\n Overridden methods In Java there is a possibility to generate overridden methods. Basically it means that two or more methods have the same name and different parameters (in quantity and type). As an example the following java code snippet is valid:\npublic static int multiply(int val1, int val2) { return val1 * val2; } ​ public static byte multiply(byte val1, byte val2) { return (byte) (val1 * val2); } If you want to use an overridden method, the syntax does not change, as Frida solves the method by the argument types, so in the previous example the snippet code to call the multiply operation would be the following one:\nvar BasicTypes = Java.use(\u0026#34;com.blog.testfrida.examples.BasicTypes\u0026#34;); console.log(BasicTypes.multiply(3,5)); The difference in the syntax comes when you want to modify a method with overridden options. The naive approach would be the following one:\nvar BasicTypes = Java.use(\u0026#34;com.blog.testfrida.examples.BasicTypes\u0026#34;); console.log(BasicTypes.multiply(3,5)); ​ BasicTypes.multiply.implementation = function (val1, val2) { console.log(\u0026#34;it works\u0026#34;); return val1 * val2; } If that code is executed, you\u0026rsquo;ll see in the Frida cli console the following error:\nError: multiply(): has more than one overload, use .overload() to choose from: .overload(\u0026#39;long\u0026#39;, \u0026#39;long\u0026#39;) .overload(\u0026#39;byte\u0026#39;, \u0026#39;byte\u0026#39;) .overload(\u0026#39;short\u0026#39;, \u0026#39;short\u0026#39;) .overload(\u0026#39;int\u0026#39;, \u0026#39;int\u0026#39;) .overload(\u0026#39;float\u0026#39;, \u0026#39;float\u0026#39;) at throwOverloadError (frida/node_modules/frida-java-bridge/lib/class-factory.js:1054) at frida/node_modules/frida-java-bridge/lib/class-factory.js:714 at /examples.js:164 which states that you should define which of the overridden methods you want to modify. As an example we\u0026rsquo;ll modify the multiplication of two ints:\nBasicTypes.multiply.overload(\u0026#39;int\u0026#39;,\u0026#39;int\u0026#39;).implementation = function (val1, val2) { return val1 * val2; } Once you start to write Frida scripts, you will eventually find the need to modify or rewrite an overridden method. Not all the types of attributes are written as clear as the basic types. The following table can help to search for the types:\n   Java Type Frida Type     int int   byte byte   short short   long long   float float   double double   char char   {Object} (eg. String) {package}.{Object} (eg. java.lang.String)   int[] [I   byte[] [B   short[] [S   long[] [J   float[] [F   double[] [D   char[] [C   {Object}[] [L{package}.{Object} (eg. [Ljava.lang.String)     Note that the object array starts with a \u0026ldquo;L\u0026rdquo; char.\n If you wander where those weird data types comes from, they are inherited by the dex specification (Java code is transformed in dex format when the application is compiled). Primitives are represented by a single letter. They are actually stored in the dex file, in string form. They are specified in the Dex format document in the AOSP repository.\nAs an example the following script lists all the overridden methods with their signatures:\nfunction listOverritenMethods(className, func) { var Class = Java.use(className); var overloadedMethods = Class[func].overloads; for (i in overloadedMethods) { if (overloadedMethods[i].hasOwnProperty(\u0026#39;argumentTypes\u0026#39;)) { var parameterString = \u0026#34;(\u0026#34;; for (j in overloadedMethods[i].argumentTypes) { parameterString = parameterString + overloadedMethods[i].argumentTypes[j].className + \u0026#34;,\u0026#34;; } parameterString = parameterString.slice(0,-1) + \u0026#34;)\u0026#34;; console.log(func + parameterString); } } } ​ Java.perform(function () { listOverritenMethods(\u0026#34;com.blog.testfrida.examples.BasicTypes\u0026#34;,\u0026#34;multiply\u0026#34;) }); Next: Access to content of classes\n","permalink":"https://cmrodriguez.me/blog/methods/","tags":["Frida","Android","Scripting guide"],"title":"Frida Scripting Guide (2) - Methods"},{"categories":["Frida","Android"],"contents":"TL;DR In this blogpost I show the results of an analysis done over some frida scripts that allows the bypass of the network security configuration in Android. I show a new way to bypass the configuration. Also I will show the procedure used to test the scripts in multiple scenarios, and an analysis of the reason some scripts do not work in all the test-cases.\nA couple of months ago I was in the middle of an Android application security assessment. One of the first steps while preparing the environment to start the pentest is configuring the application to bypass the network security config (check this link for references regarding network security config: https://developer.android.com/training/articles/security-config). As I am a frida fan, I tend to do everything with it (there are other alternatives to do this: https://www.nccgroup.trust/uk/about-us/newsroom-and-events/blogs/2017/november/bypassing-androids-network-security-configuration/).\nI downloaded two or three scripts at that moment, but when I run it in my Android 7.1.0, none of those worked. That was the reason I started to analyze how the network security config worked, and how to bypass it with frida. The first thing I did was to generate different test cases. I tried to choose the most popular ones:\n OKHttp (it is also used in retrofit and volley also) HttpsURLConnection WebView (Chromium in API 25 and 26, and Default WebView in API 24).  Then I generated three applications with different network security config:\n An application that used the default NSC configuration (without network-security-config xml file) - called BypassNSC An application with a NSC file that used only system certificates - called BypassNSC2. An application with a NSC file that enforced the certificate pinning - called BypassNSC3.  At the time of evaluating the scripts with my test suite, only one worked in the 100% of the cases. I also developed an alternative that also works in all of the cases.\nThe code that parses and validates the network security config is in the Android SDK, so it might change between versions. I tested the scripts with the versions 24,25 and 26.\nThe following github repository has all the applications I developed and the scripts I used.\nhttps://github.com/CesarMRodriguez/network-security-config-frida\nThe scripts are called:\n network-security-config-bypass-1.js network-security-config-bypass-2.js network-security-config-bypass-3.js network-security-config-bypass-cr.js \u0026lt;\u0026ndash; this is the one I created  The following is a screenshot of the table I created with the results of the analysis:\nI analysed all the scripts I downloaded to know why it didn\u0026rsquo;t work in some of the scenarios.\nnetwork-security-config-bypass-1.js Original reference: Link\nIn this case the script basically modifies the getEffectiveCertificatesEntryRefs method from the NetworkSecurityConfig.Builder class. This method returns the list of valid certificates. In a standard Android configuration, the list of certificates it returns is the ones installed in the system. In this script, the certificates installed by the user are also returned. So it is logical that the bypass for the first two applications worked, but I was surprised that the ones with the certificate pinning configuration also worked. The method that validates the pinning is the following one:\nandroid.security.net.config.NetworkSecurityTrustManager.checkPins The following stacktrace shows the path executed till it gets to the checkPins function:\nat android.security.net.config.NetworkSecurityTrustManager.checkPins(Native Method) at android.security.net.config.NetworkSecurityTrustManager.checkServerTrusted(NetworkSecurityTrustManager.java:95) at android.security.net.config.RootTrustManager.checkServerTrusted(RootTrustManager.java:88) at com.android.org.conscrypt.Platform.checkServerTrusted(Platform.java:178) at com.android.org.conscrypt.OpenSSLSocketImpl.verifyCertificateChain(OpenSSLSocketImpl.java:596) at com.android.org.conscrypt.NativeCrypto.SSL_do_handshake(Native Method) at com.android.org.conscrypt.OpenSSLSocketImpl.startHandshake(OpenSSLSocketImpl.java:357) ... If the patch is not executed, the following exception is thrown when it gets to that method:\nCaused by: java.security.cert.CertificateException: Pin verification failed at android.security.net.config.NetworkSecurityTrustManager.checkPins(NetworkSecurityTrustManager.java:148) at android.security.net.config.NetworkSecurityTrustManager.checkServerTrusted(NetworkSecurityTrustManager.java:95) at android.security.net.config.RootTrustManager.checkServerTrusted(RootTrustManager.java:88) at com.android.org.conscrypt.Platform.checkServerTrusted(Platform.java:178) at com.android.org.conscrypt.OpenSSLSocketImpl.verifyCertificateChain(OpenSSLSocketImpl.java:596) at com.android.org.conscrypt.NativeCrypto.SSL_do_handshake(Native Method) at com.android.org. Let\u0026rsquo;s check the implementation of this method (API 25):\nprivate void checkPins(List\u0026lt;X509Certificate\u0026gt; chain) throws CertificateException { PinSet pinSet = mNetworkSecurityConfig.getPins(); if (pinSet.pins.isEmpty() || System.currentTimeMillis() \u0026gt; pinSet.expirationTime || !isPinningEnforced(chain)) { return; } Set\u0026lt;String\u0026gt; pinAlgorithms = pinSet.getPinAlgorithms(); Map\u0026lt;String, MessageDigest\u0026gt; digestMap = new ArrayMap\u0026lt;String, MessageDigest\u0026gt;( pinAlgorithms.size()); for (int i = chain.size() - 1; i \u0026gt;= 0 ; i--) { X509Certificate cert = chain.get(i); byte[] encodedSPKI = cert.getPublicKey().getEncoded(); for (String algorithm : pinAlgorithms) { MessageDigest md = digestMap.get(algorithm); if (md == null) { try { md = MessageDigest.getInstance(algorithm); } catch (GeneralSecurityException e) { throw new RuntimeException(e); } digestMap.put(algorithm, md); } if (pinSet.pins.contains(new Pin(algorithm, md.digest(encodedSPKI)))) { return; } } } // TODO: Throw a subclass of CertificateException which indicates a pinning failure.  throw new CertificateException(\u0026#34;Pin verification failed\u0026#34;); } This method receives a list of certificates returned by the site when the communication starts. The first thing it does is checking some conditions:\n the pinset (list of pins loaded during the configuration instantiation) is empty. the pinset has expired at the moment of validation pinning is NOT enforced by configuration  If any of those conditions are true, pinning validation is ignored. In case the validation must be achieved, the application checks if any of the certificates provided by the site matches with one of the pins defined in the network security config file. In that case the validation is successful. If that does not happen, the method throws the exception shown in the previous stacktrace.\nInitially I thought the issue was in the for loop that analyzed each of the certificates, so I added the following log in the frida script:\nvar Pin = Java.use(\u0026#34;android.security.net.config.Pin\u0026#34;); Pin.$init.implementation = function (digestAlg, digest) { var bt = Java.use(\u0026#34;android.util.Log\u0026#34;).getStackTraceString(Java.use(\u0026#34;java.lang.Exception\u0026#34;).$new()); console.log(\u0026#34;\\nBacktrace:\\n\u0026#34; + bt); console.log(digestAlg); return this.$init(digestAlg,digest); } It should print each of the Pins created during the evaluation. When I run the application with the changes I found that the application wasn\u0026rsquo;t getting to that point.\nI thought it could be because of the for loop, so I added a log in the call to pinSet.getPinAlgorithms(), that was executed before the for loop:\nvar PinSet = Java.use(\u0026#34;android.security.net.config.PinSet\u0026#34;); PinSet.getPinAlgorithms.implementation = function () { var bt = Java.use(\u0026#34;android.util.Log\u0026#34;).getStackTraceString(Java.use(\u0026#34;java.lang.Exception\u0026#34;).$new()); console.log(\u0026#34;\\nBacktrace:\\n\u0026#34; + bt); return this.getPinAlgorithms(); } And nothing was printed. My next idea was that the first if was evaluated to true, and that was the reason it didn\u0026rsquo;t get to the rest of the method. To check which conditions were the ones that made the method exit, I added the following lines to the script:\nNetworkSecurityTrustManager.checkPins.implementation = function (pins) { var bt = Java.use(\u0026#34;android.util.Log\u0026#34;).getStackTraceString(Java.use(\u0026#34;java.lang.Exception\u0026#34;).$new()); console.log(\u0026#34;\\nBacktrace:\\n\u0026#34; + bt); pinSet = this.mNetworkSecurityConfig.value.getPins(); console.log(\u0026#34;pinSet.pins.value.isEmpty: \u0026#34; +pinSet.pins.value.isEmpty()); console.log(\u0026#34;isPinningEnforced: \u0026#34; +this.isPinningEnforced(pins)); console.log(\u0026#34;pins.isEmpty: \u0026#34; +pins.isEmpty()); console.log(System.currentTimeMillis()) console.log(pinSet.expirationTime.value); console.log(System.currentTimeMillis() \u0026gt; pinSet.expirationTime.value); this.checkPins(pins); } So after running the application I got the following output:\npinSet.pins.value.isEmpty: false isPinningEnforced: false \u0026lt;-- this condition is the problematic one pins.isEmpty: false 1562031248274 9223372036854775807 false As it can be seen, the isPinningEnforced was evaluated to false and then as it was negated, it transformed all the expression to true.\nThe method has the following implementation:\nprivate boolean isPinningEnforced(List\u0026lt;X509Certificate\u0026gt; chain) throws CertificateException { if (chain.isEmpty()) { return false; } X509Certificate anchorCert = chain.get(chain.size() - 1); TrustAnchor chainAnchor = mNetworkSecurityConfig.findTrustAnchorBySubjectAndPublicKey(anchorCert); if (chainAnchor == null) { throw new CertificateException(\u0026#34;Trusted chain does not end in a TrustAnchor\u0026#34;); } return !chainAnchor.overridesPins; } I knew the chain wasn\u0026rsquo;t empty, as I already executed the evaluation of the List, so the problem should ne in the findTrustAnchorBySubjectAndPublicKey, which returned a chainAnchor with the attribute overridesPins in true.\nThe findTrustAnchorBySubjectAndPublicKey method is implemented in the NetworkSecurityConfig class:\npublic TrustAnchor findTrustAnchorBySubjectAndPublicKey(X509Certificate cert) { for (CertificatesEntryRef ref : mCertificatesEntryRefs) { TrustAnchor anchor = ref.findBySubjectAndPublicKey(cert); if (anchor != null) { return anchor; } } return null; } It iterates over all the CertificatesEntryRef created during the seting up, and returns the first one that matches the SubjectAndPublicKey. In this scenario it will always return the ones from the proxy. After reading the source code I went to the CertificatesEntryRef class to check where the classes were instantiated, and found that the only constructor was the following one:\npublic CertificatesEntryRef(CertificateSource source, boolean overridesPins) { mSource = source; mOverridesPins = overridesPins; } If you read the frida script again, you will see that the CertificatesEntryRef were created in the following way:\nNetworkSecurityConfig_Builder.getEffectiveCertificatesEntryRefs.implementation = function(){ origin = this.getEffectiveCertificatesEntryRefs() source = UserCertificateSource.getInstance() userCert = CertificatesEntryRef.$new(source,true) \u0026lt;-- sets overridesPins in true origin.add(userCert) return origin } And that is the reason why this script works for all the scenarios.\nnetwork-security-config-bypass-2.js Original Reference: Link\nIn this case, the only case that worked was the one where the network security config file was not present. I analyzed why this patch didn\u0026rsquo;t work. The issue is in the XmlConfigSource in the method \u0026ldquo;parseNetworkSecurityConfig\u0026rdquo;:\nXmlUtils.beginDocument(parser, \u0026#34;network-security-config\u0026#34;); int outerDepth = parser.getDepth(); while (XmlUtils.nextElementWithin(parser, outerDepth)) { //here it creates a NetworkSecurityconfig.Builder based on the xml structure.  ... } ... NetworkSecurityConfig.Builder platformDefaultBuilder = NetworkSecurityConfig.getDefaultBuilder(mTargetSdkVersion); \u0026lt;-- this is the method changed with the script addDebugAnchorsIfNeeded(debugConfigBuilder, platformDefaultBuilder); //baseConfigBuilder is null only if the xml network-security-config is not defined in the AndroidManifest.xml  if (baseConfigBuilder != null) { baseConfigBuilder.setParent(platformDefaultBuilder); addDebugAnchorsIfNeeded(debugConfigBuilder, baseConfigBuilder); } else { baseConfigBuilder = platformDefaultBuilder; } ... mDefaultConfig = baseConfigBuilder.build(); mDomainMap = configs; } The build method generates the NetworkSecurityConfig entity:\npublic NetworkSecurityConfig build() { boolean cleartextPermitted = getEffectiveCleartextTrafficPermitted(); boolean hstsEnforced = getEffectiveHstsEnforced(); PinSet pinSet = getEffectivePinSet(); List\u0026lt;CertificatesEntryRef\u0026gt; entryRefs = getEffectiveCertificatesEntryRefs(); return new NetworkSecurityConfig(cleartextPermitted, hstsEnforced, pinSet, entryRefs); } The valid certificate sources are defined in the entryRefs variable, which is constructed as:\nprivate List\u0026lt;CertificatesEntryRef\u0026gt; getEffectiveCertificatesEntryRefs() { if (mCertificatesEntryRefs != null) { return mCertificatesEntryRefs; } if (mParentBuilder != null) { return mParentBuilder.getEffectiveCertificatesEntryRefs(); } return Collections.\u0026lt;CertificatesEntryRef\u0026gt;emptyList(); } In this case mCertificatesEntryRefs is not null, as it returns the standard SystemCertificateSource (looks for all the certs in the system ca folder). So the mParentBuilder (the one modified in the script) is never called.\nLater on, when the server certificate is validated, the application calls the method NetworkSecurityConfig.findTrustAnchorBySubjectAndPublicKey, which filters the valid certificates from the system folder:\npublic TrustAnchor findTrustAnchorBySubjectAndPublicKey(X509Certificate cert) { for (CertificatesEntryRef ref : mCertificatesEntryRefs) { TrustAnchor anchor = ref.findBySubjectAndPublicKey(cert); if (anchor != null) { return anchor; } } return null; } leading to the exception thrown in the stacktrace, because there aren\u0026rsquo;t coincidences as the certificate return by the server is self-signed:\ncom.android.org.conscrypt.TrustManagerImpl.checkTrusted(TrustManagerImpl.java:375) at com.android.org.conscrypt.TrustManagerImpl.getTrustedChainForServer(TrustManagerImpl.java:304) at android.security.net.config.NetworkSecurityTrustManager.checkServerTrusted(NetworkSecurityTrustManager.java:94) at android.security.net.config.RootTrustManager.checkServerTrusted(RootTrustManager.java:88) ... network-security-config-bypass-3.js Original Reference: Link\nThis works in two of the three scenarios, because the patch is executed in the method that validates certificates. But it does not work in the third scenario because the pin validation is executed in other method, as shown in the error stacktrace:\nat android.security.net.config.NetworkSecurityTrustManager.checkPins(NetworkSecurityTrustManager.java:148) at android.security.net.config.NetworkSecurityTrustManager.checkServerTrusted(NetworkSecurityTrustManager.java:95) at android.security.net.config.RootTrustManager.checkServerTrusted(RootTrustManager.java:88) at com.android.org.conscrypt.Platform.checkServerTrusted(Platform.java:203) at com.android.org.conscrypt.OpenSSLSocketImpl.verifyCertificateChain(OpenSSLSocketImpl.java:592) at com.android.org.conscrypt.NativeCrypto.SSL_do_handshake(Native Method) at com.android.org.conscrypt.OpenSSLSocketImpl.startHandshake(OpenSSLSocketImpl.java:351) ... 25 more network-security-config-bypass-cr.js In this case the method patched is getConfigSource, which is called when the network-security-config is parsed. As it can be seen, the reimplementation proposed creates a DefaultConfigSource, setting as a parameter the android version 23. So regardless of the file uploaded in the application, it will always retrieve the configuration of Android 23 (adds user certificates, does not validate certificate pinning, and allows http communication at http level).\nConclusion: I could achieve my goal, that was finding a script to bypass the network security configuration implemented by the Android SDK. Creating a new alternative to the one I found was a bonus track. During the process I learnt many aspects of the SDK, frida and the Android ecosystem. It is not easy to find bypasses. The hardest part during my analysis was the definition and setting up of all the environment to execution different test scenarios. Adding a new script, a new way to execute requests or another SDK would lead to at least 18 new cases. I guess this is the main reason many of the scripts I found worked for some cases (but not for all of them).\n","permalink":"https://cmrodriguez.me/blog/nsc-bypass/","tags":["Frida","Android"],"title":"Analysis of Network Security Configuration bypasses with Frida"},{"categories":["Frida","Android"],"contents":"In this post I will explain how to try exception handling in Java with Frida. While working on Frida scripts it is usually common to get an error that will crash the script or even the application. So to reliably create applications powered by Frida it is advisable to protect the code from unexpected errors by using exceptions, as shown in the following example:\ntry { var instanceInnerClass = InnerClass.$new(); } catch (e) { var instanceOuterClass = OuterClass.$new(); var instanceInnerClass = InnerClass.$new(instanceOuterClass); } finally { //always gets to this part. } So if any error happens when you call the InnerClass.$new(), the script won\u0026rsquo;t crash, and the execution will follow.\nJava exception handling from Frida When an exception is thrown, Frida generates a javascript exception as well The variable thrown is a JSON with a $handle structure, so we have to cast it to an appropriate class. Depending on the situation we might or might not know which exception can be thrown based on the source code. So in order to handle all the possible exceptions thrown by Java, we need to cast it to a \u0026ldquo;java.lang.Throwable\u0026rdquo; class, and then cast it to the specific class (only if you want to do something specific related to the exception class):\nvar testExceptions = function () { var ThrowingExceptionClass = Java.use(\u0026#34;com.blog.testfrida.exceptions.ThrowingExceptionClass\u0026#34;); try { ThrowingExceptionClass.callException(); } catch (ex) { //ex is a handle, you have to cast it.  var Exception = Java.use(\u0026#34;java.lang.Trowable\u0026#34;); var item = Java.cast(ex,Exception); var SpecificException = Java.use(item.$className); item = Java.cast(ex,SpecificException); console.log(item.attribute.value); } } ","permalink":"https://cmrodriguez.me/blog/exception-handling/","tags":["Frida","Android","Scripting guide"],"title":"Frida Scripting Guide (10) - Exception Handling"},{"categories":["Frida","Android"],"contents":"In this blogpost I will explain how to access different methods with different visibilities in a class through Frida. Whenever we work with Java we have four scopes available applicable to a class, method or attribute. The following table shows what each scope means.\n   Class Package Subclass (same pkg) Subclass (diff pkg) World      public + + + + +   protected + + + +    no modifier + + +     private +          : accessible blank : not accessible   As an example a private method can only be invoked by the class or instance that owns the method (if it is not static, just by an instance). The static methods and objects can be used from a Frida script independently of the scope modifier, as shown in the following example:\nvar ScopeObject = Java.use(\u0026#34;com.blog.testfrida.complexobjects.ScopeObject\u0026#34;); console.log(\u0026#34;private static object:\u0026#34; + ScopeObject.privateStaticObject.value); console.log(\u0026#34;protected static object:\u0026#34; + ScopeObject.protectedStaticObject.value); console.log(\u0026#34;public static object:\u0026#34; + ScopeObject.publicStaticObject.value); console.log(\u0026#34;static object:\u0026#34; + ScopeObject.nonModifiedStaticObject.value); console.log(\u0026#34;private static method:\u0026#34; + ScopeObject.privateStaticMethod()); console.log(\u0026#34;protected static method:\u0026#34; + ScopeObject.protectedStaticMethod()); console.log(\u0026#34;public static method:\u0026#34; + ScopeObject.publicStaticMethod()); console.log(\u0026#34;static method:\u0026#34; + ScopeObject.nonModifiedStaticMethod()); In order to use the attributes and methods of an instance, we need to create an instance by calling its constructor. Frida acts like in the case of the static methods and attributes:\nvar ScopeObject = Java.use(\u0026#34;com.blog.testfrida.complexobjects.ScopeObject\u0026#34;); var scopeInstance = ScopeObject.$new(); console.log(\u0026#34;private object:\u0026#34; + scopeInstance.privateObject.value); console.log(\u0026#34;protected object:\u0026#34; + scopeInstance.protectedObject.value); console.log(\u0026#34;public object:\u0026#34; + scopeInstance.publicObject.value); console.log(\u0026#34;object:\u0026#34; + scopeInstance.nonModifiedObject.value); console.log(\u0026#34;private method:\u0026#34; + scopeInstance.privateMethod()); console.log(\u0026#34;protected method:\u0026#34; + scopeInstance.protectedMethod()); console.log(\u0026#34;public method:\u0026#34; + scopeInstance.publicMethod()); console.log(\u0026#34;method:\u0026#34; + scopeInstance.nonModifiedMethod()); Next: \u0026ldquo;this\u0026rdquo; reference\n","permalink":"https://cmrodriguez.me/blog/classes-content/","tags":["Frida","Android","Scripting guide"],"title":"Frida Scripting Guide (3) - Access to content of classes"},{"categories":["Frida","Android"],"contents":"In this post I\u0026rsquo;ll show how to access the this reference. In Java (and a lot of other languages as well) there is always a special variable called this that references the object which is running the method. In Frida, whenever someone is rewriting a method, he has access to the \u0026ldquo;this\u0026rdquo; parameter. Check the following script as an example:\nBasicTypes.addTwoInts.implementation = function (var1,var2) { console.log(\u0026#34;the method is being called\u0026#34;); return this.addTwoInts(var1,var2); } In this case the \u0026ldquo;this\u0026rdquo; references the class BasicTypes. So by calling the \u0026ldquo;this.addTwoInts\u0026rdquo; we are calling the original implementation of the method, instead of reimplementing it. This feature is useful for many use cases as:\n know if a method is being called (as shown in the example above) print the input values to know what is being received by the function. print the stack trace to know where it is being called.  In all these cases the idea is not to change the workflow of the methods, just trace or debug the functionality.\nNext: Arrays\n","permalink":"https://cmrodriguez.me/blog/this-reference/","tags":["Frida","Android","Scripting guide"],"title":"Frida Scripting Guide (4) - 'this' Reference"},{"categories":["Frida","Android"],"contents":"In this post I\u0026rsquo;ll explain how to use arrays from Java in Frida. Arrays are transformed in Frida from Javascript to Java transparently, so there is no special consideration, as shown in the following examples:\nvar intArray = [1, 2, 3]; console.log(ArrayType.sumArray(intArray)); This example shows a transformation from a javascript Array to a Java array.\nArrayType.sumArray.overload(\u0026#34;[I\u0026#34;).implementation = function (arrayList) { var total = 0; for (var i = 0; i \u0026lt; arrayList.length; i++) { total += arrayList[i]; } console.log(\u0026#34;Entra en arrayInt sumArray: \u0026#34; + total); return total; } This method receives an array in Java. When the Frida user writes the reimplementation function, they will receive a Javascript Array.\n Warning The forEach structure (used in Javascript) to iterate on an array does not work.\n Whenever the following code is called:\nvar total = 0.0; arrayList.forEach(function (element) { total += element; }); the frida server generates an error:\nTypeError: undefined not callable (property \u0026#39;forEach\u0026#39; of [object Object]) at [anon] (../../../frida-gum/bindings/gumjs/duktape.c:65012) at /examples.js:278 at input:1 Working with array of Objects is like working with native types, with the exception that a position in the Array can be null, so it must be taken in consideration when the script is being developed, as in the following example:\nvar peopleArray = ArrayType.getAllPeople(); for (var i = 0; i \u0026lt; peopleArray.length; i++) { if (peopleArray[i] == null) { console.log(i + \u0026#34; - null\u0026#34;); } else { console.log(peopleArray[i].getId()+\u0026#34; - \u0026#34;+peopleArray[i].getName() + \u0026#34; - \u0026#34; + peopleArray[i].getAge()); } }  Note A null value in the Java array is translated to a null javascript value automatically by the framework.\n Next: Enums\n","permalink":"https://cmrodriguez.me/blog/arrays/","tags":["Frida","Android","Scripting guide"],"title":"Frida Scripting Guide (5) - Arrays"},{"categories":["Frida","Android"],"contents":"It is a bit complicated to work on Enums. There is a difference between Enums and common classes. The latter has multiple values but no status. So it is usually used to hold finite and semantically strong status, like in the following case months of a year (in Java code):\nenum Month { JAN, FEB, MAR, APR, MAY, JUN, JUL, AUG, SEP, OCT, NOV, DEC } To set a value you have to define the value to set:\nMonth month = Month.APR; In Frida we have the following possibilties:\n Generate a Frida reference to the enum  Month = Java.use(\u0026#34;com.blog.testfrida.complexobjects.DateAbstraction$Month\u0026#34;); Get all the possible values (it returns an array, so it can be iterated as shown in the array part of this guide):  Month.values(); Print the value of a particular state. Note that we need a .value to get to the real value and not the wrapper of the status:  //Month has not redefined the toString so it calls the Object one console.log(Month.APR.value);  The toString method does not work in this case, as it will print the generic \u0026quot;[object Object]\u0026quot; string.\n  Instantiate a Month value based on a String, and send it as a parameter (there are two ways to send it as a parameter to the Java method):\n  console.log(DateAbstraction.getMonthName(Month.valueOf(String.$new(\u0026#34;APR\u0026#34;)))); console.log(DateAbstraction.getMonthName(Month.APR.value)); While writing this guide I had issues finding a way to get the value from a method (when it returns an Enum) and get the value when You want to override a method. The following example does not work as expected. We have the following code in Java:\npublic static Month getMay() { return Month.MAY; } When we get the result from Frida:\nMay = DateAbstraction.getMay(); the object returned seems to be the Month enum itself and not the particular value (so as an example the .value does not work with the May object). I\u0026rsquo;ll post a bug in the Frida repo and will update the result.\nNext: Inheritance\n","permalink":"https://cmrodriguez.me/blog/enums/","tags":["Frida","Android","Scripting guide"],"title":"Frida Scripting Guide (6) - Enums"},{"categories":["Frida","Android"],"contents":"In this post I will show how to use inheritance in Java from Frida. Java as a OOP language has the inheritance feature. When one class inherits from another class in Java, the two classes take on certain roles. The class that extends (inherits from another class) is the subclass and the class that is being extended (the class being inherited from) is the superclass. In other words, the subclass extends the superclass. Or, the subclass inherits from the superclass. The subclass inherits the attributes and methods from their parents, so a subclass behaves like a superclass.\npublic static double getPerimeter(Figure figure) { return figure.perimeter(); } As it can be seen it receives a \u0026ldquo;Figure\u0026rdquo; class type. As the Circle and Square classes are figures (because of inheritance), you can send any instance of these two classes to the getPerimeter method. Let\u0026rsquo;s do this with Frida:\nvar TestInheritance = Java.use(\u0026#34;com.blog.testfrida.inheritance.TestInheritance\u0026#34;); var Square = Java.use(\u0026#34;com.blog.testfrida.inheritance.Square\u0026#34;); var squareInstance = Square.$new(5); console.log(\u0026#34;square perimeter: \u0026#34; + TestInheritance.getPerimeter(squareInstance)); In Frida you can work with inherited classes as you would do directly in Java, as the methods automatically casts the object to the right type.\npublic static double getPerimeter(Figure figure) { return figure.perimeter(); } When we retrieve the value from Frida and check the class:\nvar figureInstance = TestInheritance.getCircle(); console.log(figureInstance.$className); we get that the className is \u0026lsquo;com.blog.testfrida.inheritance.Circle'. But when we try to use a method that is in the Circle only (getCircleName) we get that the method is undefined. This means the object is casted to a Figure:\nvar figureInstance = TestInheritance.getCircle(); if (figureInstance.getCircleName === undefined) { console.log(\u0026#34;Instance is figure, the getCircleName does not exist.\u0026#34;); } else { console.log(figureInstance.getCircleName()); } To access the circle method, we should cast it:\ncircleInstance = Java.cast(figureInstance,Circle); console.log(circleInstance.getCircleName()); Sometimes in Java we want to reuse some code of a parent class, but we want to add some component that exists or makes sense only in the subclass. As an example a constructor that sets all the private attributes to a default value. As an example, in the Android application I created two classes. One is SuperClass, and the other SubClass. In the SuperClass we have the \u0026ldquo;superValue\u0026rdquo;. In the constructor we set its value to 10:\npublic SuperClass() { superValue = 10; } The SubClass has two attributes that are being set in the constructor.\npublic SubClass() { super(); subValue = 10; setValue = 10; } To avoid copy the SuperClass content to the SubClass constructor (in some cases it isn\u0026rsquo;t even possible), Java has a \u0026ldquo;super\u0026rdquo; attribute that points to the SuperClass object. We can use it to call the SuperClass method, so then when we use the SubClass method to get the superValue, we\u0026rsquo;ll see that it was set to 10.\n//In this case I rewrote a new function that has a super implementation SubClass.$init.implementation = function () { var superInheritance = Java.cast(this,SuperClass); superInheritance.$init(); this.subValue.value = 25; } There a couple of things to tell about this example. When you want to change or intercept a constructor, you need to modify the $init function in Frida. To call the super class, you need to cast the \u0026ldquo;this\u0026rdquo; variable (reference to itself).\nNext: Interfaces\n","permalink":"https://cmrodriguez.me/blog/inheritance/","tags":["Frida","Android","Scripting guide"],"title":"Frida Scripting Guide (8) - Inheritance"},{"categories":["Frida","Android"],"contents":"An interface is a reference type in Java. It is similar to class. It is a collection of abstract methods. A class implements an interface, thereby inheriting the abstract methods of the interface.\nAlong with abstract methods, an interface may also contain constants, default methods, static methods, and nested types. Method bodies exist only for default methods and static methods.\nAn interface is different from a class in several ways:\n You cannot instantiate an interface. An interface does not contain any constructors. All of the methods in an interface are abstract. An interface cannot contain instance fields. The only fields that can appear in an interface must be declared both static and final. An interface is not extended by a class; it is implemented by a class.  To test this functionality I\u0026rsquo;ve created in the application an interface called MyInterface, and a class that implements the interface called MyInterfaceClass.\nIn order to get the interface representation in Frida we use the same code as we would use for a class:\nMyInterface = Java.use(\u0026#34;com.blog.testfrida.interfaces.MyInterface\u0026#34;); We can\u0026rsquo;t intercept or modify the abstract methods exposed by the interface. As an example I tried to implement the getMessage method from the interface in the following way:\nMyInterface.getMessage.implementation = function () { console.log(\u0026#34;it gets into the getMessage\u0026#34;); return String.$new(\u0026#34;it works\u0026#34;); } When we call the getMessage from the implementation of the getMessage method in the MyInterfaceClass, the console.log is not triggered. If we want to change the implementation, we have to do it in each class the abstract method is implemented. In this case we did it on the only class implementing MyInterface:\nvar MyInterfaceClass = Java.use(\u0026#34;com.blog.testfrida.interfaces.MyInterfaceClass\u0026#34;); MyInterfaceClass.getMessage.implementation = function () { console.log(\u0026#34;it gets into the getMessage\u0026#34;); return String.$new(\u0026#34;it works\u0026#34;); } Note that we can\u0026rsquo;t instantiate an interface, it will throw the following error:\nError: no supported overloads at makeConstructor (frida/node_modules/frida-java-bridge/lib/class-factory.js:478) ... at /examples.js:434 When we get an instance of a class that implements an interface, we can call the interfaces\u0026rsquo; methods, but Frida will end up calling the classes implementations as in the following examples:\n//we get an instance of Interface and call the getMessage var interfaceInstance = MyInterfaceClass.getNewInstance(); //internally it calls the getMessage from the MyInterfaceClass console.log(interfaceInstance.getMessage()); //this does not call the default interface, it calls the class one (even when it is //casted as a MyInterface interface) console.log(interfaceInstance.getInt()); Next: Inner classes\n","permalink":"https://cmrodriguez.me/blog/interfaces/","tags":["Frida","Android","Scripting guide"],"title":"Frida Scripting Guide (8) - Interfaces"},{"categories":["Frida","Android"],"contents":"In this blogpost I will show how to consume inner classes in Java from Frida. In Java nested classes are classes that are defined inside another class. The purpose of a nested class is to clearly group the nested class with its surrounding class, signaling that these two classes are to be used together. Or perhaps that the nested class is only to be used from inside its enclosing (owning) class.\nAs an example the following are nested classes:\npublic class OuterClass { ... class InnerClass { public char getInnerChar() { return \u0026#39;i\u0026#39;; } } } In order to get with Frida to the InnerClass we have to use the following code:\nvar InnerClass = Java.use(\u0026#34;com.blog.testfrida.innerclasses.OuterClass$InnerClass\u0026#34;); var OuterClass = Java.use(\u0026#34;com.blog.testfrida.innerclasses.OuterClass\u0026#34;); If the inner class is instantiated as a static public class, it can be used in a code as a common class (besides the OuterClass, that always has access to the InnerClass). But if the class is configured as shown in the example the following code will generate an error:\nvar instanceInnerClass = InnerClass.$new(); It will fail because the InnerClass will have by default a constructor that receives an instance from the OuterClass (as the declaration of the class is not static). So to create an instance we need to execute the following code in Frida:\nvar instanceOuterClass = OuterClass.$new(); var instanceInnerClass = InnerClass.$new(instanceOuterClass); So the reference to the OuterClass is stored in an internal attribute. In order to ge acces to it from a reimplementation of a method we can use the this$0 reference as in the following example:\nInnerClass.getInnerChar.implementation = function () { //reference to outer class, and call a method  console.log(this.this$0.value.getIdOuterClass()); //reference to outer class, and call an attribute  console.log(this.this$0.value.val.value); return \u0026#39;j\u0026#39;; } There is another type of innerclass called Anonymous Inner Class. It is an inner class without a name and for which only a single object is created. An anonymous inner class can be useful when making an instance of an object with certain “extras” such as overloading methods of a class or interface, without having to actually subclass a class. The following is an example of an anonymous inner class:\npublic class AnonymousInnerClass { public String getMessageAnonymous() { InnerInterface inner = new InnerInterface() { @Override public String getMessage() { return \u0026#34;getMessage\u0026#34;; } }; return inner.getMessage(); } } Even when the anonmyous class seems not to have a name, Java internally at compile type generates a common nested class with a numeric name (starting in 1). In order to abstract ourselves from the name Java assigns to the class we can use the following code in Frida:\nJava.enumerateLoadedClasses( { \u0026#34;onMatch\u0026#34;: function(className){ if(className.includes(\u0026#34;com.blog.testfrida.innerclasses.AnonymousInnerClass$\u0026#34;)){ console.log(className); } }, \u0026#34;onComplete\u0026#34;:function(){} } ); This code snippet lists all the classes loaded in the VM by name. As we know that the anonymous class is created as an inner class, we know that the full classpath will be $. So we filter all the classes that starts with that name. As a caveat, the first time I listed all the inner classes from AnonymousInnerClass, I could find none. After some minutes of analyzing the reason I realized that it has not been loaded by a ClassLoader yet, as it was never used in the application. So I forced the VM to load it basically instantiating it:\nvar AnonymousInnerClass = Java.use(\u0026#34;com.blog.testfrida.innerclasses.AnonymousInnerClass\u0026#34;); var instanceAnonymous = AnonymousInnerClass.$new(); And after that I could achieve the dynamic instrumentation of the anonymous inner class:\nJava.enumerateLoadedClasses( { \u0026#34;onMatch\u0026#34;: function(className){ if(className.includes(\u0026#34;com.blog.testfrida.innerclasses.AnonymousInnerClass\u0026#34;)){ if (className.includes(\u0026#34;$\u0026#34;)) { var anonymousClass = Java.use(className); anonymousClass.getMessage.implementation = function () { return \u0026#34;it works well :)\u0026#34;; } } } }, \u0026#34;onComplete\u0026#34;:function(){} } ); Next: Exception handling\n","permalink":"https://cmrodriguez.me/blog/inner-classes/","tags":["Frida","Android","Scripting guide"],"title":"Frida Scripting Guide (9) - Inner Classes"}]